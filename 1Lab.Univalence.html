<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>

<head>
  <meta charset="utf-8"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
  <meta name="keywords" content="Agda,categories,topos"></meta>

  <title>1Lab.Univalence - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css"></link>
  <link rel="stylesheet" href="/css/katex.min.css"></link>
  <link rel="stylesheet" href="/css/agda-cats.css"></link>

  <meta name="twitter:card" content="summary"></meta>
  <meta name="twitter:title" content="1Lab.Univalence - 1Lab"></meta>
  <meta name="twitter:image" content="https://cubical.1lab.dev/static/cube-128x.png"></meta>

  <meta name="og:title" content="1Lab.Univalence - 1Lab"></meta>
  <meta name="og:image" content="https://cubical.1lab.dev/static/cube-128x.png"></meta>
  <meta name="og:site-name" content="The 1Lab"></meta>
  <meta name="og:type" content="website"></meta>
    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  
  <script src="/equations.js" type="text/javascript"></script> 
  <script src="/highlight-hover.js" type="text/javascript"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0;">
                <a class="Module">1Lab.Univalence</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto; height: 32px;"></img>
      
      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr></hr>
      <ul class="incremental">
      <li><a href="#univalence">Univalence</a>
      <ul class="incremental">
      <li><a href="#glue">Glue</a></li>
      <li><a href="#paths-from-glue">Paths from Glue</a></li>
      <li><a href="#paths-over-ua">Paths over ua</a></li>
      </ul></li>
      <li><a href="#the-axiom">The “axiom”</a>
      <ul class="incremental">
      <li><a href="#equivalence-induction">Equivalence Induction</a></li>
      <li><a href="#object-classifiers">Object Classifiers</a></li>
      </ul></li>
      </ul>
      <hr></hr>

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr></hr>

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/e8a5036abd8b717920913d468aa0218168c894d1/src/1Lab/Univalence.lagda.md">link to source</a> <br />
      </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="33" class="Keyword">open</a> <a id="38" class="Keyword">import</a> <a id="45" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a>
<a id="56" class="Keyword">open</a> <a id="61" class="Keyword">import</a> <a id="68" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="78" class="Keyword">open</a> <a id="83" class="Keyword">import</a> <a id="90" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="101" class="Keyword">module</a> <a id="108" href="1Lab.Univalence.html" class="Module">1Lab.Univalence</a> <a id="124" class="Keyword">where</a>
</pre>
<h1 id="univalence">Univalence</h1>
<p>In Homotopy Type Theory, <strong>univalence</strong> is the principle stating that <a href="1Lab.Equiv.html#_≃_">equivalent</a> types can be <a href="1Lab.Path.html#Path">identified</a>. When <a href="https://homotopytypetheory.org/book">the book</a> first came out, there was no widely-accepted <em>computational</em> interpretation of this principle, so it was added to the theory as an axiom: the <strong>univalence axiom</strong>.</p>
<p>Precisely, the axiom as presented in the book consists of the following data (right under remark §2.10.4):</p>
<ul class="incremental">
<li><p>A map which turns equivalences into propositional equalities of type. This map is called <span class="Agda"><a href="1Lab.Univalence.html#8768" class="Function">ua</a></span>.</p></li>
<li><p>A rule for eliminating equalities of types, by turning them into equivalences: <span class="Agda"><a href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a></span></p></li>
<li><p>The propositional computation rule, stating that transport along <code>ua(f)</code> is equal to applying <code>f</code>: <span class="Agda"><a href="1Lab.Univalence.html#10927" class="Function">uaβ</a></span>.</p></li>
</ul>
<p>In the book, there is an extra postulated datum asserting that <span class="Agda"><a href="1Lab.Univalence.html#8768" class="Function">ua</a></span> is an inverse to <span class="Agda"><a href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a></span>. This datum does not have a name in this development, because it’s proved in-line in the construction of the term <span class="Agda"><a href="1Lab.Univalence.html#16724" class="Function">univalence</a></span>.</p>
<p>The point of cubical type theory is to give these terms constructive interpretations, i.e., make them definable in the theory, in terms of constructions that have computational behaviour. Let’s see how this is done.</p>
<h2 id="glue">Glue</h2>
<p>To even <em>state</em> univalence, we first have to make sure that the concept of “paths between types” makes sense in the first place. In “Book HoTT”, paths between types are a well-formed concept because the path type is uniformly inductively defined for <em>everything</em> — including universes. This is not the case in Cubical type theory, where for paths in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> to be well-behaved, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> must <a href="1Lab.Path.html#fibrant">be <em>fibrant</em></a>.</p>
<p>Since there’s no obvious choice for how to interpret <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> in <span class="Agda"><a href="1Lab.Type.html#394" class="Primitive">Type</a></span>, a fine solution is to make <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> its own type former. This is the approach taken by some Cubical type theories in the <a href="https://redprl.org/">RedPRL school</a>. Univalence in those type theories is then achieved by adding a type former, called <code>V</code>, which turns an equivalence into a path.</p>
<p>In <a href="https://arxiv.org/abs/1611.02108">CCHM</a> — and therefore Cubical Agda — a different approach is taken, which combines proving univalence with defining a fibrancy structure for the universe. The core idea is to define a new type former, <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span>, which “glues” a <a href="1Lab.Path.html#partial-elements">partial type</a>, along an equivalence, to a total type.</p>
<!--
<pre class="Agda"><a id="2786" class="Keyword">private</a>
  <a id="2796" class="Keyword">variable</a>
    <a id="2809" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a> <a id="2811" href="1Lab.Univalence.html#2811" class="Generalizable">ℓ&#39;</a> <a id="2814" class="Symbol">:</a> <a id="2816" href="Agda.Primitive.html#597" class="Postulate">Level</a>

  <a id="2825" class="Keyword">primitive</a>
    <a id="primGlue"></a><a id="2839" href="1Lab.Univalence.html#2839" class="Primitive">primGlue</a> <a id="2848" class="Symbol">:</a> <a id="2850" class="Symbol">(</a><a id="2851" href="1Lab.Univalence.html#2851" class="Bound">A</a> <a id="2853" class="Symbol">:</a> <a id="2855" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2860" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="2861" class="Symbol">)</a> <a id="2863" class="Symbol">{</a><a id="2864" href="1Lab.Univalence.html#2864" class="Bound">φ</a> <a id="2866" class="Symbol">:</a> <a id="2868" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="2869" class="Symbol">}</a>
             <a id="2884" class="Symbol">→</a> <a id="2886" class="Symbol">(</a><a id="2887" href="1Lab.Univalence.html#2887" class="Bound">T</a> <a id="2889" class="Symbol">:</a> <a id="2891" href="Agda.Primitive.Cubical.html#699" class="Primitive">Partial</a> <a id="2899" href="1Lab.Univalence.html#2864" class="Bound">φ</a> <a id="2901" class="Symbol">(</a><a id="2902" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2907" href="1Lab.Univalence.html#2811" class="Generalizable">ℓ&#39;</a><a id="2909" class="Symbol">))</a> <a id="2912" class="Symbol">→</a> <a id="2914" class="Symbol">(</a><a id="2915" href="1Lab.Univalence.html#2915" class="Bound">e</a> <a id="2917" class="Symbol">:</a> <a id="2919" href="Agda.Primitive.Cubical.html#733" class="Primitive">PartialP</a> <a id="2928" href="1Lab.Univalence.html#2864" class="Bound">φ</a> <a id="2930" class="Symbol">(λ</a> <a id="2933" href="1Lab.Univalence.html#2933" class="Bound">o</a> <a id="2935" class="Symbol">→</a> <a id="2937" href="1Lab.Univalence.html#2887" class="Bound">T</a> <a id="2939" href="1Lab.Univalence.html#2933" class="Bound">o</a> <a id="2941" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="2943" href="1Lab.Univalence.html#2851" class="Bound">A</a><a id="2944" class="Symbol">))</a>
             <a id="2960" class="Symbol">→</a> <a id="2962" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2967" href="1Lab.Univalence.html#2811" class="Generalizable">ℓ&#39;</a>

    <a id="prim^glue"></a><a id="2975" href="1Lab.Univalence.html#2975" class="Primitive">prim^glue</a> <a id="2985" class="Symbol">:</a> <a id="2987" class="Symbol">{</a><a id="2988" href="1Lab.Univalence.html#2988" class="Bound">A</a> <a id="2990" class="Symbol">:</a> <a id="2992" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2997" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="2998" class="Symbol">}</a> <a id="3000" class="Symbol">{</a><a id="3001" href="1Lab.Univalence.html#3001" class="Bound">φ</a> <a id="3003" class="Symbol">:</a> <a id="3005" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="3006" class="Symbol">}</a>
              <a id="3022" class="Symbol">→</a> <a id="3024" class="Symbol">{</a><a id="3025" href="1Lab.Univalence.html#3025" class="Bound">T</a> <a id="3027" class="Symbol">:</a> <a id="3029" href="Agda.Primitive.Cubical.html#699" class="Primitive">Partial</a> <a id="3037" href="1Lab.Univalence.html#3001" class="Bound">φ</a> <a id="3039" class="Symbol">(</a><a id="3040" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3045" href="1Lab.Univalence.html#2811" class="Generalizable">ℓ&#39;</a><a id="3047" class="Symbol">)}</a> <a id="3050" class="Symbol">→</a> <a id="3052" class="Symbol">{</a><a id="3053" href="1Lab.Univalence.html#3053" class="Bound">e</a> <a id="3055" class="Symbol">:</a> <a id="3057" href="Agda.Primitive.Cubical.html#733" class="Primitive">PartialP</a> <a id="3066" href="1Lab.Univalence.html#3001" class="Bound">φ</a> <a id="3068" class="Symbol">(λ</a> <a id="3071" href="1Lab.Univalence.html#3071" class="Bound">o</a> <a id="3073" class="Symbol">→</a> <a id="3075" href="1Lab.Univalence.html#3025" class="Bound">T</a> <a id="3077" href="1Lab.Univalence.html#3071" class="Bound">o</a> <a id="3079" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="3081" href="1Lab.Univalence.html#2988" class="Bound">A</a><a id="3082" class="Symbol">)}</a>
              <a id="3099" class="Symbol">→</a> <a id="3101" href="Agda.Primitive.Cubical.html#733" class="Primitive">PartialP</a> <a id="3110" href="1Lab.Univalence.html#3001" class="Bound">φ</a> <a id="3112" href="1Lab.Univalence.html#3025" class="Bound">T</a> <a id="3114" class="Symbol">→</a> <a id="3116" href="1Lab.Univalence.html#2988" class="Bound">A</a> <a id="3118" class="Symbol">→</a> <a id="3120" href="1Lab.Univalence.html#2839" class="Primitive">primGlue</a> <a id="3129" href="1Lab.Univalence.html#2988" class="Bound">A</a> <a id="3131" href="1Lab.Univalence.html#3025" class="Bound">T</a> <a id="3133" href="1Lab.Univalence.html#3053" class="Bound">e</a>

    <a id="prim^unglue"></a><a id="3140" href="1Lab.Univalence.html#3140" class="Primitive">prim^unglue</a> <a id="3152" class="Symbol">:</a> <a id="3154" class="Symbol">{</a><a id="3155" href="1Lab.Univalence.html#3155" class="Bound">A</a> <a id="3157" class="Symbol">:</a> <a id="3159" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3164" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="3165" class="Symbol">}</a> <a id="3167" class="Symbol">{</a><a id="3168" href="1Lab.Univalence.html#3168" class="Bound">φ</a> <a id="3170" class="Symbol">:</a> <a id="3172" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="3173" class="Symbol">}</a>
                <a id="3191" class="Symbol">→</a> <a id="3193" class="Symbol">{</a><a id="3194" href="1Lab.Univalence.html#3194" class="Bound">T</a> <a id="3196" class="Symbol">:</a> <a id="3198" href="Agda.Primitive.Cubical.html#699" class="Primitive">Partial</a> <a id="3206" href="1Lab.Univalence.html#3168" class="Bound">φ</a> <a id="3208" class="Symbol">(</a><a id="3209" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3214" href="1Lab.Univalence.html#2811" class="Generalizable">ℓ&#39;</a><a id="3216" class="Symbol">)}</a> <a id="3219" class="Symbol">→</a> <a id="3221" class="Symbol">{</a><a id="3222" href="1Lab.Univalence.html#3222" class="Bound">e</a> <a id="3224" class="Symbol">:</a> <a id="3226" href="Agda.Primitive.Cubical.html#733" class="Primitive">PartialP</a> <a id="3235" href="1Lab.Univalence.html#3168" class="Bound">φ</a> <a id="3237" class="Symbol">(λ</a> <a id="3240" href="1Lab.Univalence.html#3240" class="Bound">o</a> <a id="3242" class="Symbol">→</a> <a id="3244" href="1Lab.Univalence.html#3194" class="Bound">T</a> <a id="3246" href="1Lab.Univalence.html#3240" class="Bound">o</a> <a id="3248" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="3250" href="1Lab.Univalence.html#3155" class="Bound">A</a><a id="3251" class="Symbol">)}</a>
                <a id="3270" class="Symbol">→</a> <a id="3272" href="1Lab.Univalence.html#2839" class="Primitive">primGlue</a> <a id="3281" href="1Lab.Univalence.html#3155" class="Bound">A</a> <a id="3283" href="1Lab.Univalence.html#3194" class="Bound">T</a> <a id="3285" href="1Lab.Univalence.html#3222" class="Bound">e</a> <a id="3287" class="Symbol">→</a> <a id="3289" href="1Lab.Univalence.html#3155" class="Bound">A</a>

<a id="3292" class="Keyword">open</a> <a id="3297" class="Keyword">import</a> <a id="3304" href="Agda.Builtin.Cubical.HCompU.html" class="Module">Agda.Builtin.Cubical.HCompU</a>
<a id="3332" class="Keyword">open</a> <a id="3337" class="Keyword">import</a> <a id="3344" href="1Lab.Equiv.FromPath.html" class="Module">1Lab.Equiv.FromPath</a>
</pre>-->
<pre class="Agda"><a id="Glue"></a><a id="3381" href="1Lab.Univalence.html#3381" class="Function">Glue</a> <a id="3386" class="Symbol">:</a> <a id="3388" class="Symbol">(</a><a id="3389" href="1Lab.Univalence.html#3389" class="Bound">A</a> <a id="3391" class="Symbol">:</a> <a id="3393" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3398" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="3399" class="Symbol">)</a>
     <a id="3406" class="Symbol">→</a> <a id="3408" class="Symbol">{</a><a id="3409" href="1Lab.Univalence.html#3409" class="Bound">φ</a> <a id="3411" class="Symbol">:</a> <a id="3413" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="3414" class="Symbol">}</a>
     <a id="3421" class="Symbol">→</a> <a id="3423" class="Symbol">(</a><a id="3424" href="1Lab.Univalence.html#3424" class="Bound">Te</a> <a id="3427" class="Symbol">:</a> <a id="3429" href="Agda.Primitive.Cubical.html#699" class="Primitive">Partial</a> <a id="3437" href="1Lab.Univalence.html#3409" class="Bound">φ</a> <a id="3439" class="Symbol">(</a><a id="3440" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="3443" href="1Lab.Univalence.html#3443" class="Bound">T</a> <a id="3445" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="3447" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3452" href="1Lab.Univalence.html#2811" class="Generalizable">ℓ&#39;</a> <a id="3455" href="1Lab.Type.html#1563" class="Function">]</a> <a id="3457" class="Symbol">(</a><a id="3458" href="1Lab.Univalence.html#3443" class="Bound">T</a> <a id="3460" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="3462" href="1Lab.Univalence.html#3389" class="Bound">A</a><a id="3463" class="Symbol">)))</a>
     <a id="3472" class="Symbol">→</a> <a id="3474" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3479" href="1Lab.Univalence.html#2811" class="Generalizable">ℓ&#39;</a>
</pre>
<p>The public interface of <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span> demands a type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, called the <em>base type</em>, a formula <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span></span></span></span>, and a <a href="1Lab.Path.html#partial-elements">partial type</a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> which is equivalent to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>. Since the equivalence is defined <em>inside</em> the partial element, it can also (potentially) vary over the interval, so in reality we have a <em>family</em> of partial types <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> and a <em>family</em> of partial equivalences <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>≃</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">T \simeq A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.</p>
<p>In the specific case where we set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>=</mo><mi mathvariant="normal">¬</mi><mi>i</mi><mo>∨</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">\varphi = \neg i \lor i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord">¬</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>, we can illustrate <code>Glue A (T, f)</code> as the dashed line in the square diagram below. The conceptual idea is that by “gluing” <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> onto a totally defined type, we get a type which <a href="1Lab.Path.html#extensibility">extends</a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>.</p>
<div class="diagram-container"> <img title="commutative diagram" src="b6e2356c639f71ad0995a59d7ff4b24e.svg" class="diagram  quiver"></img> </div>
<!--
<pre class="Agda"><a id="4439" href="1Lab.Univalence.html#3381" class="Function">Glue</a> <a id="4444" href="1Lab.Univalence.html#4444" class="Bound">A</a> <a id="4446" href="1Lab.Univalence.html#4446" class="Bound">Te</a> <a id="4449" class="Symbol">=</a> <a id="4451" href="1Lab.Univalence.html#2839" class="Primitive">primGlue</a> <a id="4460" href="1Lab.Univalence.html#4444" class="Bound">A</a> <a id="4462" class="Symbol">(λ</a> <a id="4465" href="1Lab.Univalence.html#4465" class="Bound">x</a> <a id="4467" class="Symbol">→</a> <a id="4469" href="1Lab.Univalence.html#4446" class="Bound">Te</a> <a id="4472" href="1Lab.Univalence.html#4465" class="Bound">x</a> <a id="4474" class="Symbol">.</a><a id="4475" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="4478" class="Symbol">)</a> <a id="4480" class="Symbol">(λ</a> <a id="4483" href="1Lab.Univalence.html#4483" class="Bound">x</a> <a id="4485" class="Symbol">→</a> <a id="4487" href="1Lab.Univalence.html#4446" class="Bound">Te</a> <a id="4490" href="1Lab.Univalence.html#4483" class="Bound">x</a> <a id="4492" class="Symbol">.</a><a id="4493" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="4496" class="Symbol">)</a>

<a id="unglue"></a><a id="4499" href="1Lab.Univalence.html#4499" class="Function">unglue</a> <a id="4506" class="Symbol">:</a> <a id="4508" class="Symbol">{</a><a id="4509" href="1Lab.Univalence.html#4509" class="Bound">A</a> <a id="4511" class="Symbol">:</a> <a id="4513" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4518" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="4519" class="Symbol">}</a> <a id="4521" class="Symbol">(</a><a id="4522" href="1Lab.Univalence.html#4522" class="Bound">φ</a> <a id="4524" class="Symbol">:</a> <a id="4526" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="4527" class="Symbol">)</a> <a id="4529" class="Symbol">{</a><a id="4530" href="1Lab.Univalence.html#4530" class="Bound">T</a> <a id="4532" class="Symbol">:</a> <a id="4534" href="Agda.Primitive.Cubical.html#699" class="Primitive">Partial</a> <a id="4542" href="1Lab.Univalence.html#4522" class="Bound">φ</a> <a id="4544" class="Symbol">(</a><a id="4545" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4550" href="1Lab.Univalence.html#2811" class="Generalizable">ℓ&#39;</a><a id="4552" class="Symbol">)}</a>
         <a id="4564" class="Symbol">{</a><a id="4565" href="1Lab.Univalence.html#4565" class="Bound">e</a> <a id="4567" class="Symbol">:</a> <a id="4569" href="Agda.Primitive.Cubical.html#733" class="Primitive">PartialP</a> <a id="4578" href="1Lab.Univalence.html#4522" class="Bound">φ</a> <a id="4580" class="Symbol">(λ</a> <a id="4583" href="1Lab.Univalence.html#4583" class="Bound">o</a> <a id="4585" class="Symbol">→</a> <a id="4587" href="1Lab.Univalence.html#4530" class="Bound">T</a> <a id="4589" href="1Lab.Univalence.html#4583" class="Bound">o</a> <a id="4591" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="4593" href="1Lab.Univalence.html#4509" class="Bound">A</a><a id="4594" class="Symbol">)}</a> <a id="4597" class="Symbol">→</a> <a id="4599" href="1Lab.Univalence.html#2839" class="Primitive">primGlue</a> <a id="4608" href="1Lab.Univalence.html#4509" class="Bound">A</a> <a id="4610" href="1Lab.Univalence.html#4530" class="Bound">T</a> <a id="4612" href="1Lab.Univalence.html#4565" class="Bound">e</a> <a id="4614" class="Symbol">→</a> <a id="4616" href="1Lab.Univalence.html#4509" class="Bound">A</a>
<a id="4618" href="1Lab.Univalence.html#4499" class="Function">unglue</a> <a id="4625" href="1Lab.Univalence.html#4625" class="Bound">φ</a> <a id="4627" class="Symbol">=</a> <a id="4629" href="1Lab.Univalence.html#3140" class="Primitive">prim^unglue</a> <a id="4641" class="Symbol">{</a><a id="4642" class="Argument">φ</a> <a id="4644" class="Symbol">=</a> <a id="4646" href="1Lab.Univalence.html#4625" class="Bound">φ</a><a id="4647" class="Symbol">}</a>
</pre>-->
<p>For <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span> to extend <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>, we add a computation rule which could be called a <strong>boundary condition</strong>, since it specifies how <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span> behaves on the boundaries of cubes. Concisely, when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>=</mo><mi>i</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">\varphi = i1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mord">1</span></span></span></span>, we have that <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span> evaluates to the partial type. This is exactly what it means for <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span> to extend <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>!</p>
<pre class="Agda"><a id="5060" class="Keyword">module</a> <a id="5067" href="1Lab.Univalence.html#5067" class="Module">_</a> <a id="5069" class="Symbol">{</a><a id="5070" href="1Lab.Univalence.html#5070" class="Bound">A</a> <a id="5072" href="1Lab.Univalence.html#5072" class="Bound">B</a> <a id="5074" class="Symbol">:</a> <a id="5076" href="1Lab.Type.html#394" class="Primitive">Type</a><a id="5080" class="Symbol">}</a> <a id="5082" class="Symbol">{</a><a id="5083" href="1Lab.Univalence.html#5083" class="Bound">e</a> <a id="5085" class="Symbol">:</a> <a id="5087" href="1Lab.Univalence.html#5070" class="Bound">A</a> <a id="5089" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="5091" href="1Lab.Univalence.html#5072" class="Bound">B</a><a id="5092" class="Symbol">}</a> <a id="5094" class="Keyword">where</a>
  <a id="5102" class="Keyword">private</a>
    <a id="5114" href="1Lab.Univalence.html#5114" class="Function">Glue-boundary</a> <a id="5128" class="Symbol">:</a> <a id="5130" href="1Lab.Univalence.html#3381" class="Function">Glue</a> <a id="5135" href="1Lab.Univalence.html#5072" class="Bound">B</a> <a id="5137" class="Symbol">{</a><a id="5138" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="5140" class="Symbol">}</a> <a id="5142" class="Symbol">(λ</a> <a id="5145" href="1Lab.Univalence.html#5145" class="Bound">x</a> <a id="5147" class="Symbol">→</a> <a id="5149" href="1Lab.Univalence.html#5070" class="Bound">A</a> <a id="5151" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5153" href="1Lab.Univalence.html#5083" class="Bound">e</a><a id="5154" class="Symbol">)</a> <a id="5156" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5158" href="1Lab.Univalence.html#5070" class="Bound">A</a>
    <a id="5164" href="1Lab.Univalence.html#5114" class="Function">Glue-boundary</a> <a id="5178" href="1Lab.Univalence.html#5178" class="Bound">i</a> <a id="5180" class="Symbol">=</a> <a id="5182" href="1Lab.Univalence.html#5070" class="Bound">A</a>
</pre>
<p>Furthermore, since we can turn any family of paths into a family of equivalences, we can use the <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span> construct to implement something with precisely the same interface as <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> for <span class="Agda"><a href="1Lab.Type.html#394" class="Primitive">Type</a></span>:</p>
<pre class="Agda"><a id="glue-hfill"></a><a id="5413" href="1Lab.Univalence.html#5413" class="Function">glue-hfill</a>
  <a id="5426" class="Symbol">:</a> <a id="5428" class="Symbol">∀</a> <a id="5430" class="Symbol">{</a><a id="5431" href="1Lab.Univalence.html#5431" class="Bound">ℓ</a><a id="5432" class="Symbol">}</a> <a id="5434" href="1Lab.Univalence.html#5434" class="Bound">φ</a> <a id="5436" class="Symbol">(</a><a id="5437" href="1Lab.Univalence.html#5437" class="Bound">u</a> <a id="5439" class="Symbol">:</a> <a id="5441" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="5443" class="Symbol">→</a> <a id="5445" href="Agda.Primitive.Cubical.html#699" class="Primitive">Partial</a> <a id="5453" href="1Lab.Univalence.html#5434" class="Bound">φ</a> <a id="5455" class="Symbol">(</a><a id="5456" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="5461" href="1Lab.Univalence.html#5431" class="Bound">ℓ</a><a id="5462" class="Symbol">))</a> <a id="5465" class="Symbol">(</a><a id="5466" href="1Lab.Univalence.html#5466" class="Bound">u0</a> <a id="5469" class="Symbol">:</a> <a id="5471" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="5476" href="1Lab.Univalence.html#5431" class="Bound">ℓ</a> <a id="5478" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="5480" href="1Lab.Univalence.html#5434" class="Bound">φ</a> <a id="5482" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="5484" href="1Lab.Univalence.html#5437" class="Bound">u</a> <a id="5486" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="5489" href="1Lab.Path.html#27116" class="Function Operator">]</a><a id="5490" class="Symbol">)</a>
  <a id="5494" class="Symbol">→</a> <a id="5496" class="Symbol">∀</a> <a id="5498" href="1Lab.Univalence.html#5498" class="Bound">i</a> <a id="5500" class="Symbol">→</a> <a id="5502" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="5507" href="1Lab.Univalence.html#5431" class="Bound">ℓ</a> <a id="5509" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="5511" class="Symbol">_</a> <a id="5513" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="5515" class="Symbol">(λ</a> <a id="5518" class="Symbol">{</a> <a id="5520" class="Symbol">(</a><a id="5521" href="1Lab.Univalence.html#5498" class="Bound">i</a> <a id="5523" class="Symbol">=</a> <a id="5525" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="5527" class="Symbol">)</a> <a id="5529" class="Symbol">→</a> <a id="5531" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="5536" href="1Lab.Univalence.html#5466" class="Bound">u0</a>
                          <a id="5565" class="Symbol">;</a> <a id="5567" class="Symbol">(</a><a id="5568" href="1Lab.Univalence.html#5434" class="Bound">φ</a> <a id="5570" class="Symbol">=</a> <a id="5572" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="5574" class="Symbol">)</a> <a id="5576" class="Symbol">→</a> <a id="5578" href="1Lab.Univalence.html#5437" class="Bound">u</a> <a id="5580" href="1Lab.Univalence.html#5498" class="Bound">i</a> <a id="5582" href="1Lab.Path.html#982" class="Postulate">1=1</a> <a id="5586" class="Symbol">})</a> <a id="5589" href="1Lab.Path.html#27116" class="Function Operator">]</a>
</pre>
<p>The type of <span class="Agda"><a href="1Lab.Univalence.html#5413" class="Function">glue-hfill</a></span> is the same as that of <code class="sourceCode agda">hfill</code>, but the type is stated much more verbosely — so that we may define it without previous reference to a <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> analogue. Like <code class="sourceCode agda">hfill</code>, <span class="Agda"><a href="1Lab.Univalence.html#5413" class="Function">glue-hfill</a></span> extends an open box of types to a totally-defined cube. The type of <span class="Agda"><a href="1Lab.Univalence.html#5413" class="Function">glue-hfill</a></span> expresses this in terms of extensions: We have a path (that’s the <code>∀ i →</code> binder) of <span class="Agda"><a href="1Lab.Type.html#394" class="Primitive">Type</a></span>s which agrees with <code>outS u0</code> on the left endpoint, and with <code>u</code> everywhere.</p>
<pre class="Agda"><a id="6109" href="1Lab.Univalence.html#5413" class="Function">glue-hfill</a> <a id="6120" href="1Lab.Univalence.html#6120" class="Bound">φ</a> <a id="6122" href="1Lab.Univalence.html#6122" class="Bound">u</a> <a id="6124" href="1Lab.Univalence.html#6124" class="Bound">u0</a> <a id="6127" href="1Lab.Univalence.html#6127" class="Bound">i</a> <a id="6129" class="Symbol">=</a> <a id="6131" href="1Lab.Path.html#608" class="Postulate">inS</a> <a id="6135" class="Symbol">(</a>
  <a id="6139" href="1Lab.Univalence.html#3381" class="Function">Glue</a> <a id="6144" class="Symbol">(</a><a id="6145" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="6150" href="1Lab.Univalence.html#6124" class="Bound">u0</a><a id="6152" class="Symbol">)</a> <a id="6154" class="Symbol">{</a><a id="6155" class="Argument">φ</a> <a id="6157" class="Symbol">=</a> <a id="6159" href="1Lab.Univalence.html#6120" class="Bound">φ</a> <a id="6161" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="6163" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="6165" href="1Lab.Univalence.html#6127" class="Bound">i</a><a id="6166" class="Symbol">}</a>
    <a id="6172" class="Symbol">λ</a> <a id="6174" class="Symbol">{</a> <a id="6176" class="Symbol">(</a><a id="6177" href="1Lab.Univalence.html#6120" class="Bound">φ</a> <a id="6179" class="Symbol">=</a> <a id="6181" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="6183" class="Symbol">)</a> <a id="6185" class="Symbol">→</a> <a id="6187" href="1Lab.Univalence.html#6122" class="Bound">u</a> <a id="6189" href="1Lab.Univalence.html#6127" class="Bound">i</a> <a id="6191" href="1Lab.Path.html#982" class="Postulate">1=1</a> <a id="6195" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6197" href="1Lab.Equiv.FromPath.html#9222" class="Function">line→equiv</a> <a id="6208" class="Symbol">(λ</a> <a id="6211" href="1Lab.Univalence.html#6211" class="Bound">j</a> <a id="6213" class="Symbol">→</a> <a id="6215" href="1Lab.Univalence.html#6122" class="Bound">u</a> <a id="6217" class="Symbol">(</a><a id="6218" href="1Lab.Univalence.html#6127" class="Bound">i</a> <a id="6220" href="1Lab.Path.html#730" class="Primitive Operator">∧</a> <a id="6222" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="6224" href="1Lab.Univalence.html#6211" class="Bound">j</a><a id="6225" class="Symbol">)</a> <a id="6227" href="1Lab.Path.html#982" class="Postulate">1=1</a><a id="6230" class="Symbol">)</a>
      <a id="6238" class="Symbol">;</a> <a id="6240" class="Symbol">(</a><a id="6241" href="1Lab.Univalence.html#6127" class="Bound">i</a> <a id="6243" class="Symbol">=</a> <a id="6245" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="6247" class="Symbol">)</a> <a id="6249" class="Symbol">→</a> <a id="6251" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="6256" href="1Lab.Univalence.html#6124" class="Bound">u0</a> <a id="6259" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6261" href="1Lab.Equiv.FromPath.html#9222" class="Function">line→equiv</a> <a id="6272" class="Symbol">(λ</a> <a id="6275" href="1Lab.Univalence.html#6275" class="Bound">i</a> <a id="6277" class="Symbol">→</a> <a id="6279" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="6284" href="1Lab.Univalence.html#6124" class="Bound">u0</a><a id="6286" class="Symbol">)</a>
      <a id="6294" class="Symbol">})</a>
</pre>
<p>In the case for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">i = \mathrm{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>, we must glue <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">u0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal">u</span><span class="mord">0</span></span></span></span> onto itself using the identity equivalence. This guarantees that the boundary of the stated type for <span class="Agda"><a href="1Lab.Univalence.html#5413" class="Function">glue-hfill</a></span> is satisfied. However, since different faces of partial elements must agree where they are defined, we can not use the identity equivalence directly, since <code>line→equiv refl</code> is not definitionally the identity equivalence.</p>
<p>When <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>=</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\varphi = \mathrm{\phi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span>, hence where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> is defined, we glue the endpoint <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> onto <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">u0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal">u</span><span class="mord">0</span></span></span></span> using the equivalence generated by the path provided by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> itself! It’s a family of partial paths, after all, and that can be turned into a family of partial equivalences.</p>
<p>To show that <span class="Agda"><a href="1Lab.Univalence.html#5413" class="Function">glue-hfill</a></span> expresses the fibrancy structure of the universe, we prove a theorem that says anything with the same interface as <code class="sourceCode agda">hfill</code> must agree with <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> on <span class="Agda"><a href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a></span>, and from this conclude that <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> on <span class="Agda"><a href="1Lab.Type.html#394" class="Primitive">Type</a></span> agrees with the definition of <span class="Agda"><a href="1Lab.Univalence.html#5413" class="Function">glue-hfill</a></span>.</p>
<pre class="Agda"><a id="hcomp-unique"></a><a id="7299" href="1Lab.Univalence.html#7299" class="Function">hcomp-unique</a> <a id="7312" class="Symbol">:</a> <a id="7314" class="Symbol">∀</a> <a id="7316" class="Symbol">{</a><a id="7317" href="1Lab.Univalence.html#7317" class="Bound">ℓ</a><a id="7318" class="Symbol">}</a> <a id="7320" class="Symbol">{</a><a id="7321" href="1Lab.Univalence.html#7321" class="Bound">A</a> <a id="7323" class="Symbol">:</a> <a id="7325" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="7330" href="1Lab.Univalence.html#7317" class="Bound">ℓ</a><a id="7331" class="Symbol">}</a> <a id="7333" class="Symbol">{</a><a id="7334" href="1Lab.Univalence.html#7334" class="Bound">φ</a><a id="7335" class="Symbol">}</a>
               <a id="7352" class="Symbol">(</a><a id="7353" href="1Lab.Univalence.html#7353" class="Bound">u</a> <a id="7355" class="Symbol">:</a> <a id="7357" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="7359" class="Symbol">→</a> <a id="7361" href="Agda.Primitive.Cubical.html#699" class="Primitive">Partial</a> <a id="7369" href="1Lab.Univalence.html#7334" class="Bound">φ</a> <a id="7371" href="1Lab.Univalence.html#7321" class="Bound">A</a><a id="7372" class="Symbol">)</a>
               <a id="7389" class="Symbol">(</a><a id="7390" href="1Lab.Univalence.html#7390" class="Bound">u0</a> <a id="7393" class="Symbol">:</a> <a id="7395" href="1Lab.Univalence.html#7321" class="Bound">A</a> <a id="7397" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="7399" href="1Lab.Univalence.html#7334" class="Bound">φ</a> <a id="7401" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="7403" href="1Lab.Univalence.html#7353" class="Bound">u</a> <a id="7405" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="7408" href="1Lab.Path.html#27116" class="Function Operator">]</a><a id="7409" class="Symbol">)</a>
             <a id="7424" class="Symbol">→</a> <a id="7426" class="Symbol">(</a><a id="7427" href="1Lab.Univalence.html#7427" class="Bound">h2</a> <a id="7430" class="Symbol">:</a> <a id="7432" class="Symbol">∀</a> <a id="7434" href="1Lab.Univalence.html#7434" class="Bound">i</a> <a id="7436" class="Symbol">→</a> <a id="7438" href="1Lab.Univalence.html#7321" class="Bound">A</a> <a id="7440" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="7442" class="Symbol">_</a> <a id="7444" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="7446" class="Symbol">(λ</a> <a id="7449" class="Symbol">{</a> <a id="7451" class="Symbol">(</a><a id="7452" href="1Lab.Univalence.html#7434" class="Bound">i</a> <a id="7454" class="Symbol">=</a> <a id="7456" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="7458" class="Symbol">)</a> <a id="7460" class="Symbol">→</a> <a id="7462" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="7467" href="1Lab.Univalence.html#7390" class="Bound">u0</a>
                                      <a id="7508" class="Symbol">;</a> <a id="7510" class="Symbol">(</a><a id="7511" href="1Lab.Univalence.html#7334" class="Bound">φ</a> <a id="7513" class="Symbol">=</a> <a id="7515" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="7517" class="Symbol">)</a> <a id="7519" class="Symbol">→</a> <a id="7521" href="1Lab.Univalence.html#7353" class="Bound">u</a> <a id="7523" href="1Lab.Univalence.html#7434" class="Bound">i</a> <a id="7525" href="1Lab.Path.html#982" class="Postulate">1=1</a> <a id="7529" class="Symbol">})</a> <a id="7532" href="1Lab.Path.html#27116" class="Function Operator">]</a><a id="7533" class="Symbol">)</a>
             <a id="7548" class="Symbol">→</a> <a id="7550" href="1Lab.Path.html#907" class="Primitive">hcomp</a> <a id="7556" href="1Lab.Univalence.html#7353" class="Bound">u</a> <a id="7558" class="Symbol">(</a><a id="7559" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="7564" href="1Lab.Univalence.html#7390" class="Bound">u0</a><a id="7566" class="Symbol">)</a> <a id="7568" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7570" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="7575" class="Symbol">(</a><a id="7576" href="1Lab.Univalence.html#7427" class="Bound">h2</a> <a id="7579" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="7581" class="Symbol">)</a>
<a id="7583" href="1Lab.Univalence.html#7299" class="Function">hcomp-unique</a> <a id="7596" class="Symbol">{</a><a id="7597" class="Argument">φ</a> <a id="7599" class="Symbol">=</a> <a id="7601" href="1Lab.Univalence.html#7601" class="Bound">φ</a><a id="7602" class="Symbol">}</a> <a id="7604" href="1Lab.Univalence.html#7604" class="Bound">u</a> <a id="7606" href="1Lab.Univalence.html#7606" class="Bound">u0</a> <a id="7609" href="1Lab.Univalence.html#7609" class="Bound">h2</a> <a id="7612" href="1Lab.Univalence.html#7612" class="Bound">i</a> <a id="7614" class="Symbol">=</a>
  <a id="7618" href="1Lab.Path.html#907" class="Primitive">hcomp</a> <a id="7624" class="Symbol">(λ</a> <a id="7627" href="1Lab.Univalence.html#7627" class="Bound">k</a> <a id="7629" class="Symbol">→</a> <a id="7631" class="Symbol">λ</a> <a id="7633" class="Symbol">{</a> <a id="7635" class="Symbol">(</a><a id="7636" href="1Lab.Univalence.html#7601" class="Bound">φ</a> <a id="7638" class="Symbol">=</a> <a id="7640" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="7642" class="Symbol">)</a> <a id="7644" class="Symbol">→</a> <a id="7646" href="1Lab.Univalence.html#7604" class="Bound">u</a> <a id="7648" href="1Lab.Univalence.html#7627" class="Bound">k</a> <a id="7650" href="1Lab.Path.html#982" class="Postulate">1=1</a>
                 <a id="7671" class="Symbol">;</a> <a id="7673" class="Symbol">(</a><a id="7674" href="1Lab.Univalence.html#7612" class="Bound">i</a> <a id="7676" class="Symbol">=</a> <a id="7678" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="7680" class="Symbol">)</a> <a id="7682" class="Symbol">→</a> <a id="7684" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="7689" class="Symbol">(</a><a id="7690" href="1Lab.Univalence.html#7609" class="Bound">h2</a> <a id="7693" href="1Lab.Univalence.html#7627" class="Bound">k</a><a id="7694" class="Symbol">)</a> <a id="7696" class="Symbol">})</a>
        <a id="7707" class="Symbol">(</a><a id="7708" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="7713" href="1Lab.Univalence.html#7606" class="Bound">u0</a><a id="7715" class="Symbol">)</a>
</pre>
<p>Using <span class="Agda"><a href="1Lab.Univalence.html#7299" class="Function">hcomp-unique</a></span> and <span class="Agda"><a href="1Lab.Univalence.html#5413" class="Function">glue-hfill</a></span> together, we get a internal characterisation of the fibrancy structure of the universe. While <span class="Agda"><a href="1Lab.Univalence.html#7299" class="Function">hcomp-unique</a></span> may appear surprising, it is essentially a generalisation of the uniqueness of path compositions: Any open box has a contractible space of fillers.</p>
<pre class="Agda"><a id="hcomp≡Glue"></a><a id="8047" href="1Lab.Univalence.html#8047" class="Function">hcomp≡Glue</a> <a id="8058" class="Symbol">:</a> <a id="8060" class="Symbol">∀</a> <a id="8062" class="Symbol">{</a><a id="8063" href="1Lab.Univalence.html#8063" class="Bound">ℓ</a><a id="8064" class="Symbol">}</a> <a id="8066" class="Symbol">{</a><a id="8067" href="1Lab.Univalence.html#8067" class="Bound">φ</a><a id="8068" class="Symbol">}</a> <a id="8070" class="Symbol">(</a><a id="8071" href="1Lab.Univalence.html#8071" class="Bound">u</a> <a id="8073" class="Symbol">:</a> <a id="8075" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="8077" class="Symbol">→</a> <a id="8079" href="Agda.Primitive.Cubical.html#699" class="Primitive">Partial</a> <a id="8087" href="1Lab.Univalence.html#8067" class="Bound">φ</a> <a id="8089" class="Symbol">(</a><a id="8090" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="8095" href="1Lab.Univalence.html#8063" class="Bound">ℓ</a><a id="8096" class="Symbol">))</a> <a id="8099" class="Symbol">(</a><a id="8100" href="1Lab.Univalence.html#8100" class="Bound">u0</a> <a id="8103" class="Symbol">:</a> <a id="8105" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="8110" href="1Lab.Univalence.html#8063" class="Bound">ℓ</a> <a id="8112" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="8114" href="1Lab.Univalence.html#8067" class="Bound">φ</a> <a id="8116" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="8118" href="1Lab.Univalence.html#8071" class="Bound">u</a> <a id="8120" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="8123" href="1Lab.Path.html#27116" class="Function Operator">]</a><a id="8124" class="Symbol">)</a>
           <a id="8137" class="Symbol">→</a> <a id="8139" href="1Lab.Path.html#907" class="Primitive">hcomp</a> <a id="8145" href="1Lab.Univalence.html#8071" class="Bound">u</a> <a id="8147" class="Symbol">(</a><a id="8148" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="8153" href="1Lab.Univalence.html#8100" class="Bound">u0</a><a id="8155" class="Symbol">)</a>
           <a id="8168" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="8170" href="1Lab.Univalence.html#3381" class="Function">Glue</a> <a id="8175" class="Symbol">(</a><a id="8176" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="8181" href="1Lab.Univalence.html#8100" class="Bound">u0</a><a id="8183" class="Symbol">)</a>
              <a id="8199" class="Symbol">(λ</a> <a id="8202" class="Symbol">{</a> <a id="8204" class="Symbol">(</a><a id="8205" href="1Lab.Univalence.html#8067" class="Bound">φ</a> <a id="8207" class="Symbol">=</a> <a id="8209" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="8211" class="Symbol">)</a> <a id="8213" class="Symbol">→</a> <a id="8215" href="1Lab.Univalence.html#8071" class="Bound">u</a> <a id="8217" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="8220" href="1Lab.Path.html#982" class="Postulate">1=1</a> <a id="8224" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8226" href="1Lab.Equiv.FromPath.html#9222" class="Function">line→equiv</a> <a id="8237" class="Symbol">(λ</a> <a id="8240" href="1Lab.Univalence.html#8240" class="Bound">j</a> <a id="8242" class="Symbol">→</a> <a id="8244" href="1Lab.Univalence.html#8071" class="Bound">u</a> <a id="8246" class="Symbol">(</a><a id="8247" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="8249" href="1Lab.Univalence.html#8240" class="Bound">j</a><a id="8250" class="Symbol">)</a> <a id="8252" href="1Lab.Path.html#982" class="Postulate">1=1</a><a id="8255" class="Symbol">)</a> <a id="8257" class="Symbol">})</a>
<a id="8260" href="1Lab.Univalence.html#8047" class="Function">hcomp≡Glue</a> <a id="8271" href="1Lab.Univalence.html#8271" class="Bound">u</a> <a id="8273" href="1Lab.Univalence.html#8273" class="Bound">u0</a> <a id="8276" class="Symbol">=</a> <a id="8278" href="1Lab.Univalence.html#7299" class="Function">hcomp-unique</a> <a id="8291" href="1Lab.Univalence.html#8271" class="Bound">u</a> <a id="8293" href="1Lab.Univalence.html#8273" class="Bound">u0</a> <a id="8296" class="Symbol">(</a><a id="8297" href="1Lab.Univalence.html#5413" class="Function">glue-hfill</a> <a id="8308" class="Symbol">_</a> <a id="8310" href="1Lab.Univalence.html#8271" class="Bound">u</a> <a id="8312" href="1Lab.Univalence.html#8273" class="Bound">u0</a><a id="8314" class="Symbol">)</a>
</pre>
<h2 id="paths-from-glue">Paths from Glue</h2>
<p>Since <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span> generalises <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> by allowing a partial equivalence as its “tube”, rather than a partial path, it allows us to turn any equivalence into a path, using a sort of “trick”: We consider the <em>line</em> with endpoints <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> as an open cube to be filled. A filler for this line is exactly a path <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>≡</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \equiv B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>. Since <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span> fills open boxes of types using equivalences, this path exists!</p>
<pre class="Agda"><a id="ua"></a><a id="8768" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="8771" class="Symbol">:</a> <a id="8773" class="Symbol">{</a><a id="8774" href="1Lab.Univalence.html#8774" class="Bound">A</a> <a id="8776" href="1Lab.Univalence.html#8776" class="Bound">B</a> <a id="8778" class="Symbol">:</a> <a id="8780" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="8785" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="8786" class="Symbol">}</a> <a id="8788" class="Symbol">→</a> <a id="8790" href="1Lab.Univalence.html#8774" class="Bound">A</a> <a id="8792" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="8794" href="1Lab.Univalence.html#8776" class="Bound">B</a> <a id="8796" class="Symbol">→</a> <a id="8798" href="1Lab.Univalence.html#8774" class="Bound">A</a> <a id="8800" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="8802" href="1Lab.Univalence.html#8776" class="Bound">B</a>
<a id="8804" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="8807" class="Symbol">{</a><a id="8808" class="Argument">A</a> <a id="8810" class="Symbol">=</a> <a id="8812" href="1Lab.Univalence.html#8812" class="Bound">A</a><a id="8813" class="Symbol">}</a> <a id="8815" class="Symbol">{</a><a id="8816" href="1Lab.Univalence.html#8816" class="Bound">B</a><a id="8817" class="Symbol">}</a> <a id="8819" href="1Lab.Univalence.html#8819" class="Bound">eqv</a> <a id="8823" href="1Lab.Univalence.html#8823" class="Bound">i</a> <a id="8825" class="Symbol">=</a> <a id="8827" href="1Lab.Univalence.html#3381" class="Function">Glue</a> <a id="8832" href="1Lab.Univalence.html#8816" class="Bound">B</a> <a id="8834" class="Symbol">λ</a> <a id="8836" class="Symbol">{</a> <a id="8838" class="Symbol">(</a><a id="8839" href="1Lab.Univalence.html#8823" class="Bound">i</a> <a id="8841" class="Symbol">=</a> <a id="8843" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="8845" class="Symbol">)</a> <a id="8847" class="Symbol">→</a> <a id="8849" href="1Lab.Univalence.html#8812" class="Bound">A</a> <a id="8851" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8853" href="1Lab.Univalence.html#8819" class="Bound">eqv</a>
                                <a id="8889" class="Symbol">;</a> <a id="8891" class="Symbol">(</a><a id="8892" href="1Lab.Univalence.html#8823" class="Bound">i</a> <a id="8894" class="Symbol">=</a> <a id="8896" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="8898" class="Symbol">)</a> <a id="8900" class="Symbol">→</a> <a id="8902" href="1Lab.Univalence.html#8816" class="Bound">B</a> <a id="8904" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8906" class="Symbol">_</a> <a id="8908" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8910" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>
                                <a id="8950" class="Symbol">}</a>
</pre>
<p>Semantically, the explanation of <span class="Agda"><a href="1Lab.Univalence.html#8768" class="Function">ua</a></span> as completing a partial line is sufficient. But we can also ask ourselves: Why does this definition go through, <em>syntactically</em>? Because of the boundary condition for Glue: when <code>i = i0</code>, the whole thing evaluates to <code>A</code>, meaning that the left endpoint of the path is correct. The same thing happens with the right endpoint.</p>
<p>The action of <a href="1Lab.Path.html">transporting</a> along <code>ua(f)</code> can be described by chasing an element around the diagram that illustrates Glue in the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>=</mo><mi>i</mi><mo>∨</mo><mi mathvariant="normal">¬</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">\varphi = i \lor \neg i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord">¬</span><span class="mord mathnormal">i</span></span></span></span> case, specialising to <span class="Agda"><a href="1Lab.Univalence.html#8768" class="Function">ua</a></span>. Keep in mind that, since the right face of the diagram “points in the wrong direction”, it must be inverted. However, the inverse of the identity equivalence is the identity equivalence, so nothing changes (for this example).</p>
<figure>
<div class="diagram-container"> <img title="commutative diagram" src="096e2fdc0220ef7d1d917abcd6a3827f.svg" class="diagram  quiver"></img> </div>
</figure>
<ol class="incremental" type="1">
<li>The action that corresponds to the left face of the diagram is to apply the underlying function of <code>f</code>. This contributes the <code>f .fst x</code> part of the <span class="Agda"><a href="1Lab.Univalence.html#10927" class="Function">uaβ</a></span> term below.</li>
</ol>
<ol class="incremental" start="2" type="1">
<li>For the bottom face, we have a path rather than an equivalence, so we must <span class="Agda"><a href="1Lab.Path.html#10335" class="Function">transport</a></span> along it. In this case, the path is the reflexivity on <code>B</code>, but in a more general <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span> construction, it might be a non-trivial path.</li>
</ol>
<p>To compensate for this extra transport, we use <span class="Agda"><a href="1Lab.Path.html#49792" class="Function">coe1→i</a></span>, which connects <code>f .fst x</code> and <code>transport (λ i → B) (f .fst x)</code>.</p>
<ol class="incremental" start="3" type="1">
<li>Finally, we apply the inverse of the identity equivalence, corresponding to the right face in the diagram. This immediately computes away, and thus contributes nothing to the <span class="Agda"><a href="1Lab.Univalence.html#10927" class="Function">uaβ</a></span> path.</li>
</ol>
<pre class="Agda"><a id="uaβ"></a><a id="10927" href="1Lab.Univalence.html#10927" class="Function">uaβ</a> <a id="10931" class="Symbol">:</a> <a id="10933" class="Symbol">{</a><a id="10934" href="1Lab.Univalence.html#10934" class="Bound">A</a> <a id="10936" href="1Lab.Univalence.html#10936" class="Bound">B</a> <a id="10938" class="Symbol">:</a> <a id="10940" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="10945" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="10946" class="Symbol">}</a> <a id="10948" class="Symbol">(</a><a id="10949" href="1Lab.Univalence.html#10949" class="Bound">f</a> <a id="10951" class="Symbol">:</a> <a id="10953" href="1Lab.Univalence.html#10934" class="Bound">A</a> <a id="10955" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="10957" href="1Lab.Univalence.html#10936" class="Bound">B</a><a id="10958" class="Symbol">)</a> <a id="10960" class="Symbol">(</a><a id="10961" href="1Lab.Univalence.html#10961" class="Bound">x</a> <a id="10963" class="Symbol">:</a> <a id="10965" href="1Lab.Univalence.html#10934" class="Bound">A</a><a id="10966" class="Symbol">)</a> <a id="10968" class="Symbol">→</a> <a id="10970" href="1Lab.Path.html#10335" class="Function">transport</a> <a id="10980" class="Symbol">(</a><a id="10981" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="10984" href="1Lab.Univalence.html#10949" class="Bound">f</a><a id="10985" class="Symbol">)</a> <a id="10987" href="1Lab.Univalence.html#10961" class="Bound">x</a> <a id="10989" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10991" href="1Lab.Univalence.html#10949" class="Bound">f</a> <a id="10993" class="Symbol">.</a><a id="10994" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10998" href="1Lab.Univalence.html#10961" class="Bound">x</a>
<a id="11000" href="1Lab.Univalence.html#10927" class="Function">uaβ</a> <a id="11004" class="Symbol">{</a><a id="11005" class="Argument">A</a> <a id="11007" class="Symbol">=</a> <a id="11009" href="1Lab.Univalence.html#11009" class="Bound">A</a><a id="11010" class="Symbol">}</a> <a id="11012" class="Symbol">{</a><a id="11013" href="1Lab.Univalence.html#11013" class="Bound">B</a><a id="11014" class="Symbol">}</a> <a id="11016" href="1Lab.Univalence.html#11016" class="Bound">f</a> <a id="11018" href="1Lab.Univalence.html#11018" class="Bound">x</a> <a id="11020" href="1Lab.Univalence.html#11020" class="Bound">i</a> <a id="11022" class="Symbol">=</a> <a id="11024" href="1Lab.Path.html#49792" class="Function">coe1→i</a> <a id="11031" class="Symbol">(λ</a> <a id="11034" href="1Lab.Univalence.html#11034" class="Bound">_</a> <a id="11036" class="Symbol">→</a> <a id="11038" href="1Lab.Univalence.html#11013" class="Bound">B</a><a id="11039" class="Symbol">)</a> <a id="11041" href="1Lab.Univalence.html#11020" class="Bound">i</a> <a id="11043" class="Symbol">(</a><a id="11044" href="1Lab.Univalence.html#11016" class="Bound">f</a> <a id="11046" class="Symbol">.</a><a id="11047" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11051" href="1Lab.Univalence.html#11018" class="Bound">x</a><a id="11052" class="Symbol">)</a>
</pre>
<p>Since <span class="Agda"><a href="1Lab.Univalence.html#8768" class="Function">ua</a></span> is a map that turns equivalences into paths, we can compose it with a function that turns <a href="1Lab.Equiv.html#Iso">isomorphisms</a> into equivalences to get the map <span class="Agda"><a href="1Lab.Univalence.html#11280" class="Function">Iso→path</a></span>.</p>
<pre class="Agda"><a id="Iso→path"></a><a id="11280" href="1Lab.Univalence.html#11280" class="Function">Iso→path</a> <a id="11289" class="Symbol">:</a> <a id="11291" class="Symbol">{</a><a id="11292" href="1Lab.Univalence.html#11292" class="Bound">A</a> <a id="11294" href="1Lab.Univalence.html#11294" class="Bound">B</a> <a id="11296" class="Symbol">:</a> <a id="11298" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="11303" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="11304" class="Symbol">}</a> <a id="11306" class="Symbol">→</a> <a id="11308" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="11312" href="1Lab.Univalence.html#11292" class="Bound">A</a> <a id="11314" href="1Lab.Univalence.html#11294" class="Bound">B</a> <a id="11316" class="Symbol">→</a> <a id="11318" href="1Lab.Univalence.html#11292" class="Bound">A</a> <a id="11320" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="11322" href="1Lab.Univalence.html#11294" class="Bound">B</a>
<a id="11324" href="1Lab.Univalence.html#11280" class="Function">Iso→path</a> <a id="11333" class="Symbol">(</a><a id="11334" href="1Lab.Univalence.html#11334" class="Bound">f</a> <a id="11336" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11338" href="1Lab.Univalence.html#11338" class="Bound">iiso</a><a id="11342" class="Symbol">)</a> <a id="11344" class="Symbol">=</a> <a id="11346" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="11349" class="Symbol">(</a><a id="11350" href="1Lab.Univalence.html#11334" class="Bound">f</a> <a id="11352" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11354" href="1Lab.Equiv.html#19765" class="Function">isIso→isEquiv</a> <a id="11368" href="1Lab.Univalence.html#11338" class="Bound">iiso</a><a id="11372" class="Symbol">)</a>
</pre>
<h2 id="paths-over-ua">Paths over ua</h2>
<p>The introduction and elimination forms for <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span> can be specialised to the case of <span class="Agda"><a href="1Lab.Univalence.html#8768" class="Function">ua</a></span>, leading to the definitions of <span class="Agda"><a href="1Lab.Univalence.html#13100" class="Function">ua-glue</a></span> and <span class="Agda"><a href="1Lab.Univalence.html#12026" class="Function">ua-unglue</a></span> below. Their types are written in terms of interval variables and <a href="1Lab.Path.html#extensibility">extensions</a>, rather than using <code class="sourceCode agda">Path</code>s, because these typings make the structure of <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span> more explicit.</p>
<p>The first, <span class="Agda"><a href="1Lab.Univalence.html#12026" class="Function">ua-unglue</a></span>, tells us that if we have some <code>x : ua e i</code> (varying over an interval variable <code>i</code>), then we have an element of <code>B</code> which agrees with <code>e .fst x</code> on the left and with <code>x</code> on the right.</p>
<pre class="Agda"><a id="ua-unglue"></a><a id="12026" href="1Lab.Univalence.html#12026" class="Function">ua-unglue</a> <a id="12036" class="Symbol">:</a> <a id="12038" class="Symbol">∀</a> <a id="12040" class="Symbol">{</a><a id="12041" href="1Lab.Univalence.html#12041" class="Bound">A</a> <a id="12043" href="1Lab.Univalence.html#12043" class="Bound">B</a> <a id="12045" class="Symbol">:</a> <a id="12047" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="12052" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="12053" class="Symbol">}</a> <a id="12055" class="Symbol">(</a><a id="12056" href="1Lab.Univalence.html#12056" class="Bound">e</a> <a id="12058" class="Symbol">:</a> <a id="12060" href="1Lab.Univalence.html#12041" class="Bound">A</a> <a id="12062" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="12064" href="1Lab.Univalence.html#12043" class="Bound">B</a><a id="12065" class="Symbol">)</a> <a id="12067" class="Symbol">(</a><a id="12068" href="1Lab.Univalence.html#12068" class="Bound">i</a> <a id="12070" class="Symbol">:</a> <a id="12072" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="12073" class="Symbol">)</a> <a id="12075" class="Symbol">(</a><a id="12076" href="1Lab.Univalence.html#12076" class="Bound">x</a> <a id="12078" class="Symbol">:</a> <a id="12080" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="12083" href="1Lab.Univalence.html#12056" class="Bound">e</a> <a id="12085" href="1Lab.Univalence.html#12068" class="Bound">i</a><a id="12086" class="Symbol">)</a>
            <a id="12100" class="Symbol">→</a> <a id="12102" href="1Lab.Univalence.html#12043" class="Bound">B</a> <a id="12104" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="12106" class="Symbol">_</a> <a id="12108" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="12110" class="Symbol">(λ</a> <a id="12113" class="Symbol">{</a> <a id="12115" class="Symbol">(</a><a id="12116" href="1Lab.Univalence.html#12068" class="Bound">i</a> <a id="12118" class="Symbol">=</a> <a id="12120" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="12122" class="Symbol">)</a> <a id="12124" class="Symbol">→</a> <a id="12126" href="1Lab.Univalence.html#12056" class="Bound">e</a> <a id="12128" class="Symbol">.</a><a id="12129" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="12133" href="1Lab.Univalence.html#12076" class="Bound">x</a>
                         <a id="12160" class="Symbol">;</a> <a id="12162" class="Symbol">(</a><a id="12163" href="1Lab.Univalence.html#12068" class="Bound">i</a> <a id="12165" class="Symbol">=</a> <a id="12167" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="12169" class="Symbol">)</a> <a id="12171" class="Symbol">→</a> <a id="12173" href="1Lab.Univalence.html#12076" class="Bound">x</a> <a id="12175" class="Symbol">})</a> <a id="12178" href="1Lab.Path.html#27116" class="Function Operator">]</a>
<a id="12180" href="1Lab.Univalence.html#12026" class="Function">ua-unglue</a> <a id="12190" href="1Lab.Univalence.html#12190" class="Bound">e</a> <a id="12192" href="1Lab.Univalence.html#12192" class="Bound">i</a> <a id="12194" href="1Lab.Univalence.html#12194" class="Bound">x</a> <a id="12196" class="Symbol">=</a> <a id="12198" href="1Lab.Path.html#608" class="Postulate">inS</a> <a id="12202" class="Symbol">(</a><a id="12203" href="1Lab.Univalence.html#4499" class="Function">unglue</a> <a id="12210" class="Symbol">(</a><a id="12211" href="1Lab.Univalence.html#12192" class="Bound">i</a> <a id="12213" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="12215" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="12217" href="1Lab.Univalence.html#12192" class="Bound">i</a><a id="12218" class="Symbol">)</a> <a id="12220" href="1Lab.Univalence.html#12194" class="Bound">x</a><a id="12221" class="Symbol">)</a>
</pre>
<p>We can factor the interval variable out, to get a type in terms of <span class="Agda"><a href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a></span>, leading to an explanation of <code>ua-unglue</code> without mentioning extensions: A path <code>x ≡ y</code> over <code>ua e</code> induces a path <code>e .fst x ≡ y</code>.</p>
<pre class="Agda"><a id="uaPathP→Path"></a><a id="12450" href="1Lab.Univalence.html#12450" class="Function">uaPathP→Path</a> <a id="12463" class="Symbol">:</a> <a id="12465" class="Symbol">∀</a> <a id="12467" class="Symbol">{</a><a id="12468" href="1Lab.Univalence.html#12468" class="Bound">A</a> <a id="12470" href="1Lab.Univalence.html#12470" class="Bound">B</a> <a id="12472" class="Symbol">:</a> <a id="12474" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="12479" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="12480" class="Symbol">}</a> <a id="12482" class="Symbol">(</a><a id="12483" href="1Lab.Univalence.html#12483" class="Bound">e</a> <a id="12485" class="Symbol">:</a> <a id="12487" href="1Lab.Univalence.html#12468" class="Bound">A</a> <a id="12489" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="12491" href="1Lab.Univalence.html#12470" class="Bound">B</a><a id="12492" class="Symbol">)</a> <a id="12494" class="Symbol">{</a><a id="12495" href="1Lab.Univalence.html#12495" class="Bound">x</a> <a id="12497" class="Symbol">:</a> <a id="12499" href="1Lab.Univalence.html#12468" class="Bound">A</a><a id="12500" class="Symbol">}</a> <a id="12502" class="Symbol">{</a><a id="12503" href="1Lab.Univalence.html#12503" class="Bound">y</a> <a id="12505" class="Symbol">:</a> <a id="12507" href="1Lab.Univalence.html#12470" class="Bound">B</a><a id="12508" class="Symbol">}</a>
             <a id="12523" class="Symbol">→</a> <a id="12525" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="12531" class="Symbol">(λ</a> <a id="12534" href="1Lab.Univalence.html#12534" class="Bound">i</a> <a id="12536" class="Symbol">→</a> <a id="12538" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="12541" href="1Lab.Univalence.html#12483" class="Bound">e</a> <a id="12543" href="1Lab.Univalence.html#12534" class="Bound">i</a><a id="12544" class="Symbol">)</a> <a id="12546" href="1Lab.Univalence.html#12495" class="Bound">x</a> <a id="12548" href="1Lab.Univalence.html#12503" class="Bound">y</a>
             <a id="12563" class="Symbol">→</a> <a id="12565" href="1Lab.Univalence.html#12483" class="Bound">e</a> <a id="12567" class="Symbol">.</a><a id="12568" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="12572" href="1Lab.Univalence.html#12495" class="Bound">x</a> <a id="12574" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="12576" href="1Lab.Univalence.html#12503" class="Bound">y</a>
<a id="12578" href="1Lab.Univalence.html#12450" class="Function">uaPathP→Path</a> <a id="12591" href="1Lab.Univalence.html#12591" class="Bound">e</a> <a id="12593" href="1Lab.Univalence.html#12593" class="Bound">p</a> <a id="12595" href="1Lab.Univalence.html#12595" class="Bound">i</a> <a id="12597" class="Symbol">=</a> <a id="12599" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="12604" class="Symbol">(</a><a id="12605" href="1Lab.Univalence.html#12026" class="Function">ua-unglue</a> <a id="12615" href="1Lab.Univalence.html#12591" class="Bound">e</a> <a id="12617" href="1Lab.Univalence.html#12595" class="Bound">i</a> <a id="12619" class="Symbol">(</a><a id="12620" href="1Lab.Univalence.html#12593" class="Bound">p</a> <a id="12622" href="1Lab.Univalence.html#12595" class="Bound">i</a><a id="12623" class="Symbol">))</a>
</pre>
<p>In the other direction, we have <span class="Agda"><a href="1Lab.Univalence.html#13100" class="Function">ua-glue</a></span>, which expresses that a path <code>e .fst x ≡ y</code> implies that <code>x ≡ y</code> over <code>ua e</code>. For the type of <span class="Agda"><a href="1Lab.Univalence.html#13100" class="Function">ua-glue</a></span>, suppose that we have a partial element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> defined on the left endpoint of the interval, together with an extension <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> is defined. What <span class="Agda"><a href="1Lab.Univalence.html#13100" class="Function">ua-glue</a></span> expresses is that we can complete this to a path in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">u</mi><mi mathvariant="normal">a</mi></mrow><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{ua}(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ua</span></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>, which agrees with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> where these are defined.</p>
<pre class="Agda"><a id="ua-glue"></a><a id="13100" href="1Lab.Univalence.html#13100" class="Function">ua-glue</a> <a id="13108" class="Symbol">:</a> <a id="13110" class="Symbol">∀</a> <a id="13112" class="Symbol">{</a><a id="13113" href="1Lab.Univalence.html#13113" class="Bound">A</a> <a id="13115" href="1Lab.Univalence.html#13115" class="Bound">B</a> <a id="13117" class="Symbol">:</a> <a id="13119" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13124" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="13125" class="Symbol">}</a> <a id="13127" class="Symbol">(</a><a id="13128" href="1Lab.Univalence.html#13128" class="Bound">e</a> <a id="13130" class="Symbol">:</a> <a id="13132" href="1Lab.Univalence.html#13113" class="Bound">A</a> <a id="13134" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="13136" href="1Lab.Univalence.html#13115" class="Bound">B</a><a id="13137" class="Symbol">)</a> <a id="13139" class="Symbol">(</a><a id="13140" href="1Lab.Univalence.html#13140" class="Bound">i</a> <a id="13142" class="Symbol">:</a> <a id="13144" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="13145" class="Symbol">)</a>
            <a id="13159" class="Symbol">(</a><a id="13160" href="1Lab.Univalence.html#13160" class="Bound">x</a> <a id="13162" class="Symbol">:</a> <a id="13164" href="Agda.Primitive.Cubical.html#699" class="Primitive">Partial</a> <a id="13172" class="Symbol">(</a><a id="13173" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="13175" href="1Lab.Univalence.html#13140" class="Bound">i</a><a id="13176" class="Symbol">)</a> <a id="13178" href="1Lab.Univalence.html#13113" class="Bound">A</a><a id="13179" class="Symbol">)</a>
            <a id="13193" class="Symbol">(</a><a id="13194" href="1Lab.Univalence.html#13194" class="Bound">y</a> <a id="13196" class="Symbol">:</a> <a id="13198" href="1Lab.Univalence.html#13115" class="Bound">B</a> <a id="13200" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="13202" class="Symbol">_</a> <a id="13204" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="13206" class="Symbol">(λ</a> <a id="13209" class="Symbol">{</a> <a id="13211" class="Symbol">(</a><a id="13212" href="1Lab.Univalence.html#13140" class="Bound">i</a> <a id="13214" class="Symbol">=</a> <a id="13216" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="13218" class="Symbol">)</a> <a id="13220" class="Symbol">→</a> <a id="13222" href="1Lab.Univalence.html#13128" class="Bound">e</a> <a id="13224" class="Symbol">.</a><a id="13225" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="13229" class="Symbol">(</a><a id="13230" href="1Lab.Univalence.html#13160" class="Bound">x</a> <a id="13232" href="1Lab.Path.html#982" class="Postulate">1=1</a><a id="13235" class="Symbol">)</a> <a id="13237" class="Symbol">})</a> <a id="13240" href="1Lab.Path.html#27116" class="Function Operator">]</a><a id="13241" class="Symbol">)</a>
          <a id="13253" class="Symbol">→</a> <a id="13255" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="13258" href="1Lab.Univalence.html#13128" class="Bound">e</a> <a id="13260" href="1Lab.Univalence.html#13140" class="Bound">i</a> <a id="13262" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="13264" class="Symbol">_</a> <a id="13266" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="13268" class="Symbol">(λ</a> <a id="13271" class="Symbol">{</a> <a id="13273" class="Symbol">(</a><a id="13274" href="1Lab.Univalence.html#13140" class="Bound">i</a> <a id="13276" class="Symbol">=</a> <a id="13278" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="13280" class="Symbol">)</a> <a id="13282" class="Symbol">→</a> <a id="13284" href="1Lab.Univalence.html#13160" class="Bound">x</a> <a id="13286" href="1Lab.Path.html#982" class="Postulate">1=1</a>
                            <a id="13318" class="Symbol">;</a> <a id="13320" class="Symbol">(</a><a id="13321" href="1Lab.Univalence.html#13140" class="Bound">i</a> <a id="13323" class="Symbol">=</a> <a id="13325" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="13327" class="Symbol">)</a> <a id="13329" class="Symbol">→</a> <a id="13331" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="13336" href="1Lab.Univalence.html#13194" class="Bound">y</a>
                            <a id="13366" class="Symbol">})</a> <a id="13369" href="1Lab.Path.html#27116" class="Function Operator">]</a>
<a id="13371" href="1Lab.Univalence.html#13100" class="Function">ua-glue</a> <a id="13379" href="1Lab.Univalence.html#13379" class="Bound">e</a> <a id="13381" href="1Lab.Univalence.html#13381" class="Bound">i</a> <a id="13383" href="1Lab.Univalence.html#13383" class="Bound">x</a> <a id="13385" href="1Lab.Univalence.html#13385" class="Bound">y</a> <a id="13387" class="Symbol">=</a> <a id="13389" href="1Lab.Path.html#608" class="Postulate">inS</a> <a id="13393" class="Symbol">(</a><a id="13394" href="1Lab.Univalence.html#2975" class="Primitive">prim^glue</a> <a id="13404" class="Symbol">{</a><a id="13405" class="Argument">φ</a> <a id="13407" class="Symbol">=</a> <a id="13409" href="1Lab.Univalence.html#13381" class="Bound">i</a> <a id="13411" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="13413" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="13415" href="1Lab.Univalence.html#13381" class="Bound">i</a><a id="13416" class="Symbol">}</a>
                                 <a id="13451" class="Symbol">(λ</a> <a id="13454" class="Symbol">{</a> <a id="13456" class="Symbol">(</a><a id="13457" href="1Lab.Univalence.html#13381" class="Bound">i</a> <a id="13459" class="Symbol">=</a> <a id="13461" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="13463" class="Symbol">)</a> <a id="13465" class="Symbol">→</a> <a id="13467" href="1Lab.Univalence.html#13383" class="Bound">x</a> <a id="13469" href="1Lab.Path.html#982" class="Postulate">1=1</a>
                                    <a id="13509" class="Symbol">;</a> <a id="13511" class="Symbol">(</a><a id="13512" href="1Lab.Univalence.html#13381" class="Bound">i</a> <a id="13514" class="Symbol">=</a> <a id="13516" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="13518" class="Symbol">)</a> <a id="13520" class="Symbol">→</a> <a id="13522" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="13527" href="1Lab.Univalence.html#13385" class="Bound">y</a> <a id="13529" class="Symbol">})</a>
                                 <a id="13565" class="Symbol">(</a><a id="13566" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="13571" href="1Lab.Univalence.html#13385" class="Bound">y</a><a id="13572" class="Symbol">))</a>
</pre>
<p>Observe that, since <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> is partially in the image of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>, this essentially constrains <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> to be a “partial preimage” of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> under the equivalence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>. Factoring in the type of the interval, we get the promised map between dependent paths over <span class="Agda"><a href="1Lab.Univalence.html#8768" class="Function">ua</a></span> and paths in B.</p>
<pre class="Agda"><a id="Path→uaPathP"></a><a id="13860" href="1Lab.Univalence.html#13860" class="Function">Path→uaPathP</a> <a id="13873" class="Symbol">:</a> <a id="13875" class="Symbol">∀</a> <a id="13877" class="Symbol">{</a><a id="13878" href="1Lab.Univalence.html#13878" class="Bound">A</a> <a id="13880" href="1Lab.Univalence.html#13880" class="Bound">B</a> <a id="13882" class="Symbol">:</a> <a id="13884" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13889" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="13890" class="Symbol">}</a> <a id="13892" class="Symbol">(</a><a id="13893" href="1Lab.Univalence.html#13893" class="Bound">e</a> <a id="13895" class="Symbol">:</a> <a id="13897" href="1Lab.Univalence.html#13878" class="Bound">A</a> <a id="13899" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="13901" href="1Lab.Univalence.html#13880" class="Bound">B</a><a id="13902" class="Symbol">)</a> <a id="13904" class="Symbol">{</a><a id="13905" href="1Lab.Univalence.html#13905" class="Bound">x</a> <a id="13907" class="Symbol">:</a> <a id="13909" href="1Lab.Univalence.html#13878" class="Bound">A</a><a id="13910" class="Symbol">}</a> <a id="13912" class="Symbol">{</a><a id="13913" href="1Lab.Univalence.html#13913" class="Bound">y</a> <a id="13915" class="Symbol">:</a> <a id="13917" href="1Lab.Univalence.html#13880" class="Bound">B</a><a id="13918" class="Symbol">}</a>
             <a id="13933" class="Symbol">→</a> <a id="13935" href="1Lab.Univalence.html#13893" class="Bound">e</a> <a id="13937" class="Symbol">.</a><a id="13938" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="13942" href="1Lab.Univalence.html#13905" class="Bound">x</a> <a id="13944" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="13946" href="1Lab.Univalence.html#13913" class="Bound">y</a>
             <a id="13961" class="Symbol">→</a> <a id="13963" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="13969" class="Symbol">(λ</a> <a id="13972" href="1Lab.Univalence.html#13972" class="Bound">i</a> <a id="13974" class="Symbol">→</a> <a id="13976" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="13979" href="1Lab.Univalence.html#13893" class="Bound">e</a> <a id="13981" href="1Lab.Univalence.html#13972" class="Bound">i</a><a id="13982" class="Symbol">)</a> <a id="13984" href="1Lab.Univalence.html#13905" class="Bound">x</a> <a id="13986" href="1Lab.Univalence.html#13913" class="Bound">y</a>
<a id="13988" href="1Lab.Univalence.html#13860" class="Function">Path→uaPathP</a> <a id="14001" href="1Lab.Univalence.html#14001" class="Bound">e</a> <a id="14003" class="Symbol">{</a><a id="14004" class="Argument">x</a> <a id="14006" class="Symbol">=</a> <a id="14008" href="1Lab.Univalence.html#14008" class="Bound">x</a><a id="14009" class="Symbol">}</a> <a id="14011" href="1Lab.Univalence.html#14011" class="Bound">p</a> <a id="14013" href="1Lab.Univalence.html#14013" class="Bound">i</a> <a id="14015" class="Symbol">=</a> <a id="14017" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="14022" class="Symbol">(</a><a id="14023" href="1Lab.Univalence.html#13100" class="Function">ua-glue</a> <a id="14031" href="1Lab.Univalence.html#14001" class="Bound">e</a> <a id="14033" href="1Lab.Univalence.html#14013" class="Bound">i</a> <a id="14035" class="Symbol">(λ</a> <a id="14038" class="Symbol">{</a> <a id="14040" class="Symbol">(</a><a id="14041" href="1Lab.Univalence.html#14013" class="Bound">i</a> <a id="14043" class="Symbol">=</a> <a id="14045" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="14047" class="Symbol">)</a> <a id="14049" class="Symbol">→</a> <a id="14051" href="1Lab.Univalence.html#14008" class="Bound">x</a> <a id="14053" class="Symbol">})</a> <a id="14056" class="Symbol">(</a><a id="14057" href="1Lab.Path.html#608" class="Postulate">inS</a> <a id="14061" class="Symbol">(</a><a id="14062" href="1Lab.Univalence.html#14011" class="Bound">p</a> <a id="14064" href="1Lab.Univalence.html#14013" class="Bound">i</a><a id="14065" class="Symbol">)))</a>
</pre>
<p>The “pathp to path” versions of the above lemmas are definitionally inverses, so they provide a characterisation of <code>PathP (ua f)</code> in terms of non-dependent paths.</p>
<pre class="Agda"><a id="uaPathP≃Path"></a><a id="14247" href="1Lab.Univalence.html#14247" class="Function">uaPathP≃Path</a> <a id="14260" class="Symbol">:</a> <a id="14262" class="Symbol">∀</a> <a id="14264" class="Symbol">{</a><a id="14265" href="1Lab.Univalence.html#14265" class="Bound">A</a> <a id="14267" href="1Lab.Univalence.html#14267" class="Bound">B</a> <a id="14269" class="Symbol">:</a> <a id="14271" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14276" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="14277" class="Symbol">}</a> <a id="14279" class="Symbol">(</a><a id="14280" href="1Lab.Univalence.html#14280" class="Bound">e</a> <a id="14282" class="Symbol">:</a> <a id="14284" href="1Lab.Univalence.html#14265" class="Bound">A</a> <a id="14286" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="14288" href="1Lab.Univalence.html#14267" class="Bound">B</a><a id="14289" class="Symbol">)</a> <a id="14291" class="Symbol">{</a><a id="14292" href="1Lab.Univalence.html#14292" class="Bound">x</a> <a id="14294" class="Symbol">:</a> <a id="14296" href="1Lab.Univalence.html#14265" class="Bound">A</a><a id="14297" class="Symbol">}</a> <a id="14299" class="Symbol">{</a><a id="14300" href="1Lab.Univalence.html#14300" class="Bound">y</a> <a id="14302" class="Symbol">:</a> <a id="14304" href="1Lab.Univalence.html#14267" class="Bound">B</a><a id="14305" class="Symbol">}</a>
             <a id="14320" class="Symbol">→</a> <a id="14322" class="Symbol">(</a><a id="14323" href="1Lab.Univalence.html#14280" class="Bound">e</a> <a id="14325" class="Symbol">.</a><a id="14326" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="14330" href="1Lab.Univalence.html#14292" class="Bound">x</a> <a id="14332" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="14334" href="1Lab.Univalence.html#14300" class="Bound">y</a><a id="14335" class="Symbol">)</a> <a id="14337" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="14339" class="Symbol">(</a><a id="14340" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="14346" class="Symbol">(λ</a> <a id="14349" href="1Lab.Univalence.html#14349" class="Bound">i</a> <a id="14351" class="Symbol">→</a> <a id="14353" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="14356" href="1Lab.Univalence.html#14280" class="Bound">e</a> <a id="14358" href="1Lab.Univalence.html#14349" class="Bound">i</a><a id="14359" class="Symbol">)</a> <a id="14361" href="1Lab.Univalence.html#14292" class="Bound">x</a> <a id="14363" href="1Lab.Univalence.html#14300" class="Bound">y</a><a id="14364" class="Symbol">)</a>
<a id="14366" href="1Lab.Univalence.html#14247" class="Function">uaPathP≃Path</a> <a id="14379" href="1Lab.Univalence.html#14379" class="Bound">eqv</a> <a id="14383" class="Symbol">.</a><a id="14384" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="14388" class="Symbol">=</a> <a id="14390" href="1Lab.Univalence.html#13860" class="Function">Path→uaPathP</a> <a id="14403" href="1Lab.Univalence.html#14379" class="Bound">eqv</a>
<a id="14407" href="1Lab.Univalence.html#14247" class="Function">uaPathP≃Path</a> <a id="14420" href="1Lab.Univalence.html#14420" class="Bound">eqv</a> <a id="14424" class="Symbol">.</a><a id="14425" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="14429" class="Symbol">.</a><a id="14430" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a id="14436" href="1Lab.Univalence.html#14436" class="Bound">y</a> <a id="14438" class="Symbol">.</a><a id="14439" href="1Lab.HLevel.html#1400" class="Field">centre</a> <a id="14446" class="Symbol">=</a> <a id="14448" href="1Lab.Equiv.html#2799" class="Function">strict-fibres</a> <a id="14462" class="Symbol">(</a><a id="14463" href="1Lab.Univalence.html#12450" class="Function">uaPathP→Path</a> <a id="14476" href="1Lab.Univalence.html#14420" class="Bound">eqv</a><a id="14479" class="Symbol">)</a> <a id="14481" href="1Lab.Univalence.html#14436" class="Bound">y</a> <a id="14483" class="Symbol">.</a><a id="14484" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
<a id="14488" href="1Lab.Univalence.html#14247" class="Function">uaPathP≃Path</a> <a id="14501" href="1Lab.Univalence.html#14501" class="Bound">eqv</a> <a id="14505" class="Symbol">.</a><a id="14506" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="14510" class="Symbol">.</a><a id="14511" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a id="14517" href="1Lab.Univalence.html#14517" class="Bound">y</a> <a id="14519" class="Symbol">.</a><a id="14520" href="1Lab.HLevel.html#1415" class="Field">paths</a> <a id="14526" class="Symbol">=</a> <a id="14528" href="1Lab.Equiv.html#2799" class="Function">strict-fibres</a> <a id="14542" class="Symbol">(</a><a id="14543" href="1Lab.Univalence.html#12450" class="Function">uaPathP→Path</a> <a id="14556" href="1Lab.Univalence.html#14501" class="Bound">eqv</a><a id="14559" class="Symbol">)</a> <a id="14561" href="1Lab.Univalence.html#14517" class="Bound">y</a> <a id="14563" class="Symbol">.</a><a id="14564" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a>
</pre>
<h1 id="the-axiom">The “axiom”</h1>
<p>The actual “univalence axiom”, as stated in the HoTT book, says that the canonical map <code>A ≡ B</code>, defined using <span class="Agda"><a href="1Lab.Path.html#18079" class="Function">J</a></span>, is an equivalence. This map is <span class="Agda"><a href="1Lab.Univalence.html#14947" class="Function">idToEquiv</a></span>, defined right above. In more intuitive terms, it’s “casting” the identity equivalence <code>A ≃ A</code> along a proof that <code>A ≡ B</code> to get an equivalence <code>A ≃ B</code>.</p>
<pre class="Agda"><a id="14922" class="Keyword">module</a> <a id="14929" href="1Lab.Univalence.html#14929" class="Module">_</a> <a id="14931" class="Keyword">where</a> <a id="14937" class="Keyword">private</a>
  <a id="14947" href="1Lab.Univalence.html#14947" class="Function">idToEquiv</a> <a id="14957" class="Symbol">:</a> <a id="14959" class="Symbol">{</a><a id="14960" href="1Lab.Univalence.html#14960" class="Bound">A</a> <a id="14962" href="1Lab.Univalence.html#14962" class="Bound">B</a> <a id="14964" class="Symbol">:</a> <a id="14966" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14971" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="14972" class="Symbol">}</a> <a id="14974" class="Symbol">→</a> <a id="14976" href="1Lab.Univalence.html#14960" class="Bound">A</a> <a id="14978" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="14980" href="1Lab.Univalence.html#14962" class="Bound">B</a> <a id="14982" class="Symbol">→</a> <a id="14984" href="1Lab.Univalence.html#14960" class="Bound">A</a> <a id="14986" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="14988" href="1Lab.Univalence.html#14962" class="Bound">B</a>
  <a id="14992" href="1Lab.Univalence.html#14947" class="Function">idToEquiv</a> <a id="15002" class="Symbol">{</a><a id="15003" class="Argument">A</a> <a id="15005" class="Symbol">=</a> <a id="15007" href="1Lab.Univalence.html#15007" class="Bound">A</a><a id="15008" class="Symbol">}</a> <a id="15010" class="Symbol">{</a><a id="15011" href="1Lab.Univalence.html#15011" class="Bound">B</a><a id="15012" class="Symbol">}</a> <a id="15014" class="Symbol">=</a> <a id="15016" href="1Lab.Path.html#18079" class="Function">J</a> <a id="15018" class="Symbol">(λ</a> <a id="15021" href="1Lab.Univalence.html#15021" class="Bound">x</a> <a id="15023" href="1Lab.Univalence.html#15023" class="Bound">_</a> <a id="15025" class="Symbol">→</a> <a id="15027" href="1Lab.Univalence.html#15007" class="Bound">A</a> <a id="15029" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="15031" href="1Lab.Univalence.html#15021" class="Bound">x</a><a id="15032" class="Symbol">)</a> <a id="15034" class="Symbol">(_</a> <a id="15037" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="15039" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15046" class="Symbol">)</a>

  <a id="15051" href="1Lab.Univalence.html#15051" class="Function">idToEquiv-refl</a> <a id="15066" class="Symbol">:</a> <a id="15068" class="Symbol">{</a><a id="15069" href="1Lab.Univalence.html#15069" class="Bound">A</a> <a id="15071" class="Symbol">:</a> <a id="15073" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15078" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="15079" class="Symbol">}</a> <a id="15081" class="Symbol">→</a> <a id="15083" href="1Lab.Univalence.html#14947" class="Function">idToEquiv</a> <a id="15093" class="Symbol">(λ</a> <a id="15096" href="1Lab.Univalence.html#15096" class="Bound">i</a> <a id="15098" class="Symbol">→</a> <a id="15100" href="1Lab.Univalence.html#15069" class="Bound">A</a><a id="15101" class="Symbol">)</a> <a id="15103" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="15105" class="Symbol">(_</a> <a id="15108" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="15110" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15117" class="Symbol">)</a>
  <a id="15121" href="1Lab.Univalence.html#15051" class="Function">idToEquiv-refl</a> <a id="15136" class="Symbol">{</a><a id="15137" class="Argument">A</a> <a id="15139" class="Symbol">=</a> <a id="15141" href="1Lab.Univalence.html#15141" class="Bound">A</a><a id="15142" class="Symbol">}</a> <a id="15144" class="Symbol">=</a> <a id="15146" href="1Lab.Path.html#18637" class="Function">JRefl</a> <a id="15152" class="Symbol">(λ</a> <a id="15155" href="1Lab.Univalence.html#15155" class="Bound">x</a> <a id="15157" href="1Lab.Univalence.html#15157" class="Bound">_</a> <a id="15159" class="Symbol">→</a> <a id="15161" href="1Lab.Univalence.html#15141" class="Bound">A</a> <a id="15163" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="15165" href="1Lab.Univalence.html#15155" class="Bound">x</a><a id="15166" class="Symbol">)</a> <a id="15168" class="Symbol">(_</a> <a id="15171" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="15173" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15180" class="Symbol">)</a>
</pre>
<p>However, because of efficiency concerns (Agda <em>is</em> a programming language, after all), instead of using <span class="Agda"><a href="1Lab.Univalence.html#14947" class="Function">idToEquiv</a></span> defined using J, we use <span class="Agda"><a href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a></span>, which is <a href="1Lab.Equiv.FromPath.html">defined in an auxilliary module</a>.</p>
<pre class="Agda"><a id="pathToEquiv"></a><a id="15435" href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a> <a id="15447" class="Symbol">:</a> <a id="15449" class="Symbol">{</a><a id="15450" href="1Lab.Univalence.html#15450" class="Bound">A</a> <a id="15452" href="1Lab.Univalence.html#15452" class="Bound">B</a> <a id="15454" class="Symbol">:</a> <a id="15456" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15461" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="15462" class="Symbol">}</a> <a id="15464" class="Symbol">→</a> <a id="15466" href="1Lab.Univalence.html#15450" class="Bound">A</a> <a id="15468" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="15470" href="1Lab.Univalence.html#15452" class="Bound">B</a> <a id="15472" class="Symbol">→</a> <a id="15474" href="1Lab.Univalence.html#15450" class="Bound">A</a> <a id="15476" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="15478" href="1Lab.Univalence.html#15452" class="Bound">B</a>
<a id="15480" href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a> <a id="15492" href="1Lab.Univalence.html#15492" class="Bound">p</a> <a id="15494" class="Symbol">=</a> <a id="15496" href="1Lab.Equiv.FromPath.html#9222" class="Function">line→equiv</a> <a id="15507" class="Symbol">(λ</a> <a id="15510" href="1Lab.Univalence.html#15510" class="Bound">i</a> <a id="15512" class="Symbol">→</a> <a id="15514" href="1Lab.Univalence.html#15492" class="Bound">p</a> <a id="15516" href="1Lab.Univalence.html#15510" class="Bound">i</a><a id="15517" class="Symbol">)</a>
</pre>
<p>Since equality of equivalences is determined by equality of their underlying functions, to show that <span class="Agda"><a href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a></span> of <span class="Agda"><a href="1Lab.Path.html#2137" class="Function">refl</a></span> is the identity equivalence, we use <span class="Agda"><a href="1Lab.Path.html#49792" class="Function">coe1→i</a></span> to show that <span class="Agda"><a href="1Lab.Path.html#10335" class="Function">transport</a></span> by <span class="Agda"><a href="1Lab.Path.html#2137" class="Function">refl</a></span> is the identity.</p>
<pre class="Agda"><a id="pathToEquiv-refl"></a><a id="15790" href="1Lab.Univalence.html#15790" class="Function">pathToEquiv-refl</a> <a id="15807" class="Symbol">:</a> <a id="15809" class="Symbol">{</a><a id="15810" href="1Lab.Univalence.html#15810" class="Bound">A</a> <a id="15812" class="Symbol">:</a> <a id="15814" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15819" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="15820" class="Symbol">}</a> <a id="15822" class="Symbol">→</a> <a id="15824" href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a> <a id="15836" class="Symbol">(</a><a id="15837" href="1Lab.Path.html#2137" class="Function">refl</a> <a id="15842" class="Symbol">{</a><a id="15843" class="Argument">x</a> <a id="15845" class="Symbol">=</a> <a id="15847" href="1Lab.Univalence.html#15810" class="Bound">A</a><a id="15848" class="Symbol">})</a> <a id="15851" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="15853" class="Symbol">(</a><a id="15854" href="1Lab.Type.html#2348" class="Function">id</a> <a id="15857" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="15859" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15866" class="Symbol">)</a>
<a id="15868" href="1Lab.Univalence.html#15790" class="Function">pathToEquiv-refl</a> <a id="15885" class="Symbol">{</a><a id="15886" class="Argument">A</a> <a id="15888" class="Symbol">=</a> <a id="15890" href="1Lab.Univalence.html#15890" class="Bound">A</a><a id="15891" class="Symbol">}</a> <a id="15893" class="Symbol">=</a>
  <a id="15897" href="1Lab.Path.html#55613" class="Function">Σ-Path</a> <a id="15904" class="Symbol">(λ</a> <a id="15907" href="1Lab.Univalence.html#15907" class="Bound">i</a> <a id="15909" href="1Lab.Univalence.html#15909" class="Bound">x</a> <a id="15911" class="Symbol">→</a> <a id="15913" href="1Lab.Path.html#49792" class="Function">coe1→i</a> <a id="15920" class="Symbol">(λ</a> <a id="15923" href="1Lab.Univalence.html#15923" class="Bound">i</a> <a id="15925" class="Symbol">→</a> <a id="15927" href="1Lab.Univalence.html#15890" class="Bound">A</a><a id="15928" class="Symbol">)</a> <a id="15930" href="1Lab.Univalence.html#15907" class="Bound">i</a> <a id="15932" href="1Lab.Univalence.html#15909" class="Bound">x</a><a id="15933" class="Symbol">)</a>
         <a id="15944" class="Symbol">(</a><a id="15945" href="1Lab.HLevel.html#13403" class="Function">isProp→PathP</a> <a id="15958" class="Symbol">(λ</a> <a id="15961" href="1Lab.Univalence.html#15961" class="Bound">i</a> <a id="15963" class="Symbol">→</a> <a id="15965" href="1Lab.Equiv.html#4883" class="Function">isProp-isEquiv</a> <a id="15980" class="Symbol">_)</a> <a id="15983" class="Symbol">_</a> <a id="15985" class="Symbol">_)</a>
</pre>
<p>For the other direction, we must show that <span class="Agda"><a href="1Lab.Univalence.html#8768" class="Function">ua</a></span> of <span class="Agda"><a href="1Lab.Equiv.html#2526" class="Function">idEquiv</a></span> is <span class="Agda"><a href="1Lab.Path.html#2137" class="Function">refl</a></span>. We can do this quite efficiently using <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span>. Since this is a path between paths, we have two interval variables.</p>
<pre class="Agda"><a id="uaIdEquiv"></a><a id="16217" href="1Lab.Univalence.html#16217" class="Function">uaIdEquiv</a> <a id="16227" class="Symbol">:</a> <a id="16229" class="Symbol">{</a><a id="16230" href="1Lab.Univalence.html#16230" class="Bound">A</a> <a id="16232" class="Symbol">:</a> <a id="16234" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="16239" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="16240" class="Symbol">}</a> <a id="16242" class="Symbol">→</a> <a id="16244" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="16247" class="Symbol">(_</a> <a id="16250" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="16252" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a> <a id="16260" class="Symbol">{</a><a id="16261" class="Argument">A</a> <a id="16263" class="Symbol">=</a> <a id="16265" href="1Lab.Univalence.html#16230" class="Bound">A</a><a id="16266" class="Symbol">})</a> <a id="16269" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16271" href="1Lab.Path.html#2137" class="Function">refl</a>
<a id="16276" href="1Lab.Univalence.html#16217" class="Function">uaIdEquiv</a> <a id="16286" class="Symbol">{</a><a id="16287" class="Argument">A</a> <a id="16289" class="Symbol">=</a> <a id="16291" href="1Lab.Univalence.html#16291" class="Bound">A</a><a id="16292" class="Symbol">}</a> <a id="16294" href="1Lab.Univalence.html#16294" class="Bound">i</a> <a id="16296" href="1Lab.Univalence.html#16296" class="Bound">j</a> <a id="16298" class="Symbol">=</a> <a id="16300" href="1Lab.Univalence.html#3381" class="Function">Glue</a> <a id="16305" href="1Lab.Univalence.html#16291" class="Bound">A</a> <a id="16307" class="Symbol">{</a><a id="16308" class="Argument">φ</a> <a id="16310" class="Symbol">=</a> <a id="16312" href="1Lab.Univalence.html#16294" class="Bound">i</a> <a id="16314" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="16316" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="16318" href="1Lab.Univalence.html#16296" class="Bound">j</a> <a id="16320" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="16322" href="1Lab.Univalence.html#16296" class="Bound">j</a><a id="16323" class="Symbol">}</a> <a id="16325" class="Symbol">(λ</a> <a id="16328" href="1Lab.Univalence.html#16328" class="Bound">_</a> <a id="16330" class="Symbol">→</a> <a id="16332" href="1Lab.Univalence.html#16291" class="Bound">A</a> <a id="16334" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="16336" class="Symbol">_</a> <a id="16338" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="16340" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="16347" class="Symbol">)</a>
</pre>
<p>We can then prove that the map <span class="Agda"><a href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a></span> is an isomorphism, hence an equivalence. It’s very useful to have explicit names for the proofs that <span class="Agda"><a href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a></span> and <span class="Agda"><a href="1Lab.Univalence.html#8768" class="Function">ua</a></span> are equivalences without referring to components of <span class="Agda"><a href="1Lab.Univalence.html#16670" class="Function">univalence-Iso</a></span>, so we introduce names for them as well.</p>
<pre class="Agda"><a id="univalence-Iso"></a><a id="16670" href="1Lab.Univalence.html#16670" class="Function">univalence-Iso</a> <a id="16685" class="Symbol">:</a> <a id="16687" class="Symbol">{</a><a id="16688" href="1Lab.Univalence.html#16688" class="Bound">A</a> <a id="16690" href="1Lab.Univalence.html#16690" class="Bound">B</a> <a id="16692" class="Symbol">:</a> <a id="16694" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="16699" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="16700" class="Symbol">}</a> <a id="16702" class="Symbol">→</a> <a id="16704" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="16708" class="Symbol">(</a><a id="16709" href="1Lab.Univalence.html#16688" class="Bound">A</a> <a id="16711" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16713" href="1Lab.Univalence.html#16690" class="Bound">B</a><a id="16714" class="Symbol">)</a> <a id="16716" class="Symbol">(</a><a id="16717" href="1Lab.Univalence.html#16688" class="Bound">A</a> <a id="16719" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="16721" href="1Lab.Univalence.html#16690" class="Bound">B</a><a id="16722" class="Symbol">)</a>
<a id="univalence"></a><a id="16724" href="1Lab.Univalence.html#16724" class="Function">univalence</a>     <a id="16739" class="Symbol">:</a> <a id="16741" class="Symbol">{</a><a id="16742" href="1Lab.Univalence.html#16742" class="Bound">A</a> <a id="16744" href="1Lab.Univalence.html#16744" class="Bound">B</a> <a id="16746" class="Symbol">:</a> <a id="16748" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="16753" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="16754" class="Symbol">}</a> <a id="16756" class="Symbol">→</a> <a id="16758" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="16766" class="Symbol">(</a><a id="16767" href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a> <a id="16779" class="Symbol">{</a><a id="16780" class="Argument">A</a> <a id="16782" class="Symbol">=</a> <a id="16784" href="1Lab.Univalence.html#16742" class="Bound">A</a><a id="16785" class="Symbol">}</a> <a id="16787" class="Symbol">{</a><a id="16788" href="1Lab.Univalence.html#16744" class="Bound">B</a><a id="16789" class="Symbol">})</a>
<a id="univalence⁻¹"></a><a id="16792" href="1Lab.Univalence.html#16792" class="Function">univalence⁻¹</a>   <a id="16807" class="Symbol">:</a> <a id="16809" class="Symbol">{</a><a id="16810" href="1Lab.Univalence.html#16810" class="Bound">A</a> <a id="16812" href="1Lab.Univalence.html#16812" class="Bound">B</a> <a id="16814" class="Symbol">:</a> <a id="16816" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="16821" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="16822" class="Symbol">}</a> <a id="16824" class="Symbol">→</a> <a id="16826" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="16834" class="Symbol">(</a><a id="16835" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="16838" class="Symbol">{</a><a id="16839" class="Argument">A</a> <a id="16841" class="Symbol">=</a> <a id="16843" href="1Lab.Univalence.html#16810" class="Bound">A</a><a id="16844" class="Symbol">}</a> <a id="16846" class="Symbol">{</a><a id="16847" href="1Lab.Univalence.html#16812" class="Bound">B</a><a id="16848" class="Symbol">})</a>

<a id="16852" href="1Lab.Univalence.html#16670" class="Function">univalence-Iso</a> <a id="16867" class="Symbol">{</a><a id="16868" class="Argument">A</a> <a id="16870" class="Symbol">=</a> <a id="16872" href="1Lab.Univalence.html#16872" class="Bound">A</a><a id="16873" class="Symbol">}</a> <a id="16875" class="Symbol">{</a><a id="16876" class="Argument">B</a> <a id="16878" class="Symbol">=</a> <a id="16880" href="1Lab.Univalence.html#16880" class="Bound">B</a><a id="16881" class="Symbol">}</a> <a id="16883" class="Symbol">=</a> <a id="16885" href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a> <a id="16897" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="16899" href="1Lab.Univalence.html#16912" class="Function">iiso</a> <a id="16904" class="Keyword">where</a>
  <a id="16912" href="1Lab.Univalence.html#16912" class="Function">iiso</a> <a id="16917" class="Symbol">:</a> <a id="16919" href="1Lab.Equiv.html#5975" class="Record">isIso</a> <a id="16925" href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a>
  <a id="16939" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="16949" href="1Lab.Univalence.html#16912" class="Function">iiso</a> <a id="16954" class="Symbol">=</a> <a id="16956" href="1Lab.Univalence.html#8768" class="Function">ua</a>
</pre>
<p>We show that <code>pathToEquiv</code> inverts <span class="Agda"><a href="1Lab.Univalence.html#8768" class="Function">ua</a></span>, which means proving that one can recover the original equivalence from the generated path. Because of the computational nature of Cubical Agda, all we have to do is apply <span class="Agda"><a href="1Lab.Univalence.html#10927" class="Function">uaβ</a></span>:</p>
<pre class="Agda">  <a id="17208" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="17219" href="1Lab.Univalence.html#16912" class="Function">iiso</a> <a id="17224" class="Symbol">(</a><a id="17225" href="1Lab.Univalence.html#17225" class="Bound">f</a> <a id="17227" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17229" href="1Lab.Univalence.html#17229" class="Bound">isEqv</a><a id="17234" class="Symbol">)</a> <a id="17236" class="Symbol">=</a>
    <a id="17242" href="1Lab.Path.html#55613" class="Function">Σ-Path</a> <a id="17249" class="Symbol">(</a><a id="17250" href="1Lab.Path.html#56431" class="Function">funext</a> <a id="17257" class="Symbol">(</a><a id="17258" href="1Lab.Univalence.html#10927" class="Function">uaβ</a> <a id="17262" class="Symbol">(</a><a id="17263" href="1Lab.Univalence.html#17225" class="Bound">f</a> <a id="17265" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17267" href="1Lab.Univalence.html#17229" class="Bound">isEqv</a><a id="17272" class="Symbol">)))</a> <a id="17276" class="Symbol">(</a><a id="17277" href="1Lab.Equiv.html#4883" class="Function">isProp-isEquiv</a> <a id="17292" href="1Lab.Univalence.html#17225" class="Bound">f</a> <a id="17294" class="Symbol">_</a> <a id="17296" class="Symbol">_)</a>
</pre>
<p>For the other direction, we use <a href="1Lab.Path.html#J">path induction</a> to reduce the problem from showing that <span class="Agda"><a href="1Lab.Univalence.html#8768" class="Function">ua</a></span> inverts <span class="Agda"><a href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a></span> for an arbitrary path (which is hard) to showing that <span class="Agda"><a href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a></span> takes <span class="Agda"><a href="1Lab.Path.html#2137" class="Function">refl</a></span> to the identity equivalence (<span class="Agda"><a href="1Lab.Univalence.html#15790" class="Function">pathToEquiv-refl</a></span>), and that <span class="Agda"><a href="1Lab.Univalence.html#8768" class="Function">ua</a></span> takes the identity equivalence to <span class="Agda"><a href="1Lab.Path.html#2137" class="Function">refl</a></span> (<span class="Agda"><a href="1Lab.Univalence.html#16217" class="Function">uaIdEquiv</a></span>).</p>
<pre class="Agda">  <a id="17724" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="17735" href="1Lab.Univalence.html#16912" class="Function">iiso</a> <a id="17740" class="Symbol">=</a> 
    <a id="17747" href="1Lab.Path.html#18079" class="Function">J</a> <a id="17749" class="Symbol">(λ</a> <a id="17752" href="1Lab.Univalence.html#17752" class="Bound">_</a> <a id="17754" href="1Lab.Univalence.html#17754" class="Bound">p</a> <a id="17756" class="Symbol">→</a> <a id="17758" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="17761" class="Symbol">(</a><a id="17762" href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a> <a id="17774" href="1Lab.Univalence.html#17754" class="Bound">p</a><a id="17775" class="Symbol">)</a> <a id="17777" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="17779" href="1Lab.Univalence.html#17754" class="Bound">p</a><a id="17780" class="Symbol">)</a>
      <a id="17788" class="Symbol">(</a><a id="17789" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="17792" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="17795" href="1Lab.Univalence.html#15790" class="Function">pathToEquiv-refl</a> <a id="17812" href="1Lab.Path.html#38031" class="Function Operator">∙</a> <a id="17814" href="1Lab.Univalence.html#16217" class="Function">uaIdEquiv</a><a id="17823" class="Symbol">)</a>

<a id="17826" href="1Lab.Univalence.html#16724" class="Function">univalence</a> <a id="17837" class="Symbol">{</a><a id="17838" class="Argument">A</a> <a id="17840" class="Symbol">=</a> <a id="17842" href="1Lab.Univalence.html#17842" class="Bound">A</a><a id="17843" class="Symbol">}</a> <a id="17845" class="Symbol">{</a><a id="17846" href="1Lab.Univalence.html#17846" class="Bound">B</a><a id="17847" class="Symbol">}</a> <a id="17849" class="Symbol">=</a> <a id="17851" href="1Lab.Equiv.html#19765" class="Function">isIso→isEquiv</a> <a id="17865" class="Symbol">(</a><a id="17866" href="1Lab.Univalence.html#16670" class="Function">univalence-Iso</a> <a id="17881" class="Symbol">.</a><a id="17882" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="17885" class="Symbol">)</a>
<a id="17887" href="1Lab.Univalence.html#16792" class="Function">univalence⁻¹</a> <a id="17900" class="Symbol">{</a><a id="17901" class="Argument">A</a> <a id="17903" class="Symbol">=</a> <a id="17905" href="1Lab.Univalence.html#17905" class="Bound">A</a><a id="17906" class="Symbol">}</a> <a id="17908" class="Symbol">{</a><a id="17909" href="1Lab.Univalence.html#17909" class="Bound">B</a><a id="17910" class="Symbol">}</a> <a id="17912" class="Symbol">=</a> <a id="17914" href="1Lab.Equiv.html#19765" class="Function">isIso→isEquiv</a> <a id="17928" class="Symbol">(</a><a id="17929" href="1Lab.Equiv.html#6158" class="Function">isIso.inverse</a> <a id="17943" class="Symbol">(</a><a id="17944" href="1Lab.Univalence.html#16670" class="Function">univalence-Iso</a> <a id="17959" class="Symbol">.</a><a id="17960" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="17963" class="Symbol">))</a>
</pre>
<p>In some situations, it is helpful to have a proof that <span class="Agda"><a href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a></span> followed by <code class="sourceCode agda" data-ident="Lift">an adjustment of levels</code> is still an equivalence:</p>
<pre class="Agda"><a id="univalence-lift"></a><a id="18137" href="1Lab.Univalence.html#18137" class="Function">univalence-lift</a> <a id="18153" class="Symbol">:</a> <a id="18155" class="Symbol">{</a><a id="18156" href="1Lab.Univalence.html#18156" class="Bound">A</a> <a id="18158" href="1Lab.Univalence.html#18158" class="Bound">B</a> <a id="18160" class="Symbol">:</a> <a id="18162" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="18167" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="18168" class="Symbol">}</a> <a id="18170" class="Symbol">→</a> <a id="18172" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="18180" class="Symbol">(λ</a> <a id="18183" href="1Lab.Univalence.html#18183" class="Bound">e</a> <a id="18185" class="Symbol">→</a> <a id="18187" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a id="18192" class="Symbol">(</a><a id="18193" href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a> <a id="18205" class="Symbol">{</a><a id="18206" class="Argument">A</a> <a id="18208" class="Symbol">=</a> <a id="18210" href="1Lab.Univalence.html#18156" class="Bound">A</a><a id="18211" class="Symbol">}</a> <a id="18213" class="Symbol">{</a><a id="18214" href="1Lab.Univalence.html#18158" class="Bound">B</a><a id="18215" class="Symbol">}</a> <a id="18217" href="1Lab.Univalence.html#18183" class="Bound">e</a><a id="18218" class="Symbol">))</a>
<a id="18221" href="1Lab.Univalence.html#18137" class="Function">univalence-lift</a> <a id="18237" class="Symbol">{</a><a id="18238" class="Argument">ℓ</a> <a id="18240" class="Symbol">=</a> <a id="18242" href="1Lab.Univalence.html#18242" class="Bound">ℓ</a><a id="18243" class="Symbol">}</a> <a id="18245" class="Symbol">=</a> <a id="18247" href="1Lab.Equiv.html#19765" class="Function">isIso→isEquiv</a> <a id="18261" href="1Lab.Univalence.html#18274" class="Function">morp</a> <a id="18266" class="Keyword">where</a>
  <a id="18274" href="1Lab.Univalence.html#18274" class="Function">morp</a> <a id="18279" class="Symbol">:</a> <a id="18281" href="1Lab.Equiv.html#5975" class="Record">isIso</a> <a id="18287" class="Symbol">(λ</a> <a id="18290" href="1Lab.Univalence.html#18290" class="Bound">e</a> <a id="18292" class="Symbol">→</a> <a id="18294" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a id="18299" class="Symbol">{</a><a id="18300" class="Argument">ℓ</a> <a id="18302" class="Symbol">=</a> <a id="18304" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="18309" href="1Lab.Univalence.html#18242" class="Bound">ℓ</a><a id="18310" class="Symbol">}</a> <a id="18312" class="Symbol">(</a><a id="18313" href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a> <a id="18325" href="1Lab.Univalence.html#18290" class="Bound">e</a><a id="18326" class="Symbol">))</a>
  <a id="18331" href="1Lab.Univalence.html#18274" class="Function">morp</a> <a id="18336" class="Symbol">.</a><a id="18337" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="18347" href="1Lab.Univalence.html#18347" class="Bound">x</a> <a id="18349" class="Symbol">=</a> <a id="18351" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="18354" class="Symbol">(</a><a id="18355" href="1Lab.Univalence.html#18347" class="Bound">x</a> <a id="18357" class="Symbol">.</a><a id="18358" href="1Lab.Type.html#2082" class="Field">Lift.lower</a><a id="18368" class="Symbol">)</a>
  <a id="18372" href="1Lab.Univalence.html#18274" class="Function">morp</a> <a id="18377" class="Symbol">.</a><a id="18378" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="18389" href="1Lab.Univalence.html#18389" class="Bound">x</a> <a id="18391" class="Symbol">=</a>
    <a id="18397" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a id="18402" class="Symbol">(</a><a id="18403" href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a> <a id="18415" class="Symbol">(</a><a id="18416" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="18419" class="Symbol">(</a><a id="18420" href="1Lab.Univalence.html#18389" class="Bound">x</a> <a id="18422" class="Symbol">.</a><a id="18423" href="1Lab.Type.html#2082" class="Field">Lift.lower</a><a id="18433" class="Symbol">)))</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="18437" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a id="18440" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="18443" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a id="18448" class="Symbol">(</a><a id="18449" href="1Lab.Univalence.html#16670" class="Function">univalence-Iso</a> <a id="18464" class="Symbol">.</a><a id="18465" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18469" class="Symbol">.</a><a id="18470" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="18481" class="Symbol">_)</a> <a id="18484" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
    <a id="18490" href="1Lab.Univalence.html#18389" class="Bound">x</a>                                       <a id="18530" href="1Lab.Path.html#45365" class="Function Operator">∎</a>
  <a id="18534" href="1Lab.Univalence.html#18274" class="Function">morp</a> <a id="18539" class="Symbol">.</a><a id="18540" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="18551" href="1Lab.Univalence.html#18551" class="Bound">x</a> <a id="18553" class="Symbol">=</a> <a id="18555" href="1Lab.Univalence.html#16670" class="Function">univalence-Iso</a> <a id="18570" class="Symbol">.</a><a id="18571" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18575" class="Symbol">.</a><a id="18576" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="18587" class="Symbol">_</a>
</pre>
<h2 id="equivalence-induction">Equivalence Induction</h2>
<p>One useful consequence of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>≡</mo><mi>B</mi><mo stretchy="false">)</mo><mo>≃</mo><mo stretchy="false">(</mo><mi>A</mi><mo>≃</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A \equiv B) \simeq (A \simeq B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> is that the type of <em>equivalences</em> satisfies <a href="1Lab.Path.html#J">the same induction principle</a> as the type of <em>equalities</em>. By analogy with how path induction can be characterised as contractibility of singletons and transport, “equivalence induction” can be characterised as transport and contractibility of <em>singletons up to equivalence</em>:</p>
<pre class="Agda"><a id="EquivContr"></a><a id="19066" href="1Lab.Univalence.html#19066" class="Function">EquivContr</a> <a id="19077" class="Symbol">:</a> <a id="19079" class="Symbol">∀</a> <a id="19081" class="Symbol">{</a><a id="19082" href="1Lab.Univalence.html#19082" class="Bound">ℓ</a><a id="19083" class="Symbol">}</a> <a id="19085" class="Symbol">(</a><a id="19086" href="1Lab.Univalence.html#19086" class="Bound">A</a> <a id="19088" class="Symbol">:</a> <a id="19090" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19095" href="1Lab.Univalence.html#19082" class="Bound">ℓ</a><a id="19096" class="Symbol">)</a> <a id="19098" class="Symbol">→</a> <a id="19100" href="1Lab.HLevel.html#1328" class="Record">isContr</a> <a id="19108" class="Symbol">(</a><a id="19109" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="19112" href="1Lab.Univalence.html#19112" class="Bound">B</a> <a id="19114" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="19116" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19121" href="1Lab.Univalence.html#19082" class="Bound">ℓ</a> <a id="19123" href="1Lab.Type.html#1563" class="Function">]</a> <a id="19125" href="1Lab.Univalence.html#19086" class="Bound">A</a> <a id="19127" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="19129" href="1Lab.Univalence.html#19112" class="Bound">B</a><a id="19130" class="Symbol">)</a>
<a id="19132" href="1Lab.HLevel.html#1400" class="Field">isContr.centre</a> <a id="19147" class="Symbol">(</a><a id="19148" href="1Lab.Univalence.html#19066" class="Function">EquivContr</a> <a id="19159" href="1Lab.Univalence.html#19159" class="Bound">A</a><a id="19160" class="Symbol">)</a>            <a id="19173" class="Symbol">=</a> <a id="19175" href="1Lab.Univalence.html#19159" class="Bound">A</a> <a id="19177" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19179" class="Symbol">_</a> <a id="19181" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19183" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>
<a id="19191" href="1Lab.HLevel.html#1415" class="Field">isContr.paths</a> <a id="19205" class="Symbol">(</a><a id="19206" href="1Lab.Univalence.html#19066" class="Function">EquivContr</a> <a id="19217" href="1Lab.Univalence.html#19217" class="Bound">A</a><a id="19218" class="Symbol">)</a> <a id="19220" class="Symbol">(</a><a id="19221" href="1Lab.Univalence.html#19221" class="Bound">B</a> <a id="19223" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19225" href="1Lab.Univalence.html#19225" class="Bound">A≃B</a><a id="19228" class="Symbol">)</a> <a id="19230" href="1Lab.Univalence.html#19230" class="Bound">i</a> <a id="19232" class="Symbol">=</a> <a id="19234" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="19237" href="1Lab.Univalence.html#19225" class="Bound">A≃B</a> <a id="19241" href="1Lab.Univalence.html#19230" class="Bound">i</a> <a id="19243" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19245" href="1Lab.Univalence.html#19263" class="Function">p</a> <a id="19247" href="1Lab.Univalence.html#19230" class="Bound">i</a> <a id="19249" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19251" href="1Lab.Univalence.html#19382" class="Function">q</a> <a id="19253" href="1Lab.Univalence.html#19230" class="Bound">i</a> <a id="19255" class="Keyword">where</a>
  <a id="19263" href="1Lab.Univalence.html#19263" class="Function">p</a> <a id="19265" class="Symbol">:</a> <a id="19267" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="19273" class="Symbol">(λ</a> <a id="19276" href="1Lab.Univalence.html#19276" class="Bound">i</a> <a id="19278" class="Symbol">→</a> <a id="19280" href="1Lab.Univalence.html#19217" class="Bound">A</a> <a id="19282" class="Symbol">→</a> <a id="19284" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="19287" href="1Lab.Univalence.html#19225" class="Bound">A≃B</a> <a id="19291" href="1Lab.Univalence.html#19276" class="Bound">i</a><a id="19292" class="Symbol">)</a> <a id="19294" href="1Lab.Type.html#2348" class="Function">id</a> <a id="19297" class="Symbol">(</a><a id="19298" href="1Lab.Univalence.html#19225" class="Bound">A≃B</a> <a id="19302" class="Symbol">.</a><a id="19303" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="19306" class="Symbol">)</a>
  <a id="19310" href="1Lab.Univalence.html#19263" class="Function">p</a> <a id="19312" href="1Lab.Univalence.html#19312" class="Bound">i</a> <a id="19314" href="1Lab.Univalence.html#19314" class="Bound">x</a> <a id="19316" class="Symbol">=</a> <a id="19318" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="19323" class="Symbol">(</a><a id="19324" href="1Lab.Univalence.html#13100" class="Function">ua-glue</a> <a id="19332" href="1Lab.Univalence.html#19225" class="Bound">A≃B</a> <a id="19336" href="1Lab.Univalence.html#19312" class="Bound">i</a> <a id="19338" class="Symbol">(λ</a> <a id="19341" class="Symbol">{</a> <a id="19343" class="Symbol">(</a><a id="19344" href="1Lab.Univalence.html#19312" class="Bound">i</a> <a id="19346" class="Symbol">=</a> <a id="19348" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="19350" class="Symbol">)</a> <a id="19352" class="Symbol">→</a> <a id="19354" href="1Lab.Univalence.html#19314" class="Bound">x</a> <a id="19356" class="Symbol">})</a> <a id="19359" class="Symbol">(</a><a id="19360" href="1Lab.Path.html#608" class="Postulate">inS</a> <a id="19364" class="Symbol">(</a><a id="19365" href="1Lab.Univalence.html#19225" class="Bound">A≃B</a> <a id="19369" class="Symbol">.</a><a id="19370" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="19374" href="1Lab.Univalence.html#19314" class="Bound">x</a><a id="19375" class="Symbol">)))</a>

  <a id="19382" href="1Lab.Univalence.html#19382" class="Function">q</a> <a id="19384" class="Symbol">:</a> <a id="19386" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="19392" class="Symbol">(λ</a> <a id="19395" href="1Lab.Univalence.html#19395" class="Bound">i</a> <a id="19397" class="Symbol">→</a> <a id="19399" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="19407" class="Symbol">(</a><a id="19408" href="1Lab.Univalence.html#19263" class="Function">p</a> <a id="19410" href="1Lab.Univalence.html#19395" class="Bound">i</a><a id="19411" class="Symbol">))</a> <a id="19414" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a> <a id="19422" class="Symbol">(</a><a id="19423" href="1Lab.Univalence.html#19225" class="Bound">A≃B</a> <a id="19427" class="Symbol">.</a><a id="19428" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="19431" class="Symbol">)</a>
  <a id="19435" href="1Lab.Univalence.html#19382" class="Function">q</a> <a id="19437" class="Symbol">=</a> <a id="19439" href="1Lab.HLevel.html#13403" class="Function">isProp→PathP</a> <a id="19452" class="Symbol">(λ</a> <a id="19455" href="1Lab.Univalence.html#19455" class="Bound">i</a> <a id="19457" class="Symbol">→</a> <a id="19459" href="1Lab.Equiv.html#4883" class="Function">isProp-isEquiv</a> <a id="19474" class="Symbol">(</a><a id="19475" href="1Lab.Univalence.html#19263" class="Function">p</a> <a id="19477" href="1Lab.Univalence.html#19455" class="Bound">i</a><a id="19478" class="Symbol">))</a> <a id="19481" class="Symbol">_</a> <a id="19483" class="Symbol">_</a>
</pre>
<p>Combining <span class="Agda"><a href="1Lab.Univalence.html#19066" class="Function">EquivContr</a></span> with <span class="Agda"><a href="1Lab.Path.html#13853" class="Function">subst</a></span>, we get an induction principle for the type of equivalences based at <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>: To prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(B,e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span> for any <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>A</mi><mo>≃</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">e : A \simeq B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, it suffices to consider the case where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> is the identity equivalence.</p>
<pre class="Agda"><a id="EquivJ"></a><a id="19754" href="1Lab.Univalence.html#19754" class="Function">EquivJ</a> <a id="19761" class="Symbol">:</a> <a id="19763" class="Symbol">∀</a> <a id="19765" class="Symbol">{</a><a id="19766" href="1Lab.Univalence.html#19766" class="Bound">ℓ</a> <a id="19768" href="1Lab.Univalence.html#19768" class="Bound">ℓ&#39;</a><a id="19770" class="Symbol">}</a> <a id="19772" class="Symbol">{</a><a id="19773" href="1Lab.Univalence.html#19773" class="Bound">A</a> <a id="19775" class="Symbol">:</a> <a id="19777" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19782" href="1Lab.Univalence.html#19766" class="Bound">ℓ</a><a id="19783" class="Symbol">}</a>
       <a id="19792" class="Symbol">→</a> <a id="19794" class="Symbol">(</a><a id="19795" href="1Lab.Univalence.html#19795" class="Bound">P</a> <a id="19797" class="Symbol">:</a> <a id="19799" class="Symbol">(</a><a id="19800" href="1Lab.Univalence.html#19800" class="Bound">B</a> <a id="19802" class="Symbol">:</a> <a id="19804" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19809" href="1Lab.Univalence.html#19766" class="Bound">ℓ</a><a id="19810" class="Symbol">)</a> <a id="19812" class="Symbol">→</a> <a id="19814" href="1Lab.Univalence.html#19773" class="Bound">A</a> <a id="19816" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="19818" href="1Lab.Univalence.html#19800" class="Bound">B</a> <a id="19820" class="Symbol">→</a> <a id="19822" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19827" href="1Lab.Univalence.html#19768" class="Bound">ℓ&#39;</a><a id="19829" class="Symbol">)</a>
       <a id="19838" class="Symbol">→</a> <a id="19840" href="1Lab.Univalence.html#19795" class="Bound">P</a> <a id="19842" href="1Lab.Univalence.html#19773" class="Bound">A</a> <a id="19844" class="Symbol">(_</a> <a id="19847" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19849" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="19856" class="Symbol">)</a>
       <a id="19865" class="Symbol">→</a> <a id="19867" class="Symbol">{</a><a id="19868" href="1Lab.Univalence.html#19868" class="Bound">B</a> <a id="19870" class="Symbol">:</a> <a id="19872" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19877" href="1Lab.Univalence.html#19766" class="Bound">ℓ</a><a id="19878" class="Symbol">}</a> <a id="19880" class="Symbol">(</a><a id="19881" href="1Lab.Univalence.html#19881" class="Bound">e</a> <a id="19883" class="Symbol">:</a> <a id="19885" href="1Lab.Univalence.html#19773" class="Bound">A</a> <a id="19887" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="19889" href="1Lab.Univalence.html#19868" class="Bound">B</a><a id="19890" class="Symbol">)</a>
       <a id="19899" class="Symbol">→</a> <a id="19901" href="1Lab.Univalence.html#19795" class="Bound">P</a> <a id="19903" href="1Lab.Univalence.html#19868" class="Bound">B</a> <a id="19905" href="1Lab.Univalence.html#19881" class="Bound">e</a>
<a id="19907" href="1Lab.Univalence.html#19754" class="Function">EquivJ</a> <a id="19914" href="1Lab.Univalence.html#19914" class="Bound">P</a> <a id="19916" href="1Lab.Univalence.html#19916" class="Bound">pid</a> <a id="19920" href="1Lab.Univalence.html#19920" class="Bound">eqv</a> <a id="19924" class="Symbol">=</a>
  <a id="19928" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="19934" class="Symbol">(λ</a> <a id="19937" href="1Lab.Univalence.html#19937" class="Bound">e</a> <a id="19939" class="Symbol">→</a> <a id="19941" href="1Lab.Univalence.html#19914" class="Bound">P</a> <a id="19943" class="Symbol">(</a><a id="19944" href="1Lab.Univalence.html#19937" class="Bound">e</a> <a id="19946" class="Symbol">.</a><a id="19947" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="19950" class="Symbol">)</a> <a id="19952" class="Symbol">(</a><a id="19953" href="1Lab.Univalence.html#19937" class="Bound">e</a> <a id="19955" class="Symbol">.</a><a id="19956" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="19959" class="Symbol">))</a> <a id="19962" class="Symbol">(</a><a id="19963" href="1Lab.Univalence.html#19066" class="Function">EquivContr</a> <a id="19974" class="Symbol">_</a> <a id="19976" class="Symbol">.</a><a id="19977" href="1Lab.HLevel.html#1415" class="Field">isContr.paths</a> <a id="19991" class="Symbol">(_</a> <a id="19994" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19996" href="1Lab.Univalence.html#19920" class="Bound">eqv</a><a id="19999" class="Symbol">))</a> <a id="20002" href="1Lab.Univalence.html#19916" class="Bound">pid</a>
</pre>
<p>Equivalence induction simplifies the proofs of many properties about equivalences. For example, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is an equivalence, then so is its <span class="Agda"><a href="1Lab.Path.html#19262" class="Function">action on paths</a></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{ap}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>.</p>
<pre class="Agda"><a id="isEquiv→isEmbedding"></a><a id="20260" href="1Lab.Univalence.html#20260" class="Function">isEquiv→isEmbedding</a> <a id="20280" class="Symbol">:</a> <a id="20282" class="Symbol">∀</a> <a id="20284" class="Symbol">{</a><a id="20285" href="1Lab.Univalence.html#20285" class="Bound">ℓ</a><a id="20286" class="Symbol">}</a> <a id="20288" class="Symbol">{</a><a id="20289" href="1Lab.Univalence.html#20289" class="Bound">A</a> <a id="20291" href="1Lab.Univalence.html#20291" class="Bound">B</a> <a id="20293" class="Symbol">:</a> <a id="20295" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="20300" href="1Lab.Univalence.html#20285" class="Bound">ℓ</a><a id="20301" class="Symbol">}</a>
                    <a id="20323" class="Symbol">→</a> <a id="20325" class="Symbol">(</a><a id="20326" href="1Lab.Univalence.html#20326" class="Bound">f</a> <a id="20328" class="Symbol">:</a> <a id="20330" href="1Lab.Univalence.html#20289" class="Bound">A</a> <a id="20332" class="Symbol">→</a> <a id="20334" href="1Lab.Univalence.html#20291" class="Bound">B</a><a id="20335" class="Symbol">)</a> <a id="20337" class="Symbol">→</a> <a id="20339" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="20347" href="1Lab.Univalence.html#20326" class="Bound">f</a>
                    <a id="20369" class="Symbol">→</a> <a id="20371" class="Symbol">{</a><a id="20372" href="1Lab.Univalence.html#20372" class="Bound">x</a> <a id="20374" href="1Lab.Univalence.html#20374" class="Bound">y</a> <a id="20376" class="Symbol">:</a> <a id="20378" href="1Lab.Univalence.html#20289" class="Bound">A</a><a id="20379" class="Symbol">}</a>
                    <a id="20401" class="Symbol">→</a> <a id="20403" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="20411" class="Symbol">(</a><a id="20412" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="20415" href="1Lab.Univalence.html#20326" class="Bound">f</a> <a id="20417" class="Symbol">{</a><a id="20418" class="Argument">x</a> <a id="20420" class="Symbol">=</a> <a id="20422" href="1Lab.Univalence.html#20372" class="Bound">x</a><a id="20423" class="Symbol">}</a> <a id="20425" class="Symbol">{</a><a id="20426" class="Argument">y</a> <a id="20428" class="Symbol">=</a> <a id="20430" href="1Lab.Univalence.html#20374" class="Bound">y</a><a id="20431" class="Symbol">})</a>
<a id="20434" href="1Lab.Univalence.html#20260" class="Function">isEquiv→isEmbedding</a> <a id="20454" href="1Lab.Univalence.html#20454" class="Bound">f</a> <a id="20456" href="1Lab.Univalence.html#20456" class="Bound">eqv</a> <a id="20460" class="Symbol">=</a>
  <a id="20464" href="1Lab.Univalence.html#19754" class="Function">EquivJ</a> <a id="20471" class="Symbol">(λ</a> <a id="20474" href="1Lab.Univalence.html#20474" class="Bound">B</a> <a id="20476" href="1Lab.Univalence.html#20476" class="Bound">e</a> <a id="20478" class="Symbol">→</a> <a id="20480" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="20488" class="Symbol">(</a><a id="20489" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="20492" class="Symbol">(</a><a id="20493" href="1Lab.Univalence.html#20476" class="Bound">e</a> <a id="20495" class="Symbol">.</a><a id="20496" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="20499" class="Symbol">)))</a> <a id="20503" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a> <a id="20511" class="Symbol">(</a><a id="20512" href="1Lab.Univalence.html#20454" class="Bound">f</a> <a id="20514" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="20516" href="1Lab.Univalence.html#20456" class="Bound">eqv</a><a id="20519" class="Symbol">)</a>
</pre>
<p>The proof can be rendered in English roughly as follows:</p>
<blockquote>
<p>Suppose <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> <span class="Agda"><a href="1Lab.Equiv.html#2293" class="Record">is an equivalence</a></span>. We want to show that, for any choice of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x, y : A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><msub><mo stretchy="false">)</mo><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow></msub><mo>:</mo><mi>x</mi><mo>≡</mo><mi>y</mi><mo>→</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≡</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{ap}(f)_{x,y} : x \equiv y \to f(x) \equiv f(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> is an equivalence.</p>
<p>By <span class="Agda"><a href="1Lab.Univalence.html#19754" class="Function">induction</a></span>, it suffices to cover the case where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is the identity function.</p>
<p>But then, we have that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{ap}(\mathrm{id})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mclose">)</span></span></span></span> is <a href="1Lab.Path.html#ap-id">definitionally equal</a> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{id}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">id</span></span></span></span></span>, which is known to be <span class="Agda"><a href="1Lab.Equiv.html#2526" class="Function">an equivalence</a></span>. <span class="qed"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">■</mi></mrow><annotation encoding="application/x-tex">\blacksquare</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.675em;"></span><span class="mord amsrm">■</span></span></span></span></span></p>
</blockquote>
<h2 id="object-classifiers">Object Classifiers</h2>
<p>In category theory, the idea of <em>classifiers</em> (or <em>classifying objects</em>) often comes up when categories applied to the study of logic. For example, any <a href="https://ncatlab.org/nlab/show/topos#ElementaryTopos">elementary topos</a> has a <em><a href="https://ncatlab.org/nlab/show/subobject+classifier">subobject classifier</a></em>: an object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Ω</span></span></span></span> such that maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">B \to \Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Ω</span></span></span></span> corresponds to maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> with propositional fibres (equivalently, inclusions <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>↪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \hookrightarrow B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6943em;vertical-align:-0.011em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↪</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>). In higher categorical analyses of logic, classifying objects exist for more maps: an elementary <strong>2</strong>-topos has a <a href="https://ncatlab.org/nlab/show/discrete+object+classifier">discrete object classifier</a>, which classify maps with <em>discrete</em> fibres.</p>
<p>Since a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-topos has classifiers for maps with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-truncated fibres, and a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-topos has classifiers for maps with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>-truncated fibres, one might expect that an <a href="https://ncatlab.org/nlab/show/(infinity,1)-topos"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-topos</a> would have classifiers for maps with fibres that are not truncated at all. This is indeed the case! In HoTT, this fact is internalised using the univalent universes, and we can prove that univalent universes are <a href="https://ncatlab.org/nlab/show/object+classifier"><em>object classifiers</em></a>.</p>
<!--
<pre class="Agda"><a id="22521" class="Keyword">private</a> <a id="22529" class="Keyword">variable</a>
  <a id="22540" href="1Lab.Univalence.html#22540" class="Generalizable">A</a> <a id="22542" href="1Lab.Univalence.html#22542" class="Generalizable">B</a> <a id="22544" href="1Lab.Univalence.html#22544" class="Generalizable">E</a> <a id="22546" class="Symbol">:</a> <a id="22548" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="22553" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a>
<a id="22555" class="Keyword">open</a> <a id="22560" href="1Lab.Equiv.html#5975" class="Module">isIso</a>
</pre>-->
<p>As an intermediate step, we prove that the value <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> of a type family <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> at a point <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> is equivalent to the fibre of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi></mrow><mo>:</mo><msub><mi mathvariant="normal">Σ</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></msub><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\mathrm{fst} : \Sigma_{(x : A)}B(x) \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">fst</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mrel mtight">:</span><span class="mord mathnormal mtight">A</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>. The proof follows from the De Morgan structure on the interval, and the “spread” operation <span class="Agda"><a href="1Lab.Path.html#49792" class="Function">coe1→i</a></span>.</p>
<pre class="Agda"><a id="22868" class="Comment">-- HoTT book lemma 4.8.1</a>
<a id="Fibre-equiv"></a><a id="22893" href="1Lab.Univalence.html#22893" class="Function">Fibre-equiv</a> <a id="22905" class="Symbol">:</a> <a id="22907" class="Symbol">(</a><a id="22908" href="1Lab.Univalence.html#22908" class="Bound">B</a> <a id="22910" class="Symbol">:</a> <a id="22912" href="1Lab.Univalence.html#22540" class="Generalizable">A</a> <a id="22914" class="Symbol">→</a> <a id="22916" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="22921" href="1Lab.Univalence.html#2811" class="Generalizable">ℓ&#39;</a><a id="22923" class="Symbol">)</a> <a id="22925" class="Symbol">(</a><a id="22926" href="1Lab.Univalence.html#22926" class="Bound">a</a> <a id="22928" class="Symbol">:</a> <a id="22930" href="1Lab.Univalence.html#22540" class="Generalizable">A</a><a id="22931" class="Symbol">)</a>
            <a id="22945" class="Symbol">→</a> <a id="22947" href="1Lab.Equiv.html#1881" class="Function">fibre</a> <a id="22953" class="Symbol">(</a><a id="22954" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="22958" class="Symbol">{</a><a id="22959" class="Argument">B</a> <a id="22961" class="Symbol">=</a> <a id="22963" href="1Lab.Univalence.html#22908" class="Bound">B</a><a id="22964" class="Symbol">})</a> <a id="22967" href="1Lab.Univalence.html#22926" class="Bound">a</a> <a id="22969" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="22971" href="1Lab.Univalence.html#22908" class="Bound">B</a> <a id="22973" href="1Lab.Univalence.html#22926" class="Bound">a</a>
<a id="22975" href="1Lab.Univalence.html#22893" class="Function">Fibre-equiv</a> <a id="22987" href="1Lab.Univalence.html#22987" class="Bound">B</a> <a id="22989" href="1Lab.Univalence.html#22989" class="Bound">a</a> <a id="22991" class="Symbol">=</a> <a id="22993" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a id="23003" href="1Lab.Univalence.html#23016" class="Function">isom</a> <a id="23008" class="Keyword">where</a>
  <a id="23016" href="1Lab.Univalence.html#23016" class="Function">isom</a> <a id="23021" class="Symbol">:</a> <a id="23023" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="23027" class="Symbol">_</a> <a id="23029" class="Symbol">_</a>
  <a id="23033" href="1Lab.Univalence.html#23016" class="Function">isom</a> <a id="23038" class="Symbol">.</a><a id="23039" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="23043" class="Symbol">((</a><a id="23045" href="1Lab.Univalence.html#23045" class="Bound">x</a> <a id="23047" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23049" href="1Lab.Univalence.html#23049" class="Bound">y</a><a id="23050" class="Symbol">)</a> <a id="23052" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23054" href="1Lab.Univalence.html#23054" class="Bound">p</a><a id="23055" class="Symbol">)</a> <a id="23057" class="Symbol">=</a> <a id="23059" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="23065" href="1Lab.Univalence.html#22987" class="Bound">B</a> <a id="23067" href="1Lab.Univalence.html#23054" class="Bound">p</a> <a id="23069" href="1Lab.Univalence.html#23049" class="Bound">y</a>
  <a id="23073" href="1Lab.Univalence.html#23016" class="Function">isom</a> <a id="23078" class="Symbol">.</a><a id="23079" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23083" class="Symbol">.</a><a id="23084" href="1Lab.Equiv.html#6080" class="Field">inv</a> <a id="23088" href="1Lab.Univalence.html#23088" class="Bound">x</a>        <a id="23097" class="Symbol">=</a> <a id="23099" class="Symbol">(</a><a id="23100" href="1Lab.Univalence.html#22989" class="Bound">a</a> <a id="23102" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23104" href="1Lab.Univalence.html#23088" class="Bound">x</a><a id="23105" class="Symbol">)</a> <a id="23107" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23109" href="1Lab.Path.html#2137" class="Function">refl</a>
  <a id="23116" href="1Lab.Univalence.html#23016" class="Function">isom</a> <a id="23121" class="Symbol">.</a><a id="23122" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23126" class="Symbol">.</a><a id="23127" href="1Lab.Equiv.html#6096" class="Field">rinv</a> <a id="23132" href="1Lab.Univalence.html#23132" class="Bound">x</a> <a id="23134" href="1Lab.Univalence.html#23134" class="Bound">i</a>     <a id="23140" class="Symbol">=</a> <a id="23142" href="1Lab.Path.html#49792" class="Function">coe1→i</a> <a id="23149" class="Symbol">(λ</a> <a id="23152" href="1Lab.Univalence.html#23152" class="Bound">_</a> <a id="23154" class="Symbol">→</a> <a id="23156" href="1Lab.Univalence.html#22987" class="Bound">B</a> <a id="23158" href="1Lab.Univalence.html#22989" class="Bound">a</a><a id="23159" class="Symbol">)</a> <a id="23161" href="1Lab.Univalence.html#23134" class="Bound">i</a> <a id="23163" href="1Lab.Univalence.html#23132" class="Bound">x</a>
  <a id="23167" href="1Lab.Univalence.html#23016" class="Function">isom</a> <a id="23172" class="Symbol">.</a><a id="23173" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23177" class="Symbol">.</a><a id="23178" href="1Lab.Equiv.html#6128" class="Field">linv</a> <a id="23183" class="Symbol">((</a><a id="23185" href="1Lab.Univalence.html#23185" class="Bound">x</a> <a id="23187" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23189" href="1Lab.Univalence.html#23189" class="Bound">y</a><a id="23190" class="Symbol">)</a> <a id="23192" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23194" href="1Lab.Univalence.html#23194" class="Bound">p</a><a id="23195" class="Symbol">)</a> <a id="23197" href="1Lab.Univalence.html#23197" class="Bound">i</a> <a id="23199" class="Symbol">=</a>
    <a id="23205" class="Symbol">(</a><a id="23206" href="1Lab.Univalence.html#23194" class="Bound">p</a> <a id="23208" class="Symbol">(</a><a id="23209" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="23211" href="1Lab.Univalence.html#23197" class="Bound">i</a><a id="23212" class="Symbol">)</a> <a id="23214" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23216" href="1Lab.Path.html#49792" class="Function">coe1→i</a> <a id="23223" class="Symbol">(λ</a> <a id="23226" href="1Lab.Univalence.html#23226" class="Bound">j</a> <a id="23228" class="Symbol">→</a> <a id="23230" href="1Lab.Univalence.html#22987" class="Bound">B</a> <a id="23232" class="Symbol">(</a><a id="23233" href="1Lab.Univalence.html#23194" class="Bound">p</a> <a id="23235" class="Symbol">(</a><a id="23236" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="23238" href="1Lab.Univalence.html#23197" class="Bound">i</a> <a id="23240" href="1Lab.Path.html#730" class="Primitive Operator">∧</a> <a id="23242" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="23244" href="1Lab.Univalence.html#23226" class="Bound">j</a><a id="23245" class="Symbol">)))</a> <a id="23249" href="1Lab.Univalence.html#23197" class="Bound">i</a> <a id="23251" href="1Lab.Univalence.html#23189" class="Bound">y</a><a id="23252" class="Symbol">)</a> <a id="23254" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23256" class="Symbol">λ</a> <a id="23258" href="1Lab.Univalence.html#23258" class="Bound">j</a> <a id="23260" class="Symbol">→</a> <a id="23262" href="1Lab.Univalence.html#23194" class="Bound">p</a> <a id="23264" class="Symbol">(</a><a id="23265" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="23267" href="1Lab.Univalence.html#23197" class="Bound">i</a> <a id="23269" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="23271" href="1Lab.Univalence.html#23258" class="Bound">j</a><a id="23272" class="Symbol">)</a>
</pre>
<p>Another fact from homotopy theory that we can import into homotopy <em>type</em> theory is that any map is equivalent to a fibration. More specifically, given a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mi>E</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">p : E \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, the total space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> is equivalent to the dependent sum of the fibres. The theorems <span class="Agda"><a href="1Lab.Univalence.html#23663" class="Function">Total-equiv</a></span> and <span class="Agda"><a href="1Lab.Univalence.html#22893" class="Function">Fibre-equiv</a></span> are what justify referring to <span class="Agda"><a href="1Lab.Type.html#1563" class="Function">Σ</a></span> the “total space” of a type family.</p>
<pre class="Agda"><a id="Total-equiv"></a><a id="23663" href="1Lab.Univalence.html#23663" class="Function">Total-equiv</a> <a id="23675" class="Symbol">:</a> <a id="23677" class="Symbol">(</a><a id="23678" href="1Lab.Univalence.html#23678" class="Bound">p</a> <a id="23680" class="Symbol">:</a> <a id="23682" href="1Lab.Univalence.html#22544" class="Generalizable">E</a> <a id="23684" class="Symbol">→</a> <a id="23686" href="1Lab.Univalence.html#22542" class="Generalizable">B</a><a id="23687" class="Symbol">)</a> <a id="23689" class="Symbol">→</a> <a id="23691" href="1Lab.Univalence.html#22544" class="Generalizable">E</a> <a id="23693" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="23695" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="23697" class="Symbol">(</a><a id="23698" href="1Lab.Equiv.html#1881" class="Function">fibre</a> <a id="23704" href="1Lab.Univalence.html#23678" class="Bound">p</a><a id="23705" class="Symbol">)</a>
<a id="23707" href="1Lab.Univalence.html#23663" class="Function">Total-equiv</a> <a id="23719" href="1Lab.Univalence.html#23719" class="Bound">p</a> <a id="23721" class="Symbol">=</a> <a id="23723" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a id="23733" href="1Lab.Univalence.html#23746" class="Function">isom</a> <a id="23738" class="Keyword">where</a>
  <a id="23746" href="1Lab.Univalence.html#23746" class="Function">isom</a> <a id="23751" class="Symbol">:</a> <a id="23753" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="23757" class="Symbol">_</a> <a id="23759" class="Symbol">(</a><a id="23760" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="23762" class="Symbol">(</a><a id="23763" href="1Lab.Equiv.html#1881" class="Function">fibre</a> <a id="23769" href="1Lab.Univalence.html#23719" class="Bound">p</a><a id="23770" class="Symbol">))</a>
  <a id="23775" href="1Lab.Univalence.html#23746" class="Function">isom</a> <a id="23780" class="Symbol">.</a><a id="23781" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="23785" href="1Lab.Univalence.html#23785" class="Bound">x</a>                   <a id="23805" class="Symbol">=</a> <a id="23807" href="1Lab.Univalence.html#23719" class="Bound">p</a> <a id="23809" href="1Lab.Univalence.html#23785" class="Bound">x</a> <a id="23811" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23813" href="1Lab.Univalence.html#23785" class="Bound">x</a> <a id="23815" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23817" href="1Lab.Path.html#2137" class="Function">refl</a>
  <a id="23824" href="1Lab.Univalence.html#23746" class="Function">isom</a> <a id="23829" class="Symbol">.</a><a id="23830" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23834" class="Symbol">.</a><a id="23835" href="1Lab.Equiv.html#6080" class="Field">inv</a> <a id="23839" class="Symbol">(_</a> <a id="23842" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23844" href="1Lab.Univalence.html#23844" class="Bound">x</a> <a id="23846" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23848" class="Symbol">_)</a>    <a id="23854" class="Symbol">=</a> <a id="23856" href="1Lab.Univalence.html#23844" class="Bound">x</a>
  <a id="23860" href="1Lab.Univalence.html#23746" class="Function">isom</a> <a id="23865" class="Symbol">.</a><a id="23866" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23870" class="Symbol">.</a><a id="23871" href="1Lab.Equiv.html#6096" class="Field">rinv</a> <a id="23876" class="Symbol">(</a><a id="23877" href="1Lab.Univalence.html#23877" class="Bound">b</a> <a id="23879" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23881" href="1Lab.Univalence.html#23881" class="Bound">x</a> <a id="23883" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23885" href="1Lab.Univalence.html#23885" class="Bound">q</a><a id="23886" class="Symbol">)</a> <a id="23888" href="1Lab.Univalence.html#23888" class="Bound">i</a> <a id="23890" class="Symbol">=</a> <a id="23892" href="1Lab.Univalence.html#23885" class="Bound">q</a> <a id="23894" href="1Lab.Univalence.html#23888" class="Bound">i</a> <a id="23896" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23898" href="1Lab.Univalence.html#23881" class="Bound">x</a> <a id="23900" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23902" class="Symbol">λ</a> <a id="23904" href="1Lab.Univalence.html#23904" class="Bound">j</a> <a id="23906" class="Symbol">→</a> <a id="23908" href="1Lab.Univalence.html#23885" class="Bound">q</a> <a id="23910" class="Symbol">(</a><a id="23911" href="1Lab.Univalence.html#23888" class="Bound">i</a> <a id="23913" href="1Lab.Path.html#730" class="Primitive Operator">∧</a> <a id="23915" href="1Lab.Univalence.html#23904" class="Bound">j</a><a id="23916" class="Symbol">)</a>
  <a id="23920" href="1Lab.Univalence.html#23746" class="Function">isom</a> <a id="23925" class="Symbol">.</a><a id="23926" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23930" class="Symbol">.</a><a id="23931" href="1Lab.Equiv.html#6128" class="Field">linv</a> <a id="23936" href="1Lab.Univalence.html#23936" class="Bound">x</a>             <a id="23950" class="Symbol">=</a> <a id="23952" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>Putting these together, we get the promised theorem: The space of maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi></mrow></mrow><annotation encoding="application/x-tex">B \to \mathrm{Type}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">Type</span></span></span></span></span> is equivalent to the space of fibrations with base space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and variable total space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Σ</mi><mrow><mo stretchy="false">(</mo><mi>E</mi><mo>:</mo><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi></mrow><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>E</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Sigma_{(E : \mathrm{Type})} (E \to B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span><span class="mrel mtight">:</span><span class="mord mtight"><span class="mord mathrm mtight">Type</span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>. If we allow <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> to live in different universes, then the maps are classified by the biggest universe in which they both fit, namely <code>Type (ℓ ⊔ ℓ&#39;)</code>. Note that the proof of <span class="Agda"><a href="1Lab.Univalence.html#24604" class="Function">Fibration-equiv</a></span> makes fundamental use of <span class="Agda"><a href="1Lab.Univalence.html#8768" class="Function">ua</a></span>, to construct the witnesses that taking fibres and taking total spaces are inverses. Without <span class="Agda"><a href="1Lab.Univalence.html#8768" class="Function">ua</a></span>, we could only get an “isomorphism-up-to-equivalence” of types.</p>
<pre class="Agda"><a id="Fibration-equiv"></a><a id="24604" href="1Lab.Univalence.html#24604" class="Function">Fibration-equiv</a> <a id="24620" class="Symbol">:</a> <a id="24622" class="Symbol">∀</a> <a id="24624" class="Symbol">{</a><a id="24625" href="1Lab.Univalence.html#24625" class="Bound">ℓ</a> <a id="24627" href="1Lab.Univalence.html#24627" class="Bound">ℓ&#39;</a><a id="24629" class="Symbol">}</a> <a id="24631" class="Symbol">{</a><a id="24632" href="1Lab.Univalence.html#24632" class="Bound">B</a> <a id="24634" class="Symbol">:</a> <a id="24636" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24641" href="1Lab.Univalence.html#24625" class="Bound">ℓ</a><a id="24642" class="Symbol">}</a>
                <a id="24660" class="Symbol">→</a> <a id="24662" class="Symbol">(</a><a id="24663" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="24666" href="1Lab.Univalence.html#24666" class="Bound">E</a> <a id="24668" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="24670" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24675" class="Symbol">(</a><a id="24676" href="1Lab.Univalence.html#24625" class="Bound">ℓ</a> <a id="24678" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="24680" href="1Lab.Univalence.html#24627" class="Bound">ℓ&#39;</a><a id="24682" class="Symbol">)</a> <a id="24684" href="1Lab.Type.html#1563" class="Function">]</a> <a id="24686" class="Symbol">(</a><a id="24687" href="1Lab.Univalence.html#24666" class="Bound">E</a> <a id="24689" class="Symbol">→</a> <a id="24691" href="1Lab.Univalence.html#24632" class="Bound">B</a><a id="24692" class="Symbol">))</a>
                <a id="24711" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="24713" class="Symbol">(</a><a id="24714" href="1Lab.Univalence.html#24632" class="Bound">B</a> <a id="24716" class="Symbol">→</a> <a id="24718" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24723" class="Symbol">(</a><a id="24724" href="1Lab.Univalence.html#24625" class="Bound">ℓ</a> <a id="24726" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="24728" href="1Lab.Univalence.html#24627" class="Bound">ℓ&#39;</a><a id="24730" class="Symbol">))</a>
<a id="24733" href="1Lab.Univalence.html#24604" class="Function">Fibration-equiv</a> <a id="24749" class="Symbol">{</a><a id="24750" class="Argument">B</a> <a id="24752" class="Symbol">=</a> <a id="24754" href="1Lab.Univalence.html#24754" class="Bound">B</a><a id="24755" class="Symbol">}</a> <a id="24757" class="Symbol">=</a> <a id="24759" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a id="24769" href="1Lab.Univalence.html#24782" class="Function">isom</a> <a id="24774" class="Keyword">where</a>
  <a id="24782" href="1Lab.Univalence.html#24782" class="Function">isom</a> <a id="24787" class="Symbol">:</a> <a id="24789" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="24793" class="Symbol">(</a><a id="24794" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="24797" href="1Lab.Univalence.html#24797" class="Bound">E</a> <a id="24799" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="24801" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24806" class="Symbol">_</a> <a id="24808" href="1Lab.Type.html#1563" class="Function">]</a> <a id="24810" class="Symbol">(</a><a id="24811" href="1Lab.Univalence.html#24797" class="Bound">E</a> <a id="24813" class="Symbol">→</a> <a id="24815" href="1Lab.Univalence.html#24754" class="Bound">B</a><a id="24816" class="Symbol">))</a> <a id="24819" class="Symbol">(</a><a id="24820" href="1Lab.Univalence.html#24754" class="Bound">B</a> <a id="24822" class="Symbol">→</a> <a id="24824" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24829" class="Symbol">_)</a>
  <a id="24834" href="1Lab.Univalence.html#24782" class="Function">isom</a> <a id="24839" class="Symbol">.</a><a id="24840" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="24844" class="Symbol">(</a><a id="24845" href="1Lab.Univalence.html#24845" class="Bound">E</a> <a id="24847" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="24849" href="1Lab.Univalence.html#24849" class="Bound">p</a><a id="24850" class="Symbol">)</a>       <a id="24858" class="Symbol">=</a> <a id="24860" href="1Lab.Equiv.html#1881" class="Function">fibre</a> <a id="24866" href="1Lab.Univalence.html#24849" class="Bound">p</a>
  <a id="24870" href="1Lab.Univalence.html#24782" class="Function">isom</a> <a id="24875" class="Symbol">.</a><a id="24876" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="24880" class="Symbol">.</a><a id="24881" href="1Lab.Equiv.html#6080" class="Field">inv</a> <a id="24885" href="1Lab.Univalence.html#24885" class="Bound">p⁻¹</a>      <a id="24894" class="Symbol">=</a> <a id="24896" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="24898" href="1Lab.Univalence.html#24885" class="Bound">p⁻¹</a> <a id="24902" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="24904" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
  <a id="24910" href="1Lab.Univalence.html#24782" class="Function">isom</a> <a id="24915" class="Symbol">.</a><a id="24916" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="24920" class="Symbol">.</a><a id="24921" href="1Lab.Equiv.html#6096" class="Field">rinv</a> <a id="24926" href="1Lab.Univalence.html#24926" class="Bound">prep</a> <a id="24931" href="1Lab.Univalence.html#24931" class="Bound">i</a> <a id="24933" href="1Lab.Univalence.html#24933" class="Bound">x</a> <a id="24935" class="Symbol">=</a> <a id="24937" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="24940" class="Symbol">(</a><a id="24941" href="1Lab.Univalence.html#22893" class="Function">Fibre-equiv</a> <a id="24953" href="1Lab.Univalence.html#24926" class="Bound">prep</a> <a id="24958" href="1Lab.Univalence.html#24933" class="Bound">x</a><a id="24959" class="Symbol">)</a> <a id="24961" href="1Lab.Univalence.html#24931" class="Bound">i</a>
  <a id="24965" href="1Lab.Univalence.html#24782" class="Function">isom</a> <a id="24970" class="Symbol">.</a><a id="24971" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="24975" class="Symbol">.</a><a id="24976" href="1Lab.Equiv.html#6128" class="Field">linv</a> <a id="24981" class="Symbol">(</a><a id="24982" href="1Lab.Univalence.html#24982" class="Bound">E</a> <a id="24984" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="24986" href="1Lab.Univalence.html#24986" class="Bound">p</a><a id="24987" class="Symbol">)</a> <a id="24989" href="1Lab.Univalence.html#24989" class="Bound">i</a>
    <a id="24995" class="Symbol">=</a> <a id="24997" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="25000" href="1Lab.Univalence.html#25059" class="Function">e</a> <a id="25002" class="Symbol">(</a><a id="25003" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="25005" href="1Lab.Univalence.html#24989" class="Bound">i</a><a id="25006" class="Symbol">)</a> <a id="25008" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="25010" class="Symbol">λ</a> <a id="25012" href="1Lab.Univalence.html#25012" class="Bound">x</a> <a id="25014" class="Symbol">→</a> <a id="25016" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25020" class="Symbol">(</a><a id="25021" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="25026" class="Symbol">(</a><a id="25027" href="1Lab.Univalence.html#12026" class="Function">ua-unglue</a> <a id="25037" href="1Lab.Univalence.html#25059" class="Function">e</a> <a id="25039" class="Symbol">(</a><a id="25040" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="25042" href="1Lab.Univalence.html#24989" class="Bound">i</a><a id="25043" class="Symbol">)</a> <a id="25045" href="1Lab.Univalence.html#25012" class="Bound">x</a><a id="25046" class="Symbol">))</a>
    <a id="25053" class="Keyword">where</a> <a id="25059" href="1Lab.Univalence.html#25059" class="Function">e</a> <a id="25061" class="Symbol">=</a> <a id="25063" href="1Lab.Univalence.html#23663" class="Function">Total-equiv</a> <a id="25075" href="1Lab.Univalence.html#24986" class="Bound">p</a>
</pre>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr></hr>
<ol>
<li id="fn1" role="doc-endnote"><p>Not the fundamental theorem of engineering!<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </article>
</div>

</main>
</body>
</html>