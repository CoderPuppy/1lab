<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>

<head>
  <meta charset="utf-8"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
  <meta name="keywords" content="Agda,categories,topos"></meta>

  <title>1Lab.Univalence - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css"></link>
  <link rel="stylesheet" href="/css/katex.min.css"></link>
  <link rel="stylesheet" href="/css/agda-cats.css"></link>

  <meta name="twitter:card" content="summary"></meta>
  <meta name="twitter:title" content="1Lab.Univalence - 1Lab"></meta>
  <meta name="twitter:image" content="https://cubical.1lab.dev/static/cube-128x.png"></meta>

  <meta name="og:title" content="1Lab.Univalence - 1Lab"></meta>
  <meta name="og:image" content="https://cubical.1lab.dev/static/cube-128x.png"></meta>
  <meta name="og:site-name" content="The 1Lab"></meta>
  <meta name="og:type" content="website"></meta>
    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  
  <script src="/equations.js" type="text/javascript"></script> 
  <script src="/highlight-hover.js" type="text/javascript"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0;">
                <a class="Module">1Lab.Univalence</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto; height: 32px;"></img>
      
      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr></hr>
      <ul class="incremental">
      <li><a href="#univalence">Univalence</a>
      <ul class="incremental">
      <li><a href="#glue">Glue</a></li>
      <li><a href="#paths-from-glue">Paths from Glue</a></li>
      </ul></li>
      <li><a href="#the-axiom">The “axiom”</a>
      <ul class="incremental">
      <li><a href="#consequences">Consequences</a></li>
      <li><a href="#paths-over-ua">Paths over <code>ua</code></a></li>
      </ul></li>
      </ul>
      <hr></hr>

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr></hr>

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/b90a39f2f99bc5839e475eb1dab4d7fc77b4ae57/src/1Lab/Univalence.lagda.md">link to source</a> <br />
      </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="33" class="Keyword">open</a> <a id="38" class="Keyword">import</a> <a id="45" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a>
<a id="56" class="Keyword">open</a> <a id="61" class="Keyword">import</a> <a id="68" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="78" class="Keyword">open</a> <a id="83" class="Keyword">import</a> <a id="90" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="101" class="Keyword">module</a> <a id="108" href="1Lab.Univalence.html" class="Module">1Lab.Univalence</a> <a id="124" class="Keyword">where</a>
</pre>
<h1 id="univalence">Univalence</h1>
<p>In Homotopy Type Theory, <strong>univalence</strong> is the principle stating that <a href="1Lab.Equiv.html#_≃_">equivalent</a> types can be <a href="1Lab.Path.html#Path">identified</a>. When <a href="https://homotopytypetheory.org/book">the book</a> first came out, there was no widely-accepted <em>computational</em> interpretation of this principle, so it was added to the theory as an axiom: the <strong>univalence axiom</strong>.</p>
<p>Precisely, the axiom as presented in the book consists of the following data (right under remark §2.10.4):</p>
<ul class="incremental">
<li><p>A map which turns equivalences into propositional equalities of type. This map is called <span class="Agda"><a href="1Lab.Univalence.html#7883" class="Function">ua</a></span>.</p></li>
<li><p>A rule for eliminating equalities of types, by turning them into equivalences: <span class="Agda"><a href="1Lab.Univalence.html#11007" class="Function">pathToEquiv</a></span></p></li>
<li><p>The propositional computation rule, stating that transport along <code>ua(f)</code> is equal to applying <code>f</code>: <span class="Agda"><a href="1Lab.Univalence.html#9693" class="Function">uaβ</a></span>.</p></li>
</ul>
<p>In the book, there is an extra postulated datum asserting that <span class="Agda"><a href="1Lab.Univalence.html#7883" class="Function">ua</a></span> is an inverse to <span class="Agda"><a href="1Lab.Univalence.html#11007" class="Function">pathToEquiv</a></span>. This datum does not have a name in this development, because it’s proved in-line in the construction of the term <span class="Agda"><a href="1Lab.Univalence.html#11327" class="Function">univalence</a></span>.</p>
<p>The point of cubical type theory is to give these terms constructive interpretations, i.e., make them definable in the theory, in terms of constructions that have computational behaviour. Let’s see how this is done.</p>
<h2 id="glue">Glue</h2>
<p>To even <em>state</em> univalence, we first have to make sure that the concept of “paths between types” makes sense in the first place. In “Book HoTT”, paths between types are a well-formed concept because the path type is uniformly inductively defined for <em>everything</em> — including universes. This is not the case in Cubical type theory, where for paths in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> to be well-behaved, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> must <a href="1Lab.Path.html#fibrant">be <em>fibrant</em></a>.</p>
<p>Since there’s no obvious choice for how to interpret <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> in <span class="Agda"><a href="1Lab.Type.html#394" class="Primitive">Type</a></span>, a fine solution is to make <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> its own type former. This is the approach taken by some Cubical type theories in the <a href="https://redprl.org/">RedPRL school</a>. Univalence in those type theories is then achieved by adding a type former, called <code>V</code>, which turns an equivalence into a path.</p>
<p>In <a href="https://arxiv.org/abs/1611.02108">CCHM</a> — and therefore Cubical Agda — a different approach is taken, which combines proving univalence with defining a fibrancy structure for the universe. The core idea is to define a new type former, <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span>, which “glues” a <a href="1Lab.Path.html#partial-elements">partial type</a>, along an equivalence, to a total type.</p>
<!--
<pre class="Agda"><a id="2786" class="Keyword">private</a>
  <a id="2796" class="Keyword">variable</a>
    <a id="2809" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a> <a id="2811" href="1Lab.Univalence.html#2811" class="Generalizable">ℓ&#39;</a> <a id="2814" class="Symbol">:</a> <a id="2816" href="Agda.Primitive.html#597" class="Postulate">Level</a>

  <a id="2825" class="Keyword">primitive</a>
    <a id="primGlue"></a><a id="2839" href="1Lab.Univalence.html#2839" class="Primitive">primGlue</a> <a id="2848" class="Symbol">:</a> <a id="2850" class="Symbol">(</a><a id="2851" href="1Lab.Univalence.html#2851" class="Bound">A</a> <a id="2853" class="Symbol">:</a> <a id="2855" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2860" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="2861" class="Symbol">)</a> <a id="2863" class="Symbol">{</a><a id="2864" href="1Lab.Univalence.html#2864" class="Bound">φ</a> <a id="2866" class="Symbol">:</a> <a id="2868" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="2869" class="Symbol">}</a>
             <a id="2884" class="Symbol">→</a> <a id="2886" class="Symbol">(</a><a id="2887" href="1Lab.Univalence.html#2887" class="Bound">T</a> <a id="2889" class="Symbol">:</a> <a id="2891" href="Agda.Primitive.Cubical.html#699" class="Primitive">Partial</a> <a id="2899" href="1Lab.Univalence.html#2864" class="Bound">φ</a> <a id="2901" class="Symbol">(</a><a id="2902" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2907" href="1Lab.Univalence.html#2811" class="Generalizable">ℓ&#39;</a><a id="2909" class="Symbol">))</a> <a id="2912" class="Symbol">→</a> <a id="2914" class="Symbol">(</a><a id="2915" href="1Lab.Univalence.html#2915" class="Bound">e</a> <a id="2917" class="Symbol">:</a> <a id="2919" href="Agda.Primitive.Cubical.html#733" class="Primitive">PartialP</a> <a id="2928" href="1Lab.Univalence.html#2864" class="Bound">φ</a> <a id="2930" class="Symbol">(λ</a> <a id="2933" href="1Lab.Univalence.html#2933" class="Bound">o</a> <a id="2935" class="Symbol">→</a> <a id="2937" href="1Lab.Univalence.html#2887" class="Bound">T</a> <a id="2939" href="1Lab.Univalence.html#2933" class="Bound">o</a> <a id="2941" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="2943" href="1Lab.Univalence.html#2851" class="Bound">A</a><a id="2944" class="Symbol">))</a>
             <a id="2960" class="Symbol">→</a> <a id="2962" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2967" href="1Lab.Univalence.html#2811" class="Generalizable">ℓ&#39;</a>

    <a id="prim^glue"></a><a id="2975" href="1Lab.Univalence.html#2975" class="Primitive">prim^glue</a> <a id="2985" class="Symbol">:</a> <a id="2987" class="Symbol">{</a><a id="2988" href="1Lab.Univalence.html#2988" class="Bound">A</a> <a id="2990" class="Symbol">:</a> <a id="2992" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2997" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="2998" class="Symbol">}</a> <a id="3000" class="Symbol">{</a><a id="3001" href="1Lab.Univalence.html#3001" class="Bound">φ</a> <a id="3003" class="Symbol">:</a> <a id="3005" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="3006" class="Symbol">}</a>
              <a id="3022" class="Symbol">→</a> <a id="3024" class="Symbol">{</a><a id="3025" href="1Lab.Univalence.html#3025" class="Bound">T</a> <a id="3027" class="Symbol">:</a> <a id="3029" href="Agda.Primitive.Cubical.html#699" class="Primitive">Partial</a> <a id="3037" href="1Lab.Univalence.html#3001" class="Bound">φ</a> <a id="3039" class="Symbol">(</a><a id="3040" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3045" href="1Lab.Univalence.html#2811" class="Generalizable">ℓ&#39;</a><a id="3047" class="Symbol">)}</a> <a id="3050" class="Symbol">→</a> <a id="3052" class="Symbol">{</a><a id="3053" href="1Lab.Univalence.html#3053" class="Bound">e</a> <a id="3055" class="Symbol">:</a> <a id="3057" href="Agda.Primitive.Cubical.html#733" class="Primitive">PartialP</a> <a id="3066" href="1Lab.Univalence.html#3001" class="Bound">φ</a> <a id="3068" class="Symbol">(λ</a> <a id="3071" href="1Lab.Univalence.html#3071" class="Bound">o</a> <a id="3073" class="Symbol">→</a> <a id="3075" href="1Lab.Univalence.html#3025" class="Bound">T</a> <a id="3077" href="1Lab.Univalence.html#3071" class="Bound">o</a> <a id="3079" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="3081" href="1Lab.Univalence.html#2988" class="Bound">A</a><a id="3082" class="Symbol">)}</a>
              <a id="3099" class="Symbol">→</a> <a id="3101" href="Agda.Primitive.Cubical.html#733" class="Primitive">PartialP</a> <a id="3110" href="1Lab.Univalence.html#3001" class="Bound">φ</a> <a id="3112" href="1Lab.Univalence.html#3025" class="Bound">T</a> <a id="3114" class="Symbol">→</a> <a id="3116" href="1Lab.Univalence.html#2988" class="Bound">A</a> <a id="3118" class="Symbol">→</a> <a id="3120" href="1Lab.Univalence.html#2839" class="Primitive">primGlue</a> <a id="3129" href="1Lab.Univalence.html#2988" class="Bound">A</a> <a id="3131" href="1Lab.Univalence.html#3025" class="Bound">T</a> <a id="3133" href="1Lab.Univalence.html#3053" class="Bound">e</a>

    <a id="prim^unglue"></a><a id="3140" href="1Lab.Univalence.html#3140" class="Primitive">prim^unglue</a> <a id="3152" class="Symbol">:</a> <a id="3154" class="Symbol">{</a><a id="3155" href="1Lab.Univalence.html#3155" class="Bound">A</a> <a id="3157" class="Symbol">:</a> <a id="3159" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3164" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="3165" class="Symbol">}</a> <a id="3167" class="Symbol">{</a><a id="3168" href="1Lab.Univalence.html#3168" class="Bound">φ</a> <a id="3170" class="Symbol">:</a> <a id="3172" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="3173" class="Symbol">}</a>
                <a id="3191" class="Symbol">→</a> <a id="3193" class="Symbol">{</a><a id="3194" href="1Lab.Univalence.html#3194" class="Bound">T</a> <a id="3196" class="Symbol">:</a> <a id="3198" href="Agda.Primitive.Cubical.html#699" class="Primitive">Partial</a> <a id="3206" href="1Lab.Univalence.html#3168" class="Bound">φ</a> <a id="3208" class="Symbol">(</a><a id="3209" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3214" href="1Lab.Univalence.html#2811" class="Generalizable">ℓ&#39;</a><a id="3216" class="Symbol">)}</a> <a id="3219" class="Symbol">→</a> <a id="3221" class="Symbol">{</a><a id="3222" href="1Lab.Univalence.html#3222" class="Bound">e</a> <a id="3224" class="Symbol">:</a> <a id="3226" href="Agda.Primitive.Cubical.html#733" class="Primitive">PartialP</a> <a id="3235" href="1Lab.Univalence.html#3168" class="Bound">φ</a> <a id="3237" class="Symbol">(λ</a> <a id="3240" href="1Lab.Univalence.html#3240" class="Bound">o</a> <a id="3242" class="Symbol">→</a> <a id="3244" href="1Lab.Univalence.html#3194" class="Bound">T</a> <a id="3246" href="1Lab.Univalence.html#3240" class="Bound">o</a> <a id="3248" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="3250" href="1Lab.Univalence.html#3155" class="Bound">A</a><a id="3251" class="Symbol">)}</a>
                <a id="3270" class="Symbol">→</a> <a id="3272" href="1Lab.Univalence.html#2839" class="Primitive">primGlue</a> <a id="3281" href="1Lab.Univalence.html#3155" class="Bound">A</a> <a id="3283" href="1Lab.Univalence.html#3194" class="Bound">T</a> <a id="3285" href="1Lab.Univalence.html#3222" class="Bound">e</a> <a id="3287" class="Symbol">→</a> <a id="3289" href="1Lab.Univalence.html#3155" class="Bound">A</a>

<a id="3292" class="Keyword">open</a> <a id="3297" class="Keyword">import</a> <a id="3304" href="Agda.Builtin.Cubical.HCompU.html" class="Module">Agda.Builtin.Cubical.HCompU</a>
<a id="3332" class="Keyword">open</a> <a id="3337" class="Keyword">import</a> <a id="3344" href="1Lab.Equiv.FromPath.html" class="Module">1Lab.Equiv.FromPath</a>
</pre>-->
<pre class="Agda"><a id="Glue"></a><a id="3381" href="1Lab.Univalence.html#3381" class="Function">Glue</a> <a id="3386" class="Symbol">:</a> <a id="3388" class="Symbol">(</a><a id="3389" href="1Lab.Univalence.html#3389" class="Bound">A</a> <a id="3391" class="Symbol">:</a> <a id="3393" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3398" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="3399" class="Symbol">)</a>
     <a id="3406" class="Symbol">→</a> <a id="3408" class="Symbol">{</a><a id="3409" href="1Lab.Univalence.html#3409" class="Bound">φ</a> <a id="3411" class="Symbol">:</a> <a id="3413" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="3414" class="Symbol">}</a>
     <a id="3421" class="Symbol">→</a> <a id="3423" class="Symbol">(</a><a id="3424" href="1Lab.Univalence.html#3424" class="Bound">Te</a> <a id="3427" class="Symbol">:</a> <a id="3429" href="Agda.Primitive.Cubical.html#699" class="Primitive">Partial</a> <a id="3437" href="1Lab.Univalence.html#3409" class="Bound">φ</a> <a id="3439" class="Symbol">(</a><a id="3440" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="3443" href="1Lab.Univalence.html#3443" class="Bound">T</a> <a id="3445" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="3447" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3452" href="1Lab.Univalence.html#2811" class="Generalizable">ℓ&#39;</a> <a id="3455" href="1Lab.Type.html#1563" class="Function">]</a> <a id="3457" class="Symbol">(</a><a id="3458" href="1Lab.Univalence.html#3443" class="Bound">T</a> <a id="3460" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="3462" href="1Lab.Univalence.html#3389" class="Bound">A</a><a id="3463" class="Symbol">)))</a>
     <a id="3472" class="Symbol">→</a> <a id="3474" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3479" href="1Lab.Univalence.html#2811" class="Generalizable">ℓ&#39;</a>
</pre>
<p>The public interface of <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span> demands a type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, called the <em>base type</em>, a formula <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span></span></span></span>, and a <a href="1Lab.Path.html#partial-elements">partial type</a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> which is equivalent to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>. Since the equivalence is defined <em>inside</em> the partial element, it can also (potentially) vary over the interval, so in reality we have a <em>family</em> of partial types <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> and a <em>family</em> of partial equivalences <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>≃</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">T \simeq A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.</p>
<p>In the specific case where we set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>=</mo><mi mathvariant="normal">¬</mi><mi>i</mi><mo>∨</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">\varphi = \neg i \lor i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord">¬</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>, we can illustrate <code>Glue A (T, f)</code> as the dashed line in the square diagram below. The conceptual idea is that by “gluing” <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> onto a totally defined type, we get a type which <a href="1Lab.Path.html#extensibility">extends</a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>.</p>
<div class="diagram-container"> <img title="commutative diagram" src="b6e2356c639f71ad0995a59d7ff4b24e.svg" class="diagram  quiver"></img> </div>
<!--
<pre class="Agda"><a id="4439" href="1Lab.Univalence.html#3381" class="Function">Glue</a> <a id="4444" href="1Lab.Univalence.html#4444" class="Bound">A</a> <a id="4446" href="1Lab.Univalence.html#4446" class="Bound">Te</a> <a id="4449" class="Symbol">=</a> <a id="4451" href="1Lab.Univalence.html#2839" class="Primitive">primGlue</a> <a id="4460" href="1Lab.Univalence.html#4444" class="Bound">A</a> <a id="4462" class="Symbol">(λ</a> <a id="4465" href="1Lab.Univalence.html#4465" class="Bound">x</a> <a id="4467" class="Symbol">→</a> <a id="4469" href="1Lab.Univalence.html#4446" class="Bound">Te</a> <a id="4472" href="1Lab.Univalence.html#4465" class="Bound">x</a> <a id="4474" class="Symbol">.</a><a id="4475" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="4478" class="Symbol">)</a> <a id="4480" class="Symbol">(λ</a> <a id="4483" href="1Lab.Univalence.html#4483" class="Bound">x</a> <a id="4485" class="Symbol">→</a> <a id="4487" href="1Lab.Univalence.html#4446" class="Bound">Te</a> <a id="4490" href="1Lab.Univalence.html#4483" class="Bound">x</a> <a id="4492" class="Symbol">.</a><a id="4493" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="4496" class="Symbol">)</a>

<a id="unglue"></a><a id="4499" href="1Lab.Univalence.html#4499" class="Function">unglue</a> <a id="4506" class="Symbol">:</a> <a id="4508" class="Symbol">{</a><a id="4509" href="1Lab.Univalence.html#4509" class="Bound">A</a> <a id="4511" class="Symbol">:</a> <a id="4513" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4518" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="4519" class="Symbol">}</a> <a id="4521" class="Symbol">(</a><a id="4522" href="1Lab.Univalence.html#4522" class="Bound">φ</a> <a id="4524" class="Symbol">:</a> <a id="4526" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="4527" class="Symbol">)</a> <a id="4529" class="Symbol">{</a><a id="4530" href="1Lab.Univalence.html#4530" class="Bound">T</a> <a id="4532" class="Symbol">:</a> <a id="4534" href="Agda.Primitive.Cubical.html#699" class="Primitive">Partial</a> <a id="4542" href="1Lab.Univalence.html#4522" class="Bound">φ</a> <a id="4544" class="Symbol">(</a><a id="4545" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4550" href="1Lab.Univalence.html#2811" class="Generalizable">ℓ&#39;</a><a id="4552" class="Symbol">)}</a>
         <a id="4564" class="Symbol">{</a><a id="4565" href="1Lab.Univalence.html#4565" class="Bound">e</a> <a id="4567" class="Symbol">:</a> <a id="4569" href="Agda.Primitive.Cubical.html#733" class="Primitive">PartialP</a> <a id="4578" href="1Lab.Univalence.html#4522" class="Bound">φ</a> <a id="4580" class="Symbol">(λ</a> <a id="4583" href="1Lab.Univalence.html#4583" class="Bound">o</a> <a id="4585" class="Symbol">→</a> <a id="4587" href="1Lab.Univalence.html#4530" class="Bound">T</a> <a id="4589" href="1Lab.Univalence.html#4583" class="Bound">o</a> <a id="4591" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="4593" href="1Lab.Univalence.html#4509" class="Bound">A</a><a id="4594" class="Symbol">)}</a> <a id="4597" class="Symbol">→</a> <a id="4599" href="1Lab.Univalence.html#2839" class="Primitive">primGlue</a> <a id="4608" href="1Lab.Univalence.html#4509" class="Bound">A</a> <a id="4610" href="1Lab.Univalence.html#4530" class="Bound">T</a> <a id="4612" href="1Lab.Univalence.html#4565" class="Bound">e</a> <a id="4614" class="Symbol">→</a> <a id="4616" href="1Lab.Univalence.html#4509" class="Bound">A</a>
<a id="4618" href="1Lab.Univalence.html#4499" class="Function">unglue</a> <a id="4625" href="1Lab.Univalence.html#4625" class="Bound">φ</a> <a id="4627" class="Symbol">=</a> <a id="4629" href="1Lab.Univalence.html#3140" class="Primitive">prim^unglue</a> <a id="4641" class="Symbol">{</a><a id="4642" class="Argument">φ</a> <a id="4644" class="Symbol">=</a> <a id="4646" href="1Lab.Univalence.html#4625" class="Bound">φ</a><a id="4647" class="Symbol">}</a>
</pre>-->
<p>For <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span> to extend <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>, we add a computation rule which could be called a <strong>boundary condition</strong>, since it specifies how <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span> behaves on the boundaries of cubes. Concisely, when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>=</mo><mi>i</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">\varphi = i1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mord">1</span></span></span></span>, we have that <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span> evaluates to the partial type. This is exactly what it means for <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span> to extend <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>!</p>
<pre class="Agda"><a id="5060" class="Keyword">module</a> <a id="5067" href="1Lab.Univalence.html#5067" class="Module">_</a> <a id="5069" class="Symbol">{</a><a id="5070" href="1Lab.Univalence.html#5070" class="Bound">A</a> <a id="5072" href="1Lab.Univalence.html#5072" class="Bound">B</a> <a id="5074" class="Symbol">:</a> <a id="5076" href="1Lab.Type.html#394" class="Primitive">Type</a><a id="5080" class="Symbol">}</a> <a id="5082" class="Symbol">{</a><a id="5083" href="1Lab.Univalence.html#5083" class="Bound">e</a> <a id="5085" class="Symbol">:</a> <a id="5087" href="1Lab.Univalence.html#5070" class="Bound">A</a> <a id="5089" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="5091" href="1Lab.Univalence.html#5072" class="Bound">B</a><a id="5092" class="Symbol">}</a> <a id="5094" class="Keyword">where</a>
  <a id="5102" class="Keyword">private</a>
    <a id="5114" href="1Lab.Univalence.html#5114" class="Function">Glue-boundary</a> <a id="5128" class="Symbol">:</a> <a id="5130" href="1Lab.Univalence.html#3381" class="Function">Glue</a> <a id="5135" href="1Lab.Univalence.html#5072" class="Bound">B</a> <a id="5137" class="Symbol">{</a><a id="5138" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="5140" class="Symbol">}</a> <a id="5142" class="Symbol">(λ</a> <a id="5145" href="1Lab.Univalence.html#5145" class="Bound">x</a> <a id="5147" class="Symbol">→</a> <a id="5149" href="1Lab.Univalence.html#5070" class="Bound">A</a> <a id="5151" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5153" href="1Lab.Univalence.html#5083" class="Bound">e</a><a id="5154" class="Symbol">)</a> <a id="5156" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5158" href="1Lab.Univalence.html#5070" class="Bound">A</a>
    <a id="5164" href="1Lab.Univalence.html#5114" class="Function">Glue-boundary</a> <a id="5178" href="1Lab.Univalence.html#5178" class="Bound">i</a> <a id="5180" class="Symbol">=</a> <a id="5182" href="1Lab.Univalence.html#5070" class="Bound">A</a>
</pre>
<p>Furthermore, since we can turn any path into an equivalence, we can use the <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span> construct to implement something with precisely the same interface as <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> for <span class="Agda"><a href="1Lab.Type.html#394" class="Primitive">Type</a></span>:</p>
<pre class="Agda"><a id="glue-hfill"></a><a id="5392" href="1Lab.Univalence.html#5392" class="Function">glue-hfill</a>
  <a id="5405" class="Symbol">:</a> <a id="5407" class="Symbol">∀</a> <a id="5409" class="Symbol">{</a><a id="5410" href="1Lab.Univalence.html#5410" class="Bound">ℓ</a><a id="5411" class="Symbol">}</a> <a id="5413" href="1Lab.Univalence.html#5413" class="Bound">φ</a> <a id="5415" class="Symbol">(</a><a id="5416" href="1Lab.Univalence.html#5416" class="Bound">u</a> <a id="5418" class="Symbol">:</a> <a id="5420" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="5422" class="Symbol">→</a> <a id="5424" href="Agda.Primitive.Cubical.html#699" class="Primitive">Partial</a> <a id="5432" href="1Lab.Univalence.html#5413" class="Bound">φ</a> <a id="5434" class="Symbol">(</a><a id="5435" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="5440" href="1Lab.Univalence.html#5410" class="Bound">ℓ</a><a id="5441" class="Symbol">))</a> <a id="5444" class="Symbol">(</a><a id="5445" href="1Lab.Univalence.html#5445" class="Bound">u0</a> <a id="5448" class="Symbol">:</a> <a id="5450" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="5455" href="1Lab.Univalence.html#5410" class="Bound">ℓ</a> <a id="5457" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="5459" href="1Lab.Univalence.html#5413" class="Bound">φ</a> <a id="5461" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="5463" href="1Lab.Univalence.html#5416" class="Bound">u</a> <a id="5465" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="5468" href="1Lab.Path.html#27116" class="Function Operator">]</a><a id="5469" class="Symbol">)</a>
  <a id="5473" class="Symbol">→</a> <a id="5475" class="Symbol">∀</a> <a id="5477" href="1Lab.Univalence.html#5477" class="Bound">i</a> <a id="5479" class="Symbol">→</a> <a id="5481" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="5486" href="1Lab.Univalence.html#5410" class="Bound">ℓ</a> <a id="5488" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="5490" class="Symbol">_</a> <a id="5492" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="5494" class="Symbol">(λ</a> <a id="5497" class="Symbol">{</a> <a id="5499" class="Symbol">(</a><a id="5500" href="1Lab.Univalence.html#5477" class="Bound">i</a> <a id="5502" class="Symbol">=</a> <a id="5504" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="5506" class="Symbol">)</a> <a id="5508" class="Symbol">→</a> <a id="5510" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="5515" href="1Lab.Univalence.html#5445" class="Bound">u0</a>
                          <a id="5544" class="Symbol">;</a> <a id="5546" class="Symbol">(</a><a id="5547" href="1Lab.Univalence.html#5413" class="Bound">φ</a> <a id="5549" class="Symbol">=</a> <a id="5551" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="5553" class="Symbol">)</a> <a id="5555" class="Symbol">→</a> <a id="5557" href="1Lab.Univalence.html#5416" class="Bound">u</a> <a id="5559" href="1Lab.Univalence.html#5477" class="Bound">i</a> <a id="5561" href="1Lab.Path.html#982" class="Postulate">1=1</a> <a id="5565" class="Symbol">})</a> <a id="5568" href="1Lab.Path.html#27116" class="Function Operator">]</a>
</pre>
<p>The type of <span class="Agda"><a href="1Lab.Univalence.html#5392" class="Function">glue-hfill</a></span> is the same as that of <code class="sourceCode agda">hfill</code>, but the type is stated much more verbosely — so that we may define it without previous reference to a <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> analogue. It, like <code class="sourceCode agda">hfill</code>, an element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">u_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> which extends <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mtext> </mtext><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">u\ \mathrm{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord mathnormal">u</span><span class="mspace"> </span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>, and produces a cube with dimension one higher which - when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">i = \mathrm{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span> - agrees with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">u_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, and when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">i = \mathrm{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span> extends <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mtext> </mtext><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">u\
\mathrm{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord mathnormal">u</span><span class="mspace"> </span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span>.</p>
<pre class="Agda"><a id="6009" href="1Lab.Univalence.html#5392" class="Function">glue-hfill</a> <a id="6020" href="1Lab.Univalence.html#6020" class="Bound">φ</a> <a id="6022" href="1Lab.Univalence.html#6022" class="Bound">u</a> <a id="6024" href="1Lab.Univalence.html#6024" class="Bound">u0</a> <a id="6027" href="1Lab.Univalence.html#6027" class="Bound">i</a> <a id="6029" class="Symbol">=</a> <a id="6031" href="1Lab.Path.html#608" class="Postulate">inS</a> <a id="6035" class="Symbol">(</a>
  <a id="6039" href="1Lab.Univalence.html#3381" class="Function">Glue</a> <a id="6044" class="Symbol">(</a><a id="6045" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="6050" href="1Lab.Univalence.html#6024" class="Bound">u0</a><a id="6052" class="Symbol">)</a> <a id="6054" class="Symbol">{</a><a id="6055" class="Argument">φ</a> <a id="6057" class="Symbol">=</a> <a id="6059" href="1Lab.Univalence.html#6020" class="Bound">φ</a> <a id="6061" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="6063" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="6065" href="1Lab.Univalence.html#6027" class="Bound">i</a><a id="6066" class="Symbol">}</a>
    <a id="6072" class="Symbol">λ</a> <a id="6074" class="Symbol">{</a> <a id="6076" class="Symbol">(</a><a id="6077" href="1Lab.Univalence.html#6020" class="Bound">φ</a> <a id="6079" class="Symbol">=</a> <a id="6081" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="6083" class="Symbol">)</a> <a id="6085" class="Symbol">→</a> <a id="6087" href="1Lab.Univalence.html#6022" class="Bound">u</a> <a id="6089" href="1Lab.Univalence.html#6027" class="Bound">i</a> <a id="6091" href="1Lab.Path.html#982" class="Postulate">1=1</a> <a id="6095" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6097" href="1Lab.Equiv.FromPath.html#9222" class="Function">line→equiv</a> <a id="6108" class="Symbol">(λ</a> <a id="6111" href="1Lab.Univalence.html#6111" class="Bound">j</a> <a id="6113" class="Symbol">→</a> <a id="6115" href="1Lab.Univalence.html#6022" class="Bound">u</a> <a id="6117" class="Symbol">(</a><a id="6118" href="1Lab.Univalence.html#6027" class="Bound">i</a> <a id="6120" href="1Lab.Path.html#730" class="Primitive Operator">∧</a> <a id="6122" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="6124" href="1Lab.Univalence.html#6111" class="Bound">j</a><a id="6125" class="Symbol">)</a> <a id="6127" href="1Lab.Path.html#982" class="Postulate">1=1</a><a id="6130" class="Symbol">)</a>
      <a id="6138" class="Symbol">;</a> <a id="6140" class="Symbol">(</a><a id="6141" href="1Lab.Univalence.html#6027" class="Bound">i</a> <a id="6143" class="Symbol">=</a> <a id="6145" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="6147" class="Symbol">)</a> <a id="6149" class="Symbol">→</a> <a id="6151" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="6156" href="1Lab.Univalence.html#6024" class="Bound">u0</a> <a id="6159" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6161" href="1Lab.Equiv.FromPath.html#9222" class="Function">line→equiv</a> <a id="6172" class="Symbol">(λ</a> <a id="6175" href="1Lab.Univalence.html#6175" class="Bound">i</a> <a id="6177" class="Symbol">→</a> <a id="6179" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="6184" href="1Lab.Univalence.html#6024" class="Bound">u0</a><a id="6186" class="Symbol">)</a>
      <a id="6194" class="Symbol">})</a>
</pre>
<p>When <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">i = \mathrm{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>, we glue <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">u0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal">u</span><span class="mord">0</span></span></span></span> onto itself using the identity equivalence. This guarantees that the boundary of the stated type for <span class="Agda"><a href="1Lab.Univalence.html#5392" class="Function">glue-hfill</a></span> is satisfied.</p>
<p>When <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>=</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\varphi = \mathrm{\phi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span>, hence where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> is defined, we glue the endpoint <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> onto <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">u0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal">u</span><span class="mord">0</span></span></span></span> using the equivalence generated by the path provided by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> itself! It’s a family of partial paths, after all, and that can be turned into a family of partial equivalences.</p>
<p>We can prove a theorem which says that anything which satisfies the interface of <code class="sourceCode agda">hfill</code> must agree with <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> on <span class="Agda"><a href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a></span>, hence we can conclude that <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> on <span class="Agda"><a href="1Lab.Type.html#394" class="Primitive">Type</a></span> agrees with the definition of <span class="Agda"><a href="1Lab.Univalence.html#5392" class="Function">glue-hfill</a></span>.</p>
<pre class="Agda"><a id="hcomp-unique"></a><a id="6906" href="1Lab.Univalence.html#6906" class="Function">hcomp-unique</a> <a id="6919" class="Symbol">:</a> <a id="6921" class="Symbol">∀</a> <a id="6923" class="Symbol">{</a><a id="6924" href="1Lab.Univalence.html#6924" class="Bound">ℓ</a><a id="6925" class="Symbol">}</a> <a id="6927" class="Symbol">{</a><a id="6928" href="1Lab.Univalence.html#6928" class="Bound">A</a> <a id="6930" class="Symbol">:</a> <a id="6932" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="6937" href="1Lab.Univalence.html#6924" class="Bound">ℓ</a><a id="6938" class="Symbol">}</a> <a id="6940" class="Symbol">{</a><a id="6941" href="1Lab.Univalence.html#6941" class="Bound">φ</a><a id="6942" class="Symbol">}</a>
               <a id="6959" class="Symbol">(</a><a id="6960" href="1Lab.Univalence.html#6960" class="Bound">u</a> <a id="6962" class="Symbol">:</a> <a id="6964" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="6966" class="Symbol">→</a> <a id="6968" href="Agda.Primitive.Cubical.html#699" class="Primitive">Partial</a> <a id="6976" href="1Lab.Univalence.html#6941" class="Bound">φ</a> <a id="6978" href="1Lab.Univalence.html#6928" class="Bound">A</a><a id="6979" class="Symbol">)</a>
               <a id="6996" class="Symbol">(</a><a id="6997" href="1Lab.Univalence.html#6997" class="Bound">u0</a> <a id="7000" class="Symbol">:</a> <a id="7002" href="1Lab.Univalence.html#6928" class="Bound">A</a> <a id="7004" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="7006" href="1Lab.Univalence.html#6941" class="Bound">φ</a> <a id="7008" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="7010" href="1Lab.Univalence.html#6960" class="Bound">u</a> <a id="7012" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="7015" href="1Lab.Path.html#27116" class="Function Operator">]</a><a id="7016" class="Symbol">)</a>
             <a id="7031" class="Symbol">→</a> <a id="7033" class="Symbol">(</a><a id="7034" href="1Lab.Univalence.html#7034" class="Bound">h2</a> <a id="7037" class="Symbol">:</a> <a id="7039" class="Symbol">∀</a> <a id="7041" href="1Lab.Univalence.html#7041" class="Bound">i</a> <a id="7043" class="Symbol">→</a> <a id="7045" href="1Lab.Univalence.html#6928" class="Bound">A</a> <a id="7047" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="7049" class="Symbol">_</a> <a id="7051" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="7053" class="Symbol">(λ</a> <a id="7056" class="Symbol">{</a> <a id="7058" class="Symbol">(</a><a id="7059" href="1Lab.Univalence.html#7041" class="Bound">i</a> <a id="7061" class="Symbol">=</a> <a id="7063" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="7065" class="Symbol">)</a> <a id="7067" class="Symbol">→</a> <a id="7069" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="7074" href="1Lab.Univalence.html#6997" class="Bound">u0</a>
                                      <a id="7115" class="Symbol">;</a> <a id="7117" class="Symbol">(</a><a id="7118" href="1Lab.Univalence.html#6941" class="Bound">φ</a> <a id="7120" class="Symbol">=</a> <a id="7122" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="7124" class="Symbol">)</a> <a id="7126" class="Symbol">→</a> <a id="7128" href="1Lab.Univalence.html#6960" class="Bound">u</a> <a id="7130" href="1Lab.Univalence.html#7041" class="Bound">i</a> <a id="7132" href="1Lab.Path.html#982" class="Postulate">1=1</a> <a id="7136" class="Symbol">})</a> <a id="7139" href="1Lab.Path.html#27116" class="Function Operator">]</a><a id="7140" class="Symbol">)</a>
             <a id="7155" class="Symbol">→</a> <a id="7157" href="1Lab.Path.html#907" class="Primitive">hcomp</a> <a id="7163" href="1Lab.Univalence.html#6960" class="Bound">u</a> <a id="7165" class="Symbol">(</a><a id="7166" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="7171" href="1Lab.Univalence.html#6997" class="Bound">u0</a><a id="7173" class="Symbol">)</a> <a id="7175" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7177" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="7182" class="Symbol">(</a><a id="7183" href="1Lab.Univalence.html#7034" class="Bound">h2</a> <a id="7186" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="7188" class="Symbol">)</a>
<a id="7190" href="1Lab.Univalence.html#6906" class="Function">hcomp-unique</a> <a id="7203" class="Symbol">{</a><a id="7204" class="Argument">φ</a> <a id="7206" class="Symbol">=</a> <a id="7208" href="1Lab.Univalence.html#7208" class="Bound">φ</a><a id="7209" class="Symbol">}</a> <a id="7211" href="1Lab.Univalence.html#7211" class="Bound">u</a> <a id="7213" href="1Lab.Univalence.html#7213" class="Bound">u0</a> <a id="7216" href="1Lab.Univalence.html#7216" class="Bound">h2</a> <a id="7219" href="1Lab.Univalence.html#7219" class="Bound">i</a> <a id="7221" class="Symbol">=</a>
  <a id="7225" href="1Lab.Path.html#907" class="Primitive">hcomp</a> <a id="7231" class="Symbol">(λ</a> <a id="7234" href="1Lab.Univalence.html#7234" class="Bound">k</a> <a id="7236" class="Symbol">→</a> <a id="7238" class="Symbol">λ</a> <a id="7240" class="Symbol">{</a> <a id="7242" class="Symbol">(</a><a id="7243" href="1Lab.Univalence.html#7208" class="Bound">φ</a> <a id="7245" class="Symbol">=</a> <a id="7247" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="7249" class="Symbol">)</a> <a id="7251" class="Symbol">→</a> <a id="7253" href="1Lab.Univalence.html#7211" class="Bound">u</a> <a id="7255" href="1Lab.Univalence.html#7234" class="Bound">k</a> <a id="7257" href="1Lab.Path.html#982" class="Postulate">1=1</a>
                 <a id="7278" class="Symbol">;</a> <a id="7280" class="Symbol">(</a><a id="7281" href="1Lab.Univalence.html#7219" class="Bound">i</a> <a id="7283" class="Symbol">=</a> <a id="7285" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="7287" class="Symbol">)</a> <a id="7289" class="Symbol">→</a> <a id="7291" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="7296" class="Symbol">(</a><a id="7297" href="1Lab.Univalence.html#7216" class="Bound">h2</a> <a id="7300" href="1Lab.Univalence.html#7234" class="Bound">k</a><a id="7301" class="Symbol">)</a> <a id="7303" class="Symbol">})</a>
        <a id="7314" class="Symbol">(</a><a id="7315" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="7320" href="1Lab.Univalence.html#7213" class="Bound">u0</a><a id="7322" class="Symbol">)</a>
</pre>
<p>Putting <span class="Agda"><a href="1Lab.Univalence.html#6906" class="Function">hcomp-unique</a></span> and <span class="Agda"><a href="1Lab.Univalence.html#5392" class="Function">glue-hfill</a></span>, we get an internal characterisation of the fibrancy structure of the universe.</p>
<pre class="Agda"><a id="hcomp≡Glue"></a><a id="7472" href="1Lab.Univalence.html#7472" class="Function">hcomp≡Glue</a> <a id="7483" class="Symbol">:</a> <a id="7485" class="Symbol">∀</a> <a id="7487" class="Symbol">{</a><a id="7488" href="1Lab.Univalence.html#7488" class="Bound">ℓ</a><a id="7489" class="Symbol">}</a> <a id="7491" class="Symbol">{</a><a id="7492" href="1Lab.Univalence.html#7492" class="Bound">φ</a><a id="7493" class="Symbol">}</a> <a id="7495" class="Symbol">(</a><a id="7496" href="1Lab.Univalence.html#7496" class="Bound">u</a> <a id="7498" class="Symbol">:</a> <a id="7500" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="7502" class="Symbol">→</a> <a id="7504" href="Agda.Primitive.Cubical.html#699" class="Primitive">Partial</a> <a id="7512" href="1Lab.Univalence.html#7492" class="Bound">φ</a> <a id="7514" class="Symbol">(</a><a id="7515" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="7520" href="1Lab.Univalence.html#7488" class="Bound">ℓ</a><a id="7521" class="Symbol">))</a> <a id="7524" class="Symbol">(</a><a id="7525" href="1Lab.Univalence.html#7525" class="Bound">u0</a> <a id="7528" class="Symbol">:</a> <a id="7530" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="7535" href="1Lab.Univalence.html#7488" class="Bound">ℓ</a> <a id="7537" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="7539" href="1Lab.Univalence.html#7492" class="Bound">φ</a> <a id="7541" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="7543" href="1Lab.Univalence.html#7496" class="Bound">u</a> <a id="7545" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="7548" href="1Lab.Path.html#27116" class="Function Operator">]</a><a id="7549" class="Symbol">)</a>
           <a id="7562" class="Symbol">→</a> <a id="7564" href="1Lab.Path.html#907" class="Primitive">hcomp</a> <a id="7570" href="1Lab.Univalence.html#7496" class="Bound">u</a> <a id="7572" class="Symbol">(</a><a id="7573" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="7578" href="1Lab.Univalence.html#7525" class="Bound">u0</a><a id="7580" class="Symbol">)</a>
           <a id="7593" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7595" href="1Lab.Univalence.html#3381" class="Function">Glue</a> <a id="7600" class="Symbol">(</a><a id="7601" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="7606" href="1Lab.Univalence.html#7525" class="Bound">u0</a><a id="7608" class="Symbol">)</a>
              <a id="7624" class="Symbol">(λ</a> <a id="7627" class="Symbol">{</a> <a id="7629" class="Symbol">(</a><a id="7630" href="1Lab.Univalence.html#7492" class="Bound">φ</a> <a id="7632" class="Symbol">=</a> <a id="7634" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="7636" class="Symbol">)</a> <a id="7638" class="Symbol">→</a> <a id="7640" href="1Lab.Univalence.html#7496" class="Bound">u</a> <a id="7642" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="7645" href="1Lab.Path.html#982" class="Postulate">1=1</a> <a id="7649" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7651" href="1Lab.Equiv.FromPath.html#9222" class="Function">line→equiv</a> <a id="7662" class="Symbol">(λ</a> <a id="7665" href="1Lab.Univalence.html#7665" class="Bound">j</a> <a id="7667" class="Symbol">→</a> <a id="7669" href="1Lab.Univalence.html#7496" class="Bound">u</a> <a id="7671" class="Symbol">(</a><a id="7672" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="7674" href="1Lab.Univalence.html#7665" class="Bound">j</a><a id="7675" class="Symbol">)</a> <a id="7677" href="1Lab.Path.html#982" class="Postulate">1=1</a><a id="7680" class="Symbol">)</a> <a id="7682" class="Symbol">})</a>
<a id="7685" href="1Lab.Univalence.html#7472" class="Function">hcomp≡Glue</a> <a id="7696" href="1Lab.Univalence.html#7696" class="Bound">u</a> <a id="7698" href="1Lab.Univalence.html#7698" class="Bound">u0</a> <a id="7701" class="Symbol">=</a> <a id="7703" href="1Lab.Univalence.html#6906" class="Function">hcomp-unique</a> <a id="7716" href="1Lab.Univalence.html#7696" class="Bound">u</a> <a id="7718" href="1Lab.Univalence.html#7698" class="Bound">u0</a> <a id="7721" class="Symbol">(</a><a id="7722" href="1Lab.Univalence.html#5392" class="Function">glue-hfill</a> <a id="7733" class="Symbol">_</a> <a id="7735" href="1Lab.Univalence.html#7696" class="Bound">u</a> <a id="7737" href="1Lab.Univalence.html#7698" class="Bound">u0</a><a id="7739" class="Symbol">)</a>
</pre>
<h2 id="paths-from-glue">Paths from Glue</h2>
<p>As a special case of the <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span> construction, we can use <code>Glue</code> to turn any equivalence into a path:</p>
<pre class="Agda"><a id="ua"></a><a id="7883" href="1Lab.Univalence.html#7883" class="Function">ua</a> <a id="7886" class="Symbol">:</a> <a id="7888" class="Symbol">{</a><a id="7889" href="1Lab.Univalence.html#7889" class="Bound">A</a> <a id="7891" href="1Lab.Univalence.html#7891" class="Bound">B</a> <a id="7893" class="Symbol">:</a> <a id="7895" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="7900" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="7901" class="Symbol">}</a> <a id="7903" class="Symbol">→</a> <a id="7905" href="1Lab.Univalence.html#7889" class="Bound">A</a> <a id="7907" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="7909" href="1Lab.Univalence.html#7891" class="Bound">B</a> <a id="7911" class="Symbol">→</a> <a id="7913" href="1Lab.Univalence.html#7889" class="Bound">A</a> <a id="7915" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7917" href="1Lab.Univalence.html#7891" class="Bound">B</a>
<a id="7919" href="1Lab.Univalence.html#7883" class="Function">ua</a> <a id="7922" class="Symbol">{</a><a id="7923" class="Argument">A</a> <a id="7925" class="Symbol">=</a> <a id="7927" href="1Lab.Univalence.html#7927" class="Bound">A</a><a id="7928" class="Symbol">}</a> <a id="7930" class="Symbol">{</a><a id="7931" href="1Lab.Univalence.html#7931" class="Bound">B</a><a id="7932" class="Symbol">}</a> <a id="7934" href="1Lab.Univalence.html#7934" class="Bound">eqv</a> <a id="7938" href="1Lab.Univalence.html#7938" class="Bound">i</a> <a id="7940" class="Symbol">=</a> <a id="7942" href="1Lab.Univalence.html#3381" class="Function">Glue</a> <a id="7947" href="1Lab.Univalence.html#7931" class="Bound">B</a> <a id="7949" class="Symbol">λ</a> <a id="7951" class="Symbol">{</a> <a id="7953" class="Symbol">(</a><a id="7954" href="1Lab.Univalence.html#7938" class="Bound">i</a> <a id="7956" class="Symbol">=</a> <a id="7958" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="7960" class="Symbol">)</a> <a id="7962" class="Symbol">→</a> <a id="7964" href="1Lab.Univalence.html#7927" class="Bound">A</a> <a id="7966" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7968" href="1Lab.Univalence.html#7934" class="Bound">eqv</a>
                                <a id="8004" class="Symbol">;</a> <a id="8006" class="Symbol">(</a><a id="8007" href="1Lab.Univalence.html#7938" class="Bound">i</a> <a id="8009" class="Symbol">=</a> <a id="8011" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="8013" class="Symbol">)</a> <a id="8015" class="Symbol">→</a> <a id="8017" href="1Lab.Univalence.html#7931" class="Bound">B</a> <a id="8019" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8021" class="Symbol">_</a> <a id="8023" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8025" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>
                                <a id="8065" class="Symbol">}</a>
</pre>
<p>Why does this definition go through? Because of the boundary condition for Glue! When <code>i = i0</code>, the whole thing evaluates to <code>A</code>, meaning that the left endpoint of the path is correct. The same thing happens with the right endpoint.</p>
<p>The action of <a href="1Lab.Path.html">transporting</a> along <code>ua(f)</code> can be described exactly by chasing an element around the diagram that illustrates Glue in the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>=</mo><mi>i</mi><mo>∨</mo><mi mathvariant="normal">¬</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">\varphi = i \lor \neg i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord">¬</span><span class="mord mathnormal">i</span></span></span></span> case, specialising to <span class="Agda"><a href="1Lab.Univalence.html#7883" class="Function">ua</a></span>, remembering that we can invert equivalences to make this possible.</p>
<figure>
<div class="diagram-container"> <img title="commutative diagram" src="096e2fdc0220ef7d1d917abcd6a3827f.svg" class="diagram  quiver"></img> </div>
</figure>
<ol class="incremental" type="1">
<li>First, we apply the equivalence <code>f</code>. Keeping in mind that <code>f</code> is <a href="1Lab.Equiv.html#_≃_">a pair</a> of a function and a proof that this function is an equivalence, we must project the underlying function to apply it.</li>
</ol>
<ol class="incremental" start="2" type="1">
<li><p>Then, we do a vacuous [transport] along the reflexivity path on <code>B</code>. While in the case of <span class="Agda"><a href="1Lab.Univalence.html#7883" class="Function">ua</a></span>, <code>B</code> doesn’t depend on <code>i</code>, in the general case of <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span>, it might. This is where the <code>transp (λ _ → B) i</code> in the path term <span class="Agda"><a href="1Lab.Univalence.html#9693" class="Function">uaβ</a></span> comes from: We need something that, on the left endpoint, is <code>transport refl _</code>, and on the right endpoint disappears.</p></li>
<li><p>Finally, we apply the inverse of the identity equivalence, which computes away, and contributes nothing to the term.</p></li>
</ol>
<pre class="Agda"><a id="uaβ"></a><a id="9693" href="1Lab.Univalence.html#9693" class="Function">uaβ</a> <a id="9697" class="Symbol">:</a> <a id="9699" class="Symbol">{</a><a id="9700" href="1Lab.Univalence.html#9700" class="Bound">A</a> <a id="9702" href="1Lab.Univalence.html#9702" class="Bound">B</a> <a id="9704" class="Symbol">:</a> <a id="9706" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="9711" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="9712" class="Symbol">}</a> <a id="9714" class="Symbol">(</a><a id="9715" href="1Lab.Univalence.html#9715" class="Bound">f</a> <a id="9717" class="Symbol">:</a> <a id="9719" href="1Lab.Univalence.html#9700" class="Bound">A</a> <a id="9721" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="9723" href="1Lab.Univalence.html#9702" class="Bound">B</a><a id="9724" class="Symbol">)</a> <a id="9726" class="Symbol">(</a><a id="9727" href="1Lab.Univalence.html#9727" class="Bound">x</a> <a id="9729" class="Symbol">:</a> <a id="9731" href="1Lab.Univalence.html#9700" class="Bound">A</a><a id="9732" class="Symbol">)</a> <a id="9734" class="Symbol">→</a> <a id="9736" href="1Lab.Path.html#10335" class="Function">transport</a> <a id="9746" class="Symbol">(</a><a id="9747" href="1Lab.Univalence.html#7883" class="Function">ua</a> <a id="9750" href="1Lab.Univalence.html#9715" class="Bound">f</a><a id="9751" class="Symbol">)</a> <a id="9753" href="1Lab.Univalence.html#9727" class="Bound">x</a> <a id="9755" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="9757" href="1Lab.Univalence.html#9715" class="Bound">f</a> <a id="9759" class="Symbol">.</a><a id="9760" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="9764" href="1Lab.Univalence.html#9727" class="Bound">x</a>
<a id="9766" href="1Lab.Univalence.html#9693" class="Function">uaβ</a> <a id="9770" class="Symbol">{</a><a id="9771" class="Argument">A</a> <a id="9773" class="Symbol">=</a> <a id="9775" href="1Lab.Univalence.html#9775" class="Bound">A</a><a id="9776" class="Symbol">}</a> <a id="9778" class="Symbol">{</a><a id="9779" href="1Lab.Univalence.html#9779" class="Bound">B</a><a id="9780" class="Symbol">}</a> <a id="9782" href="1Lab.Univalence.html#9782" class="Bound">f</a> <a id="9784" href="1Lab.Univalence.html#9784" class="Bound">x</a> <a id="9786" href="1Lab.Univalence.html#9786" class="Bound">i</a> <a id="9788" class="Symbol">=</a> <a id="9790" href="1Lab.Path.html#944" class="Primitive">transp</a> <a id="9797" class="Symbol">(λ</a> <a id="9800" href="1Lab.Univalence.html#9800" class="Bound">_</a> <a id="9802" class="Symbol">→</a> <a id="9804" href="1Lab.Univalence.html#9779" class="Bound">B</a><a id="9805" class="Symbol">)</a> <a id="9807" href="1Lab.Univalence.html#9786" class="Bound">i</a> <a id="9809" class="Symbol">(</a><a id="9810" href="1Lab.Univalence.html#9782" class="Bound">f</a> <a id="9812" class="Symbol">.</a><a id="9813" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="9817" href="1Lab.Univalence.html#9784" class="Bound">x</a><a id="9818" class="Symbol">)</a>
</pre>
<p>Since <span class="Agda"><a href="1Lab.Univalence.html#7883" class="Function">ua</a></span> is a map that turns equivalences into paths, we can compose it with a function that turns <a href="1Lab.Equiv.html#Iso">isomorphisms</a> into equivalences to get the map <span class="Agda"><a href="1Lab.Univalence.html#10046" class="Function">Iso→path</a></span>.</p>
<pre class="Agda"><a id="Iso→path"></a><a id="10046" href="1Lab.Univalence.html#10046" class="Function">Iso→path</a> <a id="10055" class="Symbol">:</a> <a id="10057" class="Symbol">{</a><a id="10058" href="1Lab.Univalence.html#10058" class="Bound">A</a> <a id="10060" href="1Lab.Univalence.html#10060" class="Bound">B</a> <a id="10062" class="Symbol">:</a> <a id="10064" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="10069" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="10070" class="Symbol">}</a> <a id="10072" class="Symbol">→</a> <a id="10074" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="10078" href="1Lab.Univalence.html#10058" class="Bound">A</a> <a id="10080" href="1Lab.Univalence.html#10060" class="Bound">B</a> <a id="10082" class="Symbol">→</a> <a id="10084" href="1Lab.Univalence.html#10058" class="Bound">A</a> <a id="10086" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10088" href="1Lab.Univalence.html#10060" class="Bound">B</a>
<a id="10090" href="1Lab.Univalence.html#10046" class="Function">Iso→path</a> <a id="10099" class="Symbol">(</a><a id="10100" href="1Lab.Univalence.html#10100" class="Bound">f</a> <a id="10102" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10104" href="1Lab.Univalence.html#10104" class="Bound">iiso</a><a id="10108" class="Symbol">)</a> <a id="10110" class="Symbol">=</a> <a id="10112" href="1Lab.Univalence.html#7883" class="Function">ua</a> <a id="10115" class="Symbol">(</a><a id="10116" href="1Lab.Univalence.html#10100" class="Bound">f</a> <a id="10118" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10120" href="1Lab.Equiv.html#19765" class="Function">isIso→isEquiv</a> <a id="10134" href="1Lab.Univalence.html#10104" class="Bound">iiso</a><a id="10138" class="Symbol">)</a>
</pre>
<h1 id="the-axiom">The “axiom”</h1>
<p>The actual “univalence axiom”, as stated in the HoTT book, says that the canonical map <code>A ≡ B</code>, defined using <span class="Agda"><a href="1Lab.Path.html#18079" class="Function">J</a></span>, is an equivalence. This map is <span class="Agda"><a href="1Lab.Univalence.html#10519" class="Function">idToEquiv</a></span>, defined right above. In more intuitive terms, it’s “casting” the identity equivalence <code>A ≃ A</code> along a proof that <code>A ≡ B</code> to get an equivalence <code>A ≃ B</code>.</p>
<pre class="Agda"><a id="10494" class="Keyword">module</a> <a id="10501" href="1Lab.Univalence.html#10501" class="Module">_</a> <a id="10503" class="Keyword">where</a> <a id="10509" class="Keyword">private</a>
  <a id="10519" href="1Lab.Univalence.html#10519" class="Function">idToEquiv</a> <a id="10529" class="Symbol">:</a> <a id="10531" class="Symbol">{</a><a id="10532" href="1Lab.Univalence.html#10532" class="Bound">A</a> <a id="10534" href="1Lab.Univalence.html#10534" class="Bound">B</a> <a id="10536" class="Symbol">:</a> <a id="10538" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="10543" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="10544" class="Symbol">}</a> <a id="10546" class="Symbol">→</a> <a id="10548" href="1Lab.Univalence.html#10532" class="Bound">A</a> <a id="10550" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10552" href="1Lab.Univalence.html#10534" class="Bound">B</a> <a id="10554" class="Symbol">→</a> <a id="10556" href="1Lab.Univalence.html#10532" class="Bound">A</a> <a id="10558" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="10560" href="1Lab.Univalence.html#10534" class="Bound">B</a>
  <a id="10564" href="1Lab.Univalence.html#10519" class="Function">idToEquiv</a> <a id="10574" class="Symbol">{</a><a id="10575" class="Argument">A</a> <a id="10577" class="Symbol">=</a> <a id="10579" href="1Lab.Univalence.html#10579" class="Bound">A</a><a id="10580" class="Symbol">}</a> <a id="10582" class="Symbol">{</a><a id="10583" href="1Lab.Univalence.html#10583" class="Bound">B</a><a id="10584" class="Symbol">}</a> <a id="10586" class="Symbol">=</a> <a id="10588" href="1Lab.Path.html#18079" class="Function">J</a> <a id="10590" class="Symbol">(λ</a> <a id="10593" href="1Lab.Univalence.html#10593" class="Bound">x</a> <a id="10595" href="1Lab.Univalence.html#10595" class="Bound">_</a> <a id="10597" class="Symbol">→</a> <a id="10599" href="1Lab.Univalence.html#10579" class="Bound">A</a> <a id="10601" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="10603" href="1Lab.Univalence.html#10593" class="Bound">x</a><a id="10604" class="Symbol">)</a> <a id="10606" class="Symbol">(_</a> <a id="10609" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10611" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="10618" class="Symbol">)</a>

  <a id="10623" href="1Lab.Univalence.html#10623" class="Function">idToEquiv-refl</a> <a id="10638" class="Symbol">:</a> <a id="10640" class="Symbol">{</a><a id="10641" href="1Lab.Univalence.html#10641" class="Bound">A</a> <a id="10643" class="Symbol">:</a> <a id="10645" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="10650" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="10651" class="Symbol">}</a> <a id="10653" class="Symbol">→</a> <a id="10655" href="1Lab.Univalence.html#10519" class="Function">idToEquiv</a> <a id="10665" class="Symbol">(λ</a> <a id="10668" href="1Lab.Univalence.html#10668" class="Bound">i</a> <a id="10670" class="Symbol">→</a> <a id="10672" href="1Lab.Univalence.html#10641" class="Bound">A</a><a id="10673" class="Symbol">)</a> <a id="10675" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10677" class="Symbol">(_</a> <a id="10680" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10682" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="10689" class="Symbol">)</a>
  <a id="10693" href="1Lab.Univalence.html#10623" class="Function">idToEquiv-refl</a> <a id="10708" class="Symbol">{</a><a id="10709" class="Argument">A</a> <a id="10711" class="Symbol">=</a> <a id="10713" href="1Lab.Univalence.html#10713" class="Bound">A</a><a id="10714" class="Symbol">}</a> <a id="10716" class="Symbol">=</a> <a id="10718" href="1Lab.Path.html#18637" class="Function">JRefl</a> <a id="10724" class="Symbol">(λ</a> <a id="10727" href="1Lab.Univalence.html#10727" class="Bound">x</a> <a id="10729" href="1Lab.Univalence.html#10729" class="Bound">_</a> <a id="10731" class="Symbol">→</a> <a id="10733" href="1Lab.Univalence.html#10713" class="Bound">A</a> <a id="10735" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="10737" href="1Lab.Univalence.html#10727" class="Bound">x</a><a id="10738" class="Symbol">)</a> <a id="10740" class="Symbol">(_</a> <a id="10743" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10745" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="10752" class="Symbol">)</a>
</pre>
<p>However, because of efficiency concerns (Agda <em>is</em> a programming language, after all), instead of using <span class="Agda"><a href="1Lab.Univalence.html#10519" class="Function">idToEquiv</a></span> defined using J, we use <span class="Agda"><a href="1Lab.Univalence.html#11007" class="Function">pathToEquiv</a></span>, which is <a href="1Lab.Equiv.FromPath.html">defined in an auxilliary module</a>.</p>
<pre class="Agda"><a id="pathToEquiv"></a><a id="11007" href="1Lab.Univalence.html#11007" class="Function">pathToEquiv</a> <a id="11019" class="Symbol">:</a> <a id="11021" class="Symbol">{</a><a id="11022" href="1Lab.Univalence.html#11022" class="Bound">A</a> <a id="11024" href="1Lab.Univalence.html#11024" class="Bound">B</a> <a id="11026" class="Symbol">:</a> <a id="11028" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="11033" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="11034" class="Symbol">}</a> <a id="11036" class="Symbol">→</a> <a id="11038" href="1Lab.Univalence.html#11022" class="Bound">A</a> <a id="11040" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="11042" href="1Lab.Univalence.html#11024" class="Bound">B</a> <a id="11044" class="Symbol">→</a> <a id="11046" href="1Lab.Univalence.html#11022" class="Bound">A</a> <a id="11048" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="11050" href="1Lab.Univalence.html#11024" class="Bound">B</a>
<a id="11052" href="1Lab.Univalence.html#11007" class="Function">pathToEquiv</a> <a id="11064" href="1Lab.Univalence.html#11064" class="Bound">p</a> <a id="11066" class="Symbol">=</a> <a id="11068" href="1Lab.Equiv.FromPath.html#9222" class="Function">line→equiv</a> <a id="11079" class="Symbol">(λ</a> <a id="11082" href="1Lab.Univalence.html#11082" class="Bound">i</a> <a id="11084" class="Symbol">→</a> <a id="11086" href="1Lab.Univalence.html#11064" class="Bound">p</a> <a id="11088" href="1Lab.Univalence.html#11082" class="Bound">i</a><a id="11089" class="Symbol">)</a>

<a id="pathToEquiv-refl"></a><a id="11092" href="1Lab.Univalence.html#11092" class="Function">pathToEquiv-refl</a> <a id="11109" class="Symbol">:</a> <a id="11111" class="Symbol">{</a><a id="11112" href="1Lab.Univalence.html#11112" class="Bound">A</a> <a id="11114" class="Symbol">:</a> <a id="11116" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="11121" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="11122" class="Symbol">}</a> <a id="11124" class="Symbol">→</a> <a id="11126" href="1Lab.Univalence.html#11007" class="Function">pathToEquiv</a> <a id="11138" class="Symbol">(</a><a id="11139" href="1Lab.Path.html#2137" class="Function">refl</a> <a id="11144" class="Symbol">{</a><a id="11145" class="Argument">x</a> <a id="11147" class="Symbol">=</a> <a id="11149" href="1Lab.Univalence.html#11112" class="Bound">A</a><a id="11150" class="Symbol">})</a> <a id="11153" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="11155" class="Symbol">(</a><a id="11156" href="1Lab.Type.html#2348" class="Function">id</a> <a id="11159" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11161" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="11168" class="Symbol">)</a>
<a id="11170" href="1Lab.Univalence.html#11092" class="Function">pathToEquiv-refl</a> <a id="11187" class="Symbol">{</a><a id="11188" class="Argument">A</a> <a id="11190" class="Symbol">=</a> <a id="11192" href="1Lab.Univalence.html#11192" class="Bound">A</a><a id="11193" class="Symbol">}</a> <a id="11195" class="Symbol">=</a>
  <a id="11199" href="1Lab.Path.html#55613" class="Function">Σ-Path</a> <a id="11206" class="Symbol">(λ</a> <a id="11209" href="1Lab.Univalence.html#11209" class="Bound">i</a> <a id="11211" href="1Lab.Univalence.html#11211" class="Bound">x</a> <a id="11213" class="Symbol">→</a> <a id="11215" href="1Lab.Path.html#944" class="Primitive">transp</a> <a id="11222" class="Symbol">(λ</a> <a id="11225" href="1Lab.Univalence.html#11225" class="Bound">j</a> <a id="11227" class="Symbol">→</a> <a id="11229" href="1Lab.Univalence.html#11192" class="Bound">A</a><a id="11230" class="Symbol">)</a> <a id="11232" href="1Lab.Univalence.html#11209" class="Bound">i</a> <a id="11234" href="1Lab.Univalence.html#11211" class="Bound">x</a><a id="11235" class="Symbol">)</a> <a id="11237" class="Symbol">(</a><a id="11238" href="1Lab.Equiv.html#4883" class="Function">isProp-isEquiv</a> <a id="11253" class="Symbol">_</a> <a id="11255" class="Symbol">_</a> <a id="11257" class="Symbol">_)</a>
</pre>
<pre class="Agda"><a id="univalence-Iso"></a><a id="11273" href="1Lab.Univalence.html#11273" class="Function">univalence-Iso</a> <a id="11288" class="Symbol">:</a> <a id="11290" class="Symbol">{</a><a id="11291" href="1Lab.Univalence.html#11291" class="Bound">A</a> <a id="11293" href="1Lab.Univalence.html#11293" class="Bound">B</a> <a id="11295" class="Symbol">:</a> <a id="11297" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="11302" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="11303" class="Symbol">}</a> <a id="11305" class="Symbol">→</a> <a id="11307" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="11311" class="Symbol">(</a><a id="11312" href="1Lab.Univalence.html#11291" class="Bound">A</a> <a id="11314" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="11316" href="1Lab.Univalence.html#11293" class="Bound">B</a><a id="11317" class="Symbol">)</a> <a id="11319" class="Symbol">(</a><a id="11320" href="1Lab.Univalence.html#11291" class="Bound">A</a> <a id="11322" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="11324" href="1Lab.Univalence.html#11293" class="Bound">B</a><a id="11325" class="Symbol">)</a>
<a id="univalence"></a><a id="11327" href="1Lab.Univalence.html#11327" class="Function">univalence</a> <a id="11338" class="Symbol">:</a> <a id="11340" class="Symbol">{</a><a id="11341" href="1Lab.Univalence.html#11341" class="Bound">A</a> <a id="11343" href="1Lab.Univalence.html#11343" class="Bound">B</a> <a id="11345" class="Symbol">:</a> <a id="11347" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="11352" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="11353" class="Symbol">}</a> <a id="11355" class="Symbol">→</a> <a id="11357" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="11365" class="Symbol">(</a><a id="11366" href="1Lab.Univalence.html#11007" class="Function">pathToEquiv</a> <a id="11378" class="Symbol">{</a><a id="11379" class="Argument">A</a> <a id="11381" class="Symbol">=</a> <a id="11383" href="1Lab.Univalence.html#11341" class="Bound">A</a><a id="11384" class="Symbol">}</a> <a id="11386" class="Symbol">{</a><a id="11387" href="1Lab.Univalence.html#11343" class="Bound">B</a><a id="11388" class="Symbol">})</a>
<a id="univalence¯¹"></a><a id="11391" href="1Lab.Univalence.html#11391" class="Function">univalence¯¹</a> <a id="11404" class="Symbol">:</a> <a id="11406" class="Symbol">{</a><a id="11407" href="1Lab.Univalence.html#11407" class="Bound">A</a> <a id="11409" href="1Lab.Univalence.html#11409" class="Bound">B</a> <a id="11411" class="Symbol">:</a> <a id="11413" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="11418" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="11419" class="Symbol">}</a> <a id="11421" class="Symbol">→</a> <a id="11423" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="11431" class="Symbol">(</a><a id="11432" href="1Lab.Univalence.html#7883" class="Function">ua</a> <a id="11435" class="Symbol">{</a><a id="11436" class="Argument">A</a> <a id="11438" class="Symbol">=</a> <a id="11440" href="1Lab.Univalence.html#11407" class="Bound">A</a><a id="11441" class="Symbol">}</a> <a id="11443" class="Symbol">{</a><a id="11444" href="1Lab.Univalence.html#11409" class="Bound">B</a><a id="11445" class="Symbol">})</a>
</pre>
<p>We can now prove the univalence theorem - this map is an isomorphism, and thus, an equivalence. First, we need a small lemma that says <code>ua id ≡ refl</code>. This will be used to show one direction of the inverse.</p>
<pre class="Agda"><a id="uaIdEquiv"></a><a id="11669" href="1Lab.Univalence.html#11669" class="Function">uaIdEquiv</a> <a id="11679" class="Symbol">:</a> <a id="11681" class="Symbol">{</a><a id="11682" href="1Lab.Univalence.html#11682" class="Bound">A</a> <a id="11684" class="Symbol">:</a> <a id="11686" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="11691" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="11692" class="Symbol">}</a> <a id="11694" class="Symbol">→</a> <a id="11696" href="1Lab.Univalence.html#7883" class="Function">ua</a> <a id="11699" class="Symbol">(_</a> <a id="11702" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11704" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a> <a id="11712" class="Symbol">{</a><a id="11713" class="Argument">A</a> <a id="11715" class="Symbol">=</a> <a id="11717" href="1Lab.Univalence.html#11682" class="Bound">A</a><a id="11718" class="Symbol">})</a> <a id="11721" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="11723" href="1Lab.Path.html#2137" class="Function">refl</a>
<a id="11728" href="1Lab.Univalence.html#11669" class="Function">uaIdEquiv</a> <a id="11738" class="Symbol">{</a><a id="11739" class="Argument">A</a> <a id="11741" class="Symbol">=</a> <a id="11743" href="1Lab.Univalence.html#11743" class="Bound">A</a><a id="11744" class="Symbol">}</a> <a id="11746" href="1Lab.Univalence.html#11746" class="Bound">i</a> <a id="11748" href="1Lab.Univalence.html#11748" class="Bound">j</a> <a id="11750" class="Symbol">=</a> <a id="11752" href="1Lab.Univalence.html#3381" class="Function">Glue</a> <a id="11757" href="1Lab.Univalence.html#11743" class="Bound">A</a> <a id="11759" class="Symbol">{</a><a id="11760" class="Argument">φ</a> <a id="11762" class="Symbol">=</a> <a id="11764" href="1Lab.Univalence.html#11746" class="Bound">i</a> <a id="11766" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="11768" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="11770" href="1Lab.Univalence.html#11748" class="Bound">j</a> <a id="11772" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="11774" href="1Lab.Univalence.html#11748" class="Bound">j</a><a id="11775" class="Symbol">}</a> <a id="11777" class="Symbol">(λ</a> <a id="11780" href="1Lab.Univalence.html#11780" class="Bound">_</a> <a id="11782" class="Symbol">→</a> <a id="11784" href="1Lab.Univalence.html#11743" class="Bound">A</a> <a id="11786" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11788" class="Symbol">_</a> <a id="11790" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11792" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="11799" class="Symbol">)</a>

<a id="11802" href="1Lab.Univalence.html#11273" class="Function">univalence-Iso</a> <a id="11817" class="Symbol">{</a><a id="11818" class="Argument">A</a> <a id="11820" class="Symbol">=</a> <a id="11822" href="1Lab.Univalence.html#11822" class="Bound">A</a><a id="11823" class="Symbol">}</a> <a id="11825" class="Symbol">{</a><a id="11826" class="Argument">B</a> <a id="11828" class="Symbol">=</a> <a id="11830" href="1Lab.Univalence.html#11830" class="Bound">B</a><a id="11831" class="Symbol">}</a> <a id="11833" class="Symbol">=</a> <a id="11835" href="1Lab.Univalence.html#11007" class="Function">pathToEquiv</a> <a id="11847" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11849" href="1Lab.Univalence.html#12189" class="Function">iiso</a> <a id="11854" class="Keyword">where</a>
</pre>
<p>This can be shown using <span class="Agda"><a href="1Lab.Univalence.html#3381" class="Function">Glue</a></span>. There are two interval variables, this is a path between paths: a square. When <code>i = i0</code>, the glue is stuck<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, so we get <code>Glue A (λ _ → A , _ , idEquiv)</code>. When <code>i = i1</code>, by the argument <code>φ</code>, the glue computes away, and we get <code>refl</code>, hence the type.</p>
<pre class="Agda">  <a id="12189" href="1Lab.Univalence.html#12189" class="Function">iiso</a> <a id="12194" class="Symbol">:</a> <a id="12196" href="1Lab.Equiv.html#5975" class="Record">isIso</a> <a id="12202" href="1Lab.Univalence.html#11007" class="Function">pathToEquiv</a>
  <a id="12216" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="12226" href="1Lab.Univalence.html#12189" class="Function">iiso</a> <a id="12231" class="Symbol">=</a> <a id="12233" href="1Lab.Univalence.html#7883" class="Function">ua</a>
</pre>
<p>The inverse to <span class="Agda"><a href="1Lab.Univalence.html#11007" class="Function">pathToEquiv</a></span> is the <span class="Agda"><a href="1Lab.Univalence.html#7883" class="Function">ua</a></span> map which turns equivalences into paths.</p>
<pre class="Agda">  <a id="12348" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="12359" href="1Lab.Univalence.html#12189" class="Function">iiso</a> <a id="12364" class="Symbol">(</a><a id="12365" href="1Lab.Univalence.html#12365" class="Bound">f</a> <a id="12367" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="12369" href="1Lab.Univalence.html#12369" class="Bound">isEqv</a><a id="12374" class="Symbol">)</a> <a id="12376" class="Symbol">=</a>
    <a id="12382" href="1Lab.Path.html#55613" class="Function">Σ-Path</a> <a id="12389" class="Symbol">(λ</a> <a id="12392" href="1Lab.Univalence.html#12392" class="Bound">i</a> <a id="12394" href="1Lab.Univalence.html#12394" class="Bound">x</a> <a id="12396" class="Symbol">→</a> <a id="12398" href="1Lab.Path.html#944" class="Primitive">transp</a> <a id="12405" class="Symbol">(λ</a> <a id="12408" href="1Lab.Univalence.html#12408" class="Bound">i</a> <a id="12410" class="Symbol">→</a> <a id="12412" href="1Lab.Univalence.html#11830" class="Bound">B</a><a id="12413" class="Symbol">)</a> <a id="12415" href="1Lab.Univalence.html#12392" class="Bound">i</a> <a id="12417" class="Symbol">(</a><a id="12418" href="1Lab.Univalence.html#12365" class="Bound">f</a> <a id="12420" href="1Lab.Univalence.html#12394" class="Bound">x</a><a id="12421" class="Symbol">))</a>
           <a id="12435" class="Symbol">(</a><a id="12436" href="1Lab.Equiv.html#4883" class="Function">isProp-isEquiv</a> <a id="12451" href="1Lab.Univalence.html#12365" class="Bound">f</a> <a id="12453" class="Symbol">_</a> <a id="12455" class="Symbol">_)</a>
</pre>
<p>We have that <code>pathToEquiv (ua f) ≡ f</code> in two parts. Since equivalences are pairs, we can reduce this to proving that the function is preserved, and proving that the equivalence proof is preserved. The latter follows from <span class="Agda"><a href="1Lab.Equiv.html#2293" class="Record">isEquiv</a></span> being a proposition.</p>
<p>For the former, Agda does all the work for us: All we need to show is that <code>transport (λ i → B) (f x)</code> is equal to <code>f</code>. This we do using <span class="Agda"><a href="1Lab.Path.html#944" class="Primitive">transp</a></span>, which, when <code>i = i1</code>, behaves like the identity function.</p>
<pre class="Agda">  <a id="12947" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="12958" href="1Lab.Univalence.html#12189" class="Function">iiso</a> <a id="12963" class="Symbol">=</a> 
    <a id="12970" href="1Lab.Path.html#18079" class="Function">J</a> <a id="12972" class="Symbol">(λ</a> <a id="12975" href="1Lab.Univalence.html#12975" class="Bound">_</a> <a id="12977" href="1Lab.Univalence.html#12977" class="Bound">p</a> <a id="12979" class="Symbol">→</a> <a id="12981" href="1Lab.Univalence.html#7883" class="Function">ua</a> <a id="12984" class="Symbol">(</a><a id="12985" href="1Lab.Univalence.html#11007" class="Function">pathToEquiv</a> <a id="12997" href="1Lab.Univalence.html#12977" class="Bound">p</a><a id="12998" class="Symbol">)</a> <a id="13000" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="13002" href="1Lab.Univalence.html#12977" class="Bound">p</a><a id="13003" class="Symbol">)</a>
      <a id="13011" class="Symbol">(</a><a id="13012" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="13015" href="1Lab.Univalence.html#7883" class="Function">ua</a> <a id="13018" href="1Lab.Univalence.html#11092" class="Function">pathToEquiv-refl</a> <a id="13035" href="1Lab.Path.html#38031" class="Function Operator">∙</a> <a id="13037" href="1Lab.Univalence.html#11669" class="Function">uaIdEquiv</a><a id="13046" class="Symbol">)</a>

<a id="13049" href="1Lab.Univalence.html#11327" class="Function">univalence</a> <a id="13060" class="Symbol">{</a><a id="13061" class="Argument">A</a> <a id="13063" class="Symbol">=</a> <a id="13065" href="1Lab.Univalence.html#13065" class="Bound">A</a><a id="13066" class="Symbol">}</a> <a id="13068" class="Symbol">{</a><a id="13069" href="1Lab.Univalence.html#13069" class="Bound">B</a><a id="13070" class="Symbol">}</a> <a id="13072" class="Symbol">=</a> <a id="13074" href="1Lab.Equiv.html#19765" class="Function">isIso→isEquiv</a> <a id="13088" class="Symbol">(</a><a id="13089" href="1Lab.Univalence.html#11273" class="Function">univalence-Iso</a> <a id="13104" class="Symbol">.</a><a id="13105" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="13108" class="Symbol">)</a>
<a id="13110" href="1Lab.Univalence.html#11391" class="Function">univalence¯¹</a> <a id="13123" class="Symbol">{</a><a id="13124" class="Argument">A</a> <a id="13126" class="Symbol">=</a> <a id="13128" href="1Lab.Univalence.html#13128" class="Bound">A</a><a id="13129" class="Symbol">}</a> <a id="13131" class="Symbol">{</a><a id="13132" href="1Lab.Univalence.html#13132" class="Bound">B</a><a id="13133" class="Symbol">}</a> <a id="13135" class="Symbol">=</a> <a id="13137" href="1Lab.Equiv.html#19765" class="Function">isIso→isEquiv</a> <a id="13151" class="Symbol">(</a><a id="13152" href="1Lab.Equiv.html#6158" class="Function">isIso.inverse</a> <a id="13166" class="Symbol">(</a><a id="13167" href="1Lab.Univalence.html#11273" class="Function">univalence-Iso</a> <a id="13182" class="Symbol">.</a><a id="13183" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="13186" class="Symbol">))</a>
</pre>
<p>To show that <code>pathToEquiv (ua p) ≡ p</code>, we do <a href="1Lab.Path.html#J">path induction</a> on <code>p</code>, reducing this to showing that <code>ua (pathToEquiv refl) ≡ refl</code>. By <span class="Agda"><a href="1Lab.Univalence.html#11092" class="Function">pathToEquiv-refl</a></span>, we have that <code>pathToEquiv refl</code> is <span class="Agda"><a href="1Lab.Equiv.html#2526" class="Function">idEquiv</a></span>, which means the <span class="Agda"><a href="1Lab.Univalence.html#11669" class="Function">uaIdEquiv</a></span> lemma proves what we wanted.</p>
<p>In many situations, it is helpful to have a proof that <span class="Agda"><a href="1Lab.Univalence.html#11007" class="Function">pathToEquiv</a></span> followed by <code class="sourceCode agda" data-ident="Lift">an adjustment of levels</code> is still an equivalence:</p>
<pre class="Agda"><a id="univalence-lift"></a><a id="13676" href="1Lab.Univalence.html#13676" class="Function">univalence-lift</a> <a id="13692" class="Symbol">:</a> <a id="13694" class="Symbol">{</a><a id="13695" href="1Lab.Univalence.html#13695" class="Bound">A</a> <a id="13697" href="1Lab.Univalence.html#13697" class="Bound">B</a> <a id="13699" class="Symbol">:</a> <a id="13701" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13706" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="13707" class="Symbol">}</a> <a id="13709" class="Symbol">→</a> <a id="13711" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="13719" class="Symbol">(λ</a> <a id="13722" href="1Lab.Univalence.html#13722" class="Bound">e</a> <a id="13724" class="Symbol">→</a> <a id="13726" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a id="13731" class="Symbol">(</a><a id="13732" href="1Lab.Univalence.html#11007" class="Function">pathToEquiv</a> <a id="13744" class="Symbol">{</a><a id="13745" class="Argument">A</a> <a id="13747" class="Symbol">=</a> <a id="13749" href="1Lab.Univalence.html#13695" class="Bound">A</a><a id="13750" class="Symbol">}</a> <a id="13752" class="Symbol">{</a><a id="13753" href="1Lab.Univalence.html#13697" class="Bound">B</a><a id="13754" class="Symbol">}</a> <a id="13756" href="1Lab.Univalence.html#13722" class="Bound">e</a><a id="13757" class="Symbol">))</a>
<a id="13760" href="1Lab.Univalence.html#13676" class="Function">univalence-lift</a> <a id="13776" class="Symbol">{</a><a id="13777" class="Argument">ℓ</a> <a id="13779" class="Symbol">=</a> <a id="13781" href="1Lab.Univalence.html#13781" class="Bound">ℓ</a><a id="13782" class="Symbol">}</a> <a id="13784" class="Symbol">=</a> <a id="13786" href="1Lab.Equiv.html#19765" class="Function">isIso→isEquiv</a> <a id="13800" href="1Lab.Univalence.html#13813" class="Function">morp</a> <a id="13805" class="Keyword">where</a>
  <a id="13813" href="1Lab.Univalence.html#13813" class="Function">morp</a> <a id="13818" class="Symbol">:</a> <a id="13820" href="1Lab.Equiv.html#5975" class="Record">isIso</a> <a id="13826" class="Symbol">(λ</a> <a id="13829" href="1Lab.Univalence.html#13829" class="Bound">e</a> <a id="13831" class="Symbol">→</a> <a id="13833" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a id="13838" class="Symbol">{</a><a id="13839" class="Argument">ℓ</a> <a id="13841" class="Symbol">=</a> <a id="13843" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="13848" href="1Lab.Univalence.html#13781" class="Bound">ℓ</a><a id="13849" class="Symbol">}</a> <a id="13851" class="Symbol">(</a><a id="13852" href="1Lab.Univalence.html#11007" class="Function">pathToEquiv</a> <a id="13864" href="1Lab.Univalence.html#13829" class="Bound">e</a><a id="13865" class="Symbol">))</a>
  <a id="13870" href="1Lab.Univalence.html#13813" class="Function">morp</a> <a id="13875" class="Symbol">.</a><a id="13876" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="13886" href="1Lab.Univalence.html#13886" class="Bound">x</a> <a id="13888" class="Symbol">=</a> <a id="13890" href="1Lab.Univalence.html#7883" class="Function">ua</a> <a id="13893" class="Symbol">(</a><a id="13894" href="1Lab.Univalence.html#13886" class="Bound">x</a> <a id="13896" class="Symbol">.</a><a id="13897" href="1Lab.Type.html#2082" class="Field">Lift.lower</a><a id="13907" class="Symbol">)</a>
  <a id="13911" href="1Lab.Univalence.html#13813" class="Function">morp</a> <a id="13916" class="Symbol">.</a><a id="13917" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="13928" href="1Lab.Univalence.html#13928" class="Bound">x</a> <a id="13930" class="Symbol">=</a>
    <a id="13936" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a id="13941" class="Symbol">(</a><a id="13942" href="1Lab.Univalence.html#11007" class="Function">pathToEquiv</a> <a id="13954" class="Symbol">(</a><a id="13955" href="1Lab.Univalence.html#7883" class="Function">ua</a> <a id="13958" class="Symbol">(</a><a id="13959" href="1Lab.Univalence.html#13928" class="Bound">x</a> <a id="13961" class="Symbol">.</a><a id="13962" href="1Lab.Type.html#2082" class="Field">Lift.lower</a><a id="13972" class="Symbol">)))</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="13976" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a id="13979" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="13982" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a id="13987" class="Symbol">(</a><a id="13988" href="1Lab.Univalence.html#11273" class="Function">univalence-Iso</a> <a id="14003" class="Symbol">.</a><a id="14004" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="14008" class="Symbol">.</a><a id="14009" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="14020" class="Symbol">_)</a> <a id="14023" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
    <a id="14029" href="1Lab.Univalence.html#13928" class="Bound">x</a>                                       <a id="14069" href="1Lab.Path.html#45365" class="Function Operator">∎</a>
  <a id="14073" href="1Lab.Univalence.html#13813" class="Function">morp</a> <a id="14078" class="Symbol">.</a><a id="14079" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="14090" href="1Lab.Univalence.html#14090" class="Bound">x</a> <a id="14092" class="Symbol">=</a> <a id="14094" href="1Lab.Univalence.html#11273" class="Function">univalence-Iso</a> <a id="14109" class="Symbol">.</a><a id="14110" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="14114" class="Symbol">.</a><a id="14115" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="14126" class="Symbol">_</a>
</pre>
<h2 id="consequences">Consequences</h2>
<p>One useful consequence of the fact that <code>(A ≡ B) ≡ (A ≃ B)</code><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> is that the type of <em>equivalences</em> satisfies <a href="1Lab.Path.html#J">the same induction principle</a> as the type of <em>equalities</em>. What I mean, precisely, is that the type <code>Σ B (A ≃ B)</code> is contractible, like the type <code>Σ B (A ≡ B)</code>. From this, we get “equivalence induction”: <span class="Agda"><a href="1Lab.Univalence.html#15173" class="Function">EquivJ</a></span>.</p>
<pre class="Agda"><a id="EquivContr"></a><a id="14540" href="1Lab.Univalence.html#14540" class="Function">EquivContr</a> <a id="14551" class="Symbol">:</a> <a id="14553" class="Symbol">∀</a> <a id="14555" class="Symbol">{</a><a id="14556" href="1Lab.Univalence.html#14556" class="Bound">ℓ</a><a id="14557" class="Symbol">}</a> <a id="14559" class="Symbol">(</a><a id="14560" href="1Lab.Univalence.html#14560" class="Bound">A</a> <a id="14562" class="Symbol">:</a> <a id="14564" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14569" href="1Lab.Univalence.html#14556" class="Bound">ℓ</a><a id="14570" class="Symbol">)</a> <a id="14572" class="Symbol">→</a> <a id="14574" href="1Lab.HLevel.html#1328" class="Record">isContr</a> <a id="14582" class="Symbol">(</a><a id="14583" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="14586" href="1Lab.Univalence.html#14586" class="Bound">B</a> <a id="14588" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="14590" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14595" href="1Lab.Univalence.html#14556" class="Bound">ℓ</a> <a id="14597" href="1Lab.Type.html#1563" class="Function">]</a> <a id="14599" href="1Lab.Univalence.html#14560" class="Bound">A</a> <a id="14601" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="14603" href="1Lab.Univalence.html#14586" class="Bound">B</a><a id="14604" class="Symbol">)</a>
<a id="14606" href="1Lab.HLevel.html#1400" class="Field">isContr.centre</a> <a id="14621" class="Symbol">(</a><a id="14622" href="1Lab.Univalence.html#14540" class="Function">EquivContr</a> <a id="14633" href="1Lab.Univalence.html#14633" class="Bound">A</a><a id="14634" class="Symbol">)</a>          <a id="14645" class="Symbol">=</a> <a id="14647" href="1Lab.Univalence.html#14633" class="Bound">A</a> <a id="14649" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="14651" class="Symbol">_</a> <a id="14653" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="14655" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>
<a id="14663" href="1Lab.HLevel.html#1415" class="Field">isContr.paths</a> <a id="14677" class="Symbol">(</a><a id="14678" href="1Lab.Univalence.html#14540" class="Function">EquivContr</a> <a id="14689" href="1Lab.Univalence.html#14689" class="Bound">A</a><a id="14690" class="Symbol">)</a> <a id="14692" class="Symbol">(</a><a id="14693" href="1Lab.Univalence.html#14693" class="Bound">B</a> <a id="14695" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="14697" href="1Lab.Univalence.html#14697" class="Bound">A≃B</a><a id="14700" class="Symbol">)</a> <a id="14702" class="Symbol">=</a> <a id="14704" href="1Lab.Path.html#55613" class="Function">Σ-Path</a> <a id="14711" class="Symbol">(</a><a id="14712" href="1Lab.Univalence.html#7883" class="Function">ua</a> <a id="14715" href="1Lab.Univalence.html#14697" class="Bound">A≃B</a><a id="14718" class="Symbol">)</a> <a id="14720" class="Symbol">(</a><a id="14721" href="1Lab.Path.html#55613" class="Function">Σ-Path</a> <a id="14728" href="1Lab.Univalence.html#14745" class="Function">p</a> <a id="14730" href="1Lab.Univalence.html#14820" class="Function">q</a><a id="14731" class="Symbol">)</a>
  <a id="14735" class="Keyword">where</a>
    <a id="14745" href="1Lab.Univalence.html#14745" class="Function">p</a> <a id="14747" class="Symbol">:</a> <a id="14749" class="Symbol">_</a>
    <a id="14755" href="1Lab.Univalence.html#14745" class="Function">p</a> <a id="14757" href="1Lab.Univalence.html#14757" class="Bound">i</a> <a id="14759" href="1Lab.Univalence.html#14759" class="Bound">x</a> <a id="14761" class="Symbol">=</a> <a id="14763" href="1Lab.Path.html#944" class="Primitive">transp</a> <a id="14770" class="Symbol">(λ</a> <a id="14773" href="1Lab.Univalence.html#14773" class="Bound">i</a> <a id="14775" class="Symbol">→</a> <a id="14777" href="1Lab.Univalence.html#14693" class="Bound">B</a><a id="14778" class="Symbol">)</a> <a id="14780" href="1Lab.Univalence.html#14757" class="Bound">i</a> <a id="14782" class="Symbol">(</a><a id="14783" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="14787" href="1Lab.Univalence.html#14697" class="Bound">A≃B</a> <a id="14791" class="Symbol">(</a><a id="14792" href="1Lab.Path.html#944" class="Primitive">transp</a> <a id="14799" class="Symbol">(λ</a> <a id="14802" href="1Lab.Univalence.html#14802" class="Bound">j</a> <a id="14804" class="Symbol">→</a> <a id="14806" href="1Lab.Univalence.html#14689" class="Bound">A</a><a id="14807" class="Symbol">)</a> <a id="14809" href="1Lab.Univalence.html#14757" class="Bound">i</a> <a id="14811" href="1Lab.Univalence.html#14759" class="Bound">x</a><a id="14812" class="Symbol">))</a>

    <a id="14820" href="1Lab.Univalence.html#14820" class="Function">q</a> <a id="14822" class="Symbol">:</a> <a id="14824" class="Symbol">_</a>
    <a id="14830" href="1Lab.Univalence.html#14820" class="Function">q</a> <a id="14832" class="Symbol">=</a> <a id="14834" href="1Lab.Equiv.html#4883" class="Function">isProp-isEquiv</a> <a id="14849" class="Symbol">(</a><a id="14850" href="1Lab.Univalence.html#14697" class="Bound">A≃B</a> <a id="14854" class="Symbol">.</a><a id="14855" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="14858" class="Symbol">)</a> <a id="14860" class="Symbol">_</a> <a id="14862" class="Symbol">_</a>
</pre>
<p>We can use the same decomposition of <span class="Agda"><a href="1Lab.Path.html#18079" class="Function">J</a></span> as transport + contractibility of singletons for equivalences. Since we have that <code>(A , _ , idEquiv) ≡ (B , eqv)</code>, we can transport a proof of <code>P (A , _)</code> to a proof of <code>P (B , eqv)</code>. Modulo currying, this is exactly the same thing as <span class="Agda"><a href="1Lab.Path.html#18079" class="Function">J</a></span>.</p>
<pre class="Agda"><a id="EquivJ"></a><a id="15173" href="1Lab.Univalence.html#15173" class="Function">EquivJ</a> <a id="15180" class="Symbol">:</a> <a id="15182" class="Symbol">∀</a> <a id="15184" class="Symbol">{</a><a id="15185" href="1Lab.Univalence.html#15185" class="Bound">ℓ</a> <a id="15187" href="1Lab.Univalence.html#15187" class="Bound">ℓ&#39;</a><a id="15189" class="Symbol">}</a> <a id="15191" class="Symbol">{</a><a id="15192" href="1Lab.Univalence.html#15192" class="Bound">A</a> <a id="15194" class="Symbol">:</a> <a id="15196" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15201" href="1Lab.Univalence.html#15185" class="Bound">ℓ</a><a id="15202" class="Symbol">}</a>
       <a id="15211" class="Symbol">→</a> <a id="15213" class="Symbol">(</a><a id="15214" href="1Lab.Univalence.html#15214" class="Bound">P</a> <a id="15216" class="Symbol">:</a> <a id="15218" class="Symbol">(</a><a id="15219" href="1Lab.Univalence.html#15219" class="Bound">B</a> <a id="15221" class="Symbol">:</a> <a id="15223" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15228" href="1Lab.Univalence.html#15185" class="Bound">ℓ</a><a id="15229" class="Symbol">)</a> <a id="15231" class="Symbol">→</a> <a id="15233" href="1Lab.Univalence.html#15192" class="Bound">A</a> <a id="15235" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="15237" href="1Lab.Univalence.html#15219" class="Bound">B</a> <a id="15239" class="Symbol">→</a> <a id="15241" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15246" href="1Lab.Univalence.html#15187" class="Bound">ℓ&#39;</a><a id="15248" class="Symbol">)</a>
       <a id="15257" class="Symbol">→</a> <a id="15259" href="1Lab.Univalence.html#15214" class="Bound">P</a> <a id="15261" href="1Lab.Univalence.html#15192" class="Bound">A</a> <a id="15263" class="Symbol">(_</a> <a id="15266" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="15268" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15275" class="Symbol">)</a>
       <a id="15284" class="Symbol">→</a> <a id="15286" class="Symbol">{</a><a id="15287" href="1Lab.Univalence.html#15287" class="Bound">B</a> <a id="15289" class="Symbol">:</a> <a id="15291" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15296" href="1Lab.Univalence.html#15185" class="Bound">ℓ</a><a id="15297" class="Symbol">}</a> <a id="15299" class="Symbol">(</a><a id="15300" href="1Lab.Univalence.html#15300" class="Bound">e</a> <a id="15302" class="Symbol">:</a> <a id="15304" href="1Lab.Univalence.html#15192" class="Bound">A</a> <a id="15306" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="15308" href="1Lab.Univalence.html#15287" class="Bound">B</a><a id="15309" class="Symbol">)</a>
       <a id="15318" class="Symbol">→</a> <a id="15320" href="1Lab.Univalence.html#15214" class="Bound">P</a> <a id="15322" href="1Lab.Univalence.html#15287" class="Bound">B</a> <a id="15324" href="1Lab.Univalence.html#15300" class="Bound">e</a>
<a id="15326" href="1Lab.Univalence.html#15173" class="Function">EquivJ</a> <a id="15333" href="1Lab.Univalence.html#15333" class="Bound">P</a> <a id="15335" href="1Lab.Univalence.html#15335" class="Bound">pid</a> <a id="15339" href="1Lab.Univalence.html#15339" class="Bound">eqv</a> <a id="15343" class="Symbol">=</a>
  <a id="15347" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="15353" class="Symbol">(λ</a> <a id="15356" href="1Lab.Univalence.html#15356" class="Bound">e</a> <a id="15358" class="Symbol">→</a> <a id="15360" href="1Lab.Univalence.html#15333" class="Bound">P</a> <a id="15362" class="Symbol">(</a><a id="15363" href="1Lab.Univalence.html#15356" class="Bound">e</a> <a id="15365" class="Symbol">.</a><a id="15366" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="15369" class="Symbol">)</a> <a id="15371" class="Symbol">(</a><a id="15372" href="1Lab.Univalence.html#15356" class="Bound">e</a> <a id="15374" class="Symbol">.</a><a id="15375" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="15378" class="Symbol">))</a>
        <a id="15389" class="Symbol">(</a><a id="15390" href="1Lab.Univalence.html#14540" class="Function">EquivContr</a> <a id="15401" class="Symbol">_</a> <a id="15403" class="Symbol">.</a><a id="15404" href="1Lab.HLevel.html#1415" class="Field">isContr.paths</a> <a id="15418" class="Symbol">(_</a> <a id="15421" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="15423" href="1Lab.Univalence.html#15339" class="Bound">eqv</a><a id="15426" class="Symbol">))</a>
        <a id="15437" href="1Lab.Univalence.html#15335" class="Bound">pid</a>
</pre>
<p>Equivalence induction makes proving several properties about equivalences almost trivial. For example, if <code>f</code> is an equivalence, then so is its action on paths.</p>
<pre class="Agda"><a id="isEquiv→isEmbedding"></a><a id="15668" href="1Lab.Univalence.html#15668" class="Function">isEquiv→isEmbedding</a> <a id="15688" class="Symbol">:</a> <a id="15690" class="Symbol">∀</a> <a id="15692" class="Symbol">{</a><a id="15693" href="1Lab.Univalence.html#15693" class="Bound">ℓ</a><a id="15694" class="Symbol">}</a> <a id="15696" class="Symbol">{</a><a id="15697" href="1Lab.Univalence.html#15697" class="Bound">A</a> <a id="15699" href="1Lab.Univalence.html#15699" class="Bound">B</a> <a id="15701" class="Symbol">:</a> <a id="15703" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15708" href="1Lab.Univalence.html#15693" class="Bound">ℓ</a><a id="15709" class="Symbol">}</a>
                    <a id="15731" class="Symbol">→</a> <a id="15733" class="Symbol">(</a><a id="15734" href="1Lab.Univalence.html#15734" class="Bound">f</a> <a id="15736" class="Symbol">:</a> <a id="15738" href="1Lab.Univalence.html#15697" class="Bound">A</a> <a id="15740" class="Symbol">→</a> <a id="15742" href="1Lab.Univalence.html#15699" class="Bound">B</a><a id="15743" class="Symbol">)</a> <a id="15745" class="Symbol">→</a> <a id="15747" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="15755" href="1Lab.Univalence.html#15734" class="Bound">f</a>
                    <a id="15777" class="Symbol">→</a> <a id="15779" class="Symbol">{</a><a id="15780" href="1Lab.Univalence.html#15780" class="Bound">x</a> <a id="15782" href="1Lab.Univalence.html#15782" class="Bound">y</a> <a id="15784" class="Symbol">:</a> <a id="15786" href="1Lab.Univalence.html#15697" class="Bound">A</a><a id="15787" class="Symbol">}</a>
                    <a id="15809" class="Symbol">→</a> <a id="15811" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="15819" class="Symbol">(</a><a id="15820" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="15823" href="1Lab.Univalence.html#15734" class="Bound">f</a> <a id="15825" class="Symbol">{</a><a id="15826" class="Argument">x</a> <a id="15828" class="Symbol">=</a> <a id="15830" href="1Lab.Univalence.html#15780" class="Bound">x</a><a id="15831" class="Symbol">}</a> <a id="15833" class="Symbol">{</a><a id="15834" class="Argument">y</a> <a id="15836" class="Symbol">=</a> <a id="15838" href="1Lab.Univalence.html#15782" class="Bound">y</a><a id="15839" class="Symbol">})</a>
<a id="15842" href="1Lab.Univalence.html#15668" class="Function">isEquiv→isEmbedding</a> <a id="15862" href="1Lab.Univalence.html#15862" class="Bound">f</a> <a id="15864" href="1Lab.Univalence.html#15864" class="Bound">eqv</a> <a id="15868" class="Symbol">=</a>
  <a id="15872" href="1Lab.Univalence.html#15173" class="Function">EquivJ</a>
    <a id="15883" class="Symbol">(λ</a> <a id="15886" href="1Lab.Univalence.html#15886" class="Bound">B</a> <a id="15888" href="1Lab.Univalence.html#15888" class="Bound">e</a> <a id="15890" class="Symbol">→</a> <a id="15892" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="15900" class="Symbol">(</a><a id="15901" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="15904" class="Symbol">(</a><a id="15905" href="1Lab.Univalence.html#15888" class="Bound">e</a> <a id="15907" class="Symbol">.</a><a id="15908" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="15911" class="Symbol">)))</a>
    <a id="15919" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>
    <a id="15931" class="Symbol">(</a><a id="15932" href="1Lab.Univalence.html#15862" class="Bound">f</a> <a id="15934" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="15936" href="1Lab.Univalence.html#15864" class="Bound">eqv</a><a id="15939" class="Symbol">)</a>
</pre>
<p>The proof can be rendered in English roughly as follows:</p>
<blockquote>
<p>Suppose <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> <span class="Agda"><a href="1Lab.Equiv.html#2293" class="Record">is an equivalence</a></span>. We want to show that, for any choice of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x, y : A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><msub><mo stretchy="false">)</mo><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow></msub><mo>:</mo><mi>x</mi><mo>≡</mo><mi>y</mi><mo>→</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≡</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{ap}(f)_{x,y} : x \equiv y \to f(x) \equiv f(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> is an equivalence.</p>
<p>By <span class="Agda"><a href="1Lab.Univalence.html#15173" class="Function">induction</a></span>, it suffices to cover the case where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is the identity function.</p>
<p>But then, we have that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{ap}(\mathrm{id})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mclose">)</span></span></span></span> is <a href="1Lab.Path.html#ap-id">definitionally equal</a> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{id}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">id</span></span></span></span></span>, which is known to be <span class="Agda"><a href="1Lab.Equiv.html#2526" class="Function">an equivalence</a></span>. <span class="qed"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">■</mi></mrow><annotation encoding="application/x-tex">\blacksquare</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.675em;"></span><span class="mord amsrm">■</span></span></span></span></span></p>
</blockquote>
<h2 id="paths-over-ua">Paths over <code>ua</code></h2>
<p>A very useful theorem is a specialisation of <code class="sourceCode agda">PathP≡Path</code> to the case of paths dependent over <span class="Agda"><a href="1Lab.Univalence.html#7883" class="Function">ua</a></span>. This is proven using the following cubical helpers, which use the glueing primitives:</p>
<pre class="Agda"><a id="ua-unglue"></a><a id="16776" href="1Lab.Univalence.html#16776" class="Function">ua-unglue</a> <a id="16786" class="Symbol">:</a> <a id="16788" class="Symbol">∀</a> <a id="16790" class="Symbol">{</a><a id="16791" href="1Lab.Univalence.html#16791" class="Bound">A</a> <a id="16793" href="1Lab.Univalence.html#16793" class="Bound">B</a> <a id="16795" class="Symbol">:</a> <a id="16797" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="16802" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="16803" class="Symbol">}</a> <a id="16805" class="Symbol">(</a><a id="16806" href="1Lab.Univalence.html#16806" class="Bound">e</a> <a id="16808" class="Symbol">:</a> <a id="16810" href="1Lab.Univalence.html#16791" class="Bound">A</a> <a id="16812" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="16814" href="1Lab.Univalence.html#16793" class="Bound">B</a><a id="16815" class="Symbol">)</a> <a id="16817" class="Symbol">(</a><a id="16818" href="1Lab.Univalence.html#16818" class="Bound">i</a> <a id="16820" class="Symbol">:</a> <a id="16822" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="16823" class="Symbol">)</a> <a id="16825" class="Symbol">(</a><a id="16826" href="1Lab.Univalence.html#16826" class="Bound">x</a> <a id="16828" class="Symbol">:</a> <a id="16830" href="1Lab.Univalence.html#7883" class="Function">ua</a> <a id="16833" href="1Lab.Univalence.html#16806" class="Bound">e</a> <a id="16835" href="1Lab.Univalence.html#16818" class="Bound">i</a><a id="16836" class="Symbol">)</a>
            <a id="16850" class="Symbol">→</a> <a id="16852" href="1Lab.Univalence.html#16793" class="Bound">B</a> <a id="16854" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="16856" class="Symbol">_</a> <a id="16858" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="16860" class="Symbol">(λ</a> <a id="16863" class="Symbol">{</a> <a id="16865" class="Symbol">(</a><a id="16866" href="1Lab.Univalence.html#16818" class="Bound">i</a> <a id="16868" class="Symbol">=</a> <a id="16870" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="16872" class="Symbol">)</a> <a id="16874" class="Symbol">→</a> <a id="16876" href="1Lab.Univalence.html#16806" class="Bound">e</a> <a id="16878" class="Symbol">.</a><a id="16879" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="16883" href="1Lab.Univalence.html#16826" class="Bound">x</a> <a id="16885" class="Symbol">;</a> <a id="16887" class="Symbol">(</a><a id="16888" href="1Lab.Univalence.html#16818" class="Bound">i</a> <a id="16890" class="Symbol">=</a> <a id="16892" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="16894" class="Symbol">)</a> <a id="16896" class="Symbol">→</a> <a id="16898" href="1Lab.Univalence.html#16826" class="Bound">x</a> <a id="16900" class="Symbol">})</a> <a id="16903" href="1Lab.Path.html#27116" class="Function Operator">]</a>
<a id="16905" href="1Lab.Univalence.html#16776" class="Function">ua-unglue</a> <a id="16915" href="1Lab.Univalence.html#16915" class="Bound">e</a> <a id="16917" href="1Lab.Univalence.html#16917" class="Bound">i</a> <a id="16919" href="1Lab.Univalence.html#16919" class="Bound">x</a> <a id="16921" class="Symbol">=</a> <a id="16923" href="1Lab.Path.html#608" class="Postulate">inS</a> <a id="16927" class="Symbol">(</a><a id="16928" href="1Lab.Univalence.html#4499" class="Function">unglue</a> <a id="16935" class="Symbol">(</a><a id="16936" href="1Lab.Univalence.html#16917" class="Bound">i</a> <a id="16938" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="16940" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="16942" href="1Lab.Univalence.html#16917" class="Bound">i</a><a id="16943" class="Symbol">)</a> <a id="16945" href="1Lab.Univalence.html#16919" class="Bound">x</a><a id="16946" class="Symbol">)</a>

<a id="ua-glue"></a><a id="16949" href="1Lab.Univalence.html#16949" class="Function">ua-glue</a> <a id="16957" class="Symbol">:</a> <a id="16959" class="Symbol">∀</a> <a id="16961" class="Symbol">{</a><a id="16962" href="1Lab.Univalence.html#16962" class="Bound">A</a> <a id="16964" href="1Lab.Univalence.html#16964" class="Bound">B</a> <a id="16966" class="Symbol">:</a> <a id="16968" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="16973" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="16974" class="Symbol">}</a> <a id="16976" class="Symbol">(</a><a id="16977" href="1Lab.Univalence.html#16977" class="Bound">e</a> <a id="16979" class="Symbol">:</a> <a id="16981" href="1Lab.Univalence.html#16962" class="Bound">A</a> <a id="16983" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="16985" href="1Lab.Univalence.html#16964" class="Bound">B</a><a id="16986" class="Symbol">)</a> <a id="16988" class="Symbol">(</a><a id="16989" href="1Lab.Univalence.html#16989" class="Bound">i</a> <a id="16991" class="Symbol">:</a> <a id="16993" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="16994" class="Symbol">)</a> <a id="16996" class="Symbol">(</a><a id="16997" href="1Lab.Univalence.html#16997" class="Bound">x</a> <a id="16999" class="Symbol">:</a> <a id="17001" href="Agda.Primitive.Cubical.html#699" class="Primitive">Partial</a> <a id="17009" class="Symbol">(</a><a id="17010" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="17012" href="1Lab.Univalence.html#16989" class="Bound">i</a><a id="17013" class="Symbol">)</a> <a id="17015" href="1Lab.Univalence.html#16962" class="Bound">A</a><a id="17016" class="Symbol">)</a>
            <a id="17030" class="Symbol">(</a><a id="17031" href="1Lab.Univalence.html#17031" class="Bound">y</a> <a id="17033" class="Symbol">:</a> <a id="17035" href="1Lab.Univalence.html#16964" class="Bound">B</a> <a id="17037" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="17039" class="Symbol">_</a> <a id="17041" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="17043" class="Symbol">(λ</a> <a id="17046" class="Symbol">{</a> <a id="17048" class="Symbol">(</a><a id="17049" href="1Lab.Univalence.html#16989" class="Bound">i</a> <a id="17051" class="Symbol">=</a> <a id="17053" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="17055" class="Symbol">)</a> <a id="17057" class="Symbol">→</a> <a id="17059" href="1Lab.Univalence.html#16977" class="Bound">e</a> <a id="17061" class="Symbol">.</a><a id="17062" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="17066" class="Symbol">(</a><a id="17067" href="1Lab.Univalence.html#16997" class="Bound">x</a> <a id="17069" href="1Lab.Path.html#982" class="Postulate">1=1</a><a id="17072" class="Symbol">)</a> <a id="17074" class="Symbol">})</a> <a id="17077" href="1Lab.Path.html#27116" class="Function Operator">]</a><a id="17078" class="Symbol">)</a>
          <a id="17090" class="Symbol">→</a> <a id="17092" href="1Lab.Univalence.html#7883" class="Function">ua</a> <a id="17095" href="1Lab.Univalence.html#16977" class="Bound">e</a> <a id="17097" href="1Lab.Univalence.html#16989" class="Bound">i</a> <a id="17099" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="17101" class="Symbol">_</a> <a id="17103" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="17105" class="Symbol">(λ</a> <a id="17108" class="Symbol">{</a> <a id="17110" class="Symbol">(</a><a id="17111" href="1Lab.Univalence.html#16989" class="Bound">i</a> <a id="17113" class="Symbol">=</a> <a id="17115" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="17117" class="Symbol">)</a> <a id="17119" class="Symbol">→</a> <a id="17121" href="1Lab.Univalence.html#16997" class="Bound">x</a> <a id="17123" href="1Lab.Path.html#982" class="Postulate">1=1</a> <a id="17127" class="Symbol">;</a> <a id="17129" class="Symbol">(</a><a id="17130" href="1Lab.Univalence.html#16989" class="Bound">i</a> <a id="17132" class="Symbol">=</a> <a id="17134" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="17136" class="Symbol">)</a> <a id="17138" class="Symbol">→</a> <a id="17140" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="17145" href="1Lab.Univalence.html#17031" class="Bound">y</a> <a id="17147" class="Symbol">})</a> <a id="17150" href="1Lab.Path.html#27116" class="Function Operator">]</a>
<a id="17152" href="1Lab.Univalence.html#16949" class="Function">ua-glue</a> <a id="17160" href="1Lab.Univalence.html#17160" class="Bound">e</a> <a id="17162" href="1Lab.Univalence.html#17162" class="Bound">i</a> <a id="17164" href="1Lab.Univalence.html#17164" class="Bound">x</a> <a id="17166" href="1Lab.Univalence.html#17166" class="Bound">y</a> <a id="17168" class="Symbol">=</a> <a id="17170" href="1Lab.Path.html#608" class="Postulate">inS</a> <a id="17174" class="Symbol">(</a><a id="17175" href="1Lab.Univalence.html#2975" class="Primitive">prim^glue</a> <a id="17185" class="Symbol">{</a><a id="17186" class="Argument">φ</a> <a id="17188" class="Symbol">=</a> <a id="17190" href="1Lab.Univalence.html#17162" class="Bound">i</a> <a id="17192" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="17194" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="17196" href="1Lab.Univalence.html#17162" class="Bound">i</a><a id="17197" class="Symbol">}</a>
                                 <a id="17232" class="Symbol">(λ</a> <a id="17235" class="Symbol">{</a> <a id="17237" class="Symbol">(</a><a id="17238" href="1Lab.Univalence.html#17162" class="Bound">i</a> <a id="17240" class="Symbol">=</a> <a id="17242" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="17244" class="Symbol">)</a> <a id="17246" class="Symbol">→</a> <a id="17248" href="1Lab.Univalence.html#17164" class="Bound">x</a> <a id="17250" href="1Lab.Path.html#982" class="Postulate">1=1</a>
                                    <a id="17290" class="Symbol">;</a> <a id="17292" class="Symbol">(</a><a id="17293" href="1Lab.Univalence.html#17162" class="Bound">i</a> <a id="17295" class="Symbol">=</a> <a id="17297" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="17299" class="Symbol">)</a> <a id="17301" class="Symbol">→</a> <a id="17303" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="17308" href="1Lab.Univalence.html#17166" class="Bound">y</a> <a id="17310" class="Symbol">})</a>
                                 <a id="17346" class="Symbol">(</a><a id="17347" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="17352" href="1Lab.Univalence.html#17166" class="Bound">y</a><a id="17353" class="Symbol">))</a>
</pre>
<p>Fortunately, the types of these shrink a lot if the interval variable is factored in:</p>
<pre class="Agda"><a id="uaPathP→Path"></a><a id="17456" href="1Lab.Univalence.html#17456" class="Function">uaPathP→Path</a> <a id="17469" class="Symbol">:</a> <a id="17471" class="Symbol">∀</a> <a id="17473" class="Symbol">{</a><a id="17474" href="1Lab.Univalence.html#17474" class="Bound">A</a> <a id="17476" href="1Lab.Univalence.html#17476" class="Bound">B</a> <a id="17478" class="Symbol">:</a> <a id="17480" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="17485" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="17486" class="Symbol">}</a> <a id="17488" class="Symbol">(</a><a id="17489" href="1Lab.Univalence.html#17489" class="Bound">e</a> <a id="17491" class="Symbol">:</a> <a id="17493" href="1Lab.Univalence.html#17474" class="Bound">A</a> <a id="17495" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="17497" href="1Lab.Univalence.html#17476" class="Bound">B</a><a id="17498" class="Symbol">)</a> <a id="17500" class="Symbol">{</a><a id="17501" href="1Lab.Univalence.html#17501" class="Bound">x</a> <a id="17503" class="Symbol">:</a> <a id="17505" href="1Lab.Univalence.html#17474" class="Bound">A</a><a id="17506" class="Symbol">}</a> <a id="17508" class="Symbol">{</a><a id="17509" href="1Lab.Univalence.html#17509" class="Bound">y</a> <a id="17511" class="Symbol">:</a> <a id="17513" href="1Lab.Univalence.html#17476" class="Bound">B</a><a id="17514" class="Symbol">}</a>
             <a id="17529" class="Symbol">→</a> <a id="17531" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="17537" class="Symbol">(λ</a> <a id="17540" href="1Lab.Univalence.html#17540" class="Bound">i</a> <a id="17542" class="Symbol">→</a> <a id="17544" href="1Lab.Univalence.html#7883" class="Function">ua</a> <a id="17547" href="1Lab.Univalence.html#17489" class="Bound">e</a> <a id="17549" href="1Lab.Univalence.html#17540" class="Bound">i</a><a id="17550" class="Symbol">)</a> <a id="17552" href="1Lab.Univalence.html#17501" class="Bound">x</a> <a id="17554" href="1Lab.Univalence.html#17509" class="Bound">y</a>
             <a id="17569" class="Symbol">→</a> <a id="17571" href="1Lab.Univalence.html#17489" class="Bound">e</a> <a id="17573" class="Symbol">.</a><a id="17574" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="17578" href="1Lab.Univalence.html#17501" class="Bound">x</a> <a id="17580" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="17582" href="1Lab.Univalence.html#17509" class="Bound">y</a>
<a id="17584" href="1Lab.Univalence.html#17456" class="Function">uaPathP→Path</a> <a id="17597" href="1Lab.Univalence.html#17597" class="Bound">e</a> <a id="17599" href="1Lab.Univalence.html#17599" class="Bound">p</a> <a id="17601" href="1Lab.Univalence.html#17601" class="Bound">i</a> <a id="17603" class="Symbol">=</a> <a id="17605" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="17610" class="Symbol">(</a><a id="17611" href="1Lab.Univalence.html#16776" class="Function">ua-unglue</a> <a id="17621" href="1Lab.Univalence.html#17597" class="Bound">e</a> <a id="17623" href="1Lab.Univalence.html#17601" class="Bound">i</a> <a id="17625" class="Symbol">(</a><a id="17626" href="1Lab.Univalence.html#17599" class="Bound">p</a> <a id="17628" href="1Lab.Univalence.html#17601" class="Bound">i</a><a id="17629" class="Symbol">))</a>

<a id="Path→uaPathP"></a><a id="17633" href="1Lab.Univalence.html#17633" class="Function">Path→uaPathP</a> <a id="17646" class="Symbol">:</a> <a id="17648" class="Symbol">∀</a> <a id="17650" class="Symbol">{</a><a id="17651" href="1Lab.Univalence.html#17651" class="Bound">A</a> <a id="17653" href="1Lab.Univalence.html#17653" class="Bound">B</a> <a id="17655" class="Symbol">:</a> <a id="17657" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="17662" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="17663" class="Symbol">}</a> <a id="17665" class="Symbol">(</a><a id="17666" href="1Lab.Univalence.html#17666" class="Bound">e</a> <a id="17668" class="Symbol">:</a> <a id="17670" href="1Lab.Univalence.html#17651" class="Bound">A</a> <a id="17672" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="17674" href="1Lab.Univalence.html#17653" class="Bound">B</a><a id="17675" class="Symbol">)</a> <a id="17677" class="Symbol">{</a><a id="17678" href="1Lab.Univalence.html#17678" class="Bound">x</a> <a id="17680" class="Symbol">:</a> <a id="17682" href="1Lab.Univalence.html#17651" class="Bound">A</a><a id="17683" class="Symbol">}</a> <a id="17685" class="Symbol">{</a><a id="17686" href="1Lab.Univalence.html#17686" class="Bound">y</a> <a id="17688" class="Symbol">:</a> <a id="17690" href="1Lab.Univalence.html#17653" class="Bound">B</a><a id="17691" class="Symbol">}</a>
             <a id="17706" class="Symbol">→</a> <a id="17708" href="1Lab.Univalence.html#17666" class="Bound">e</a> <a id="17710" class="Symbol">.</a><a id="17711" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="17715" href="1Lab.Univalence.html#17678" class="Bound">x</a> <a id="17717" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="17719" href="1Lab.Univalence.html#17686" class="Bound">y</a>
             <a id="17734" class="Symbol">→</a> <a id="17736" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="17742" class="Symbol">(λ</a> <a id="17745" href="1Lab.Univalence.html#17745" class="Bound">i</a> <a id="17747" class="Symbol">→</a> <a id="17749" href="1Lab.Univalence.html#7883" class="Function">ua</a> <a id="17752" href="1Lab.Univalence.html#17666" class="Bound">e</a> <a id="17754" href="1Lab.Univalence.html#17745" class="Bound">i</a><a id="17755" class="Symbol">)</a> <a id="17757" href="1Lab.Univalence.html#17678" class="Bound">x</a> <a id="17759" href="1Lab.Univalence.html#17686" class="Bound">y</a>
<a id="17761" href="1Lab.Univalence.html#17633" class="Function">Path→uaPathP</a> <a id="17774" href="1Lab.Univalence.html#17774" class="Bound">e</a> <a id="17776" class="Symbol">{</a><a id="17777" class="Argument">x</a> <a id="17779" class="Symbol">=</a> <a id="17781" href="1Lab.Univalence.html#17781" class="Bound">x</a><a id="17782" class="Symbol">}</a> <a id="17784" href="1Lab.Univalence.html#17784" class="Bound">p</a> <a id="17786" href="1Lab.Univalence.html#17786" class="Bound">i</a> <a id="17788" class="Symbol">=</a> <a id="17790" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="17795" class="Symbol">(</a><a id="17796" href="1Lab.Univalence.html#16949" class="Function">ua-glue</a> <a id="17804" href="1Lab.Univalence.html#17774" class="Bound">e</a> <a id="17806" href="1Lab.Univalence.html#17786" class="Bound">i</a> <a id="17808" class="Symbol">(λ</a> <a id="17811" class="Symbol">{</a> <a id="17813" class="Symbol">(</a><a id="17814" href="1Lab.Univalence.html#17786" class="Bound">i</a> <a id="17816" class="Symbol">=</a> <a id="17818" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="17820" class="Symbol">)</a> <a id="17822" class="Symbol">→</a> <a id="17824" href="1Lab.Univalence.html#17781" class="Bound">x</a> <a id="17826" class="Symbol">})</a> <a id="17829" class="Symbol">(</a><a id="17830" href="1Lab.Path.html#608" class="Postulate">inS</a> <a id="17834" class="Symbol">(</a><a id="17835" href="1Lab.Univalence.html#17784" class="Bound">p</a> <a id="17837" href="1Lab.Univalence.html#17786" class="Bound">i</a><a id="17838" class="Symbol">)))</a>
</pre>
<p>These functions are definitional inverses, and thus they provide a characterisation of <code>PathP (ua f)</code> in terms of non-dependent paths:</p>
<pre class="Agda"><a id="uaPathP≃Path"></a><a id="17991" href="1Lab.Univalence.html#17991" class="Function">uaPathP≃Path</a> <a id="18004" class="Symbol">:</a> <a id="18006" class="Symbol">∀</a> <a id="18008" class="Symbol">{</a><a id="18009" href="1Lab.Univalence.html#18009" class="Bound">A</a> <a id="18011" href="1Lab.Univalence.html#18011" class="Bound">B</a> <a id="18013" class="Symbol">:</a> <a id="18015" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="18020" href="1Lab.Univalence.html#2809" class="Generalizable">ℓ</a><a id="18021" class="Symbol">}</a> <a id="18023" class="Symbol">(</a><a id="18024" href="1Lab.Univalence.html#18024" class="Bound">e</a> <a id="18026" class="Symbol">:</a> <a id="18028" href="1Lab.Univalence.html#18009" class="Bound">A</a> <a id="18030" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="18032" href="1Lab.Univalence.html#18011" class="Bound">B</a><a id="18033" class="Symbol">)</a> <a id="18035" class="Symbol">{</a><a id="18036" href="1Lab.Univalence.html#18036" class="Bound">x</a> <a id="18038" class="Symbol">:</a> <a id="18040" href="1Lab.Univalence.html#18009" class="Bound">A</a><a id="18041" class="Symbol">}</a> <a id="18043" class="Symbol">{</a><a id="18044" href="1Lab.Univalence.html#18044" class="Bound">y</a> <a id="18046" class="Symbol">:</a> <a id="18048" href="1Lab.Univalence.html#18011" class="Bound">B</a><a id="18049" class="Symbol">}</a>
             <a id="18064" class="Symbol">→</a> <a id="18066" class="Symbol">(</a><a id="18067" href="1Lab.Univalence.html#18024" class="Bound">e</a> <a id="18069" class="Symbol">.</a><a id="18070" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18074" href="1Lab.Univalence.html#18036" class="Bound">x</a> <a id="18076" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18078" href="1Lab.Univalence.html#18044" class="Bound">y</a><a id="18079" class="Symbol">)</a> <a id="18081" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="18083" class="Symbol">(</a><a id="18084" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="18090" class="Symbol">(λ</a> <a id="18093" href="1Lab.Univalence.html#18093" class="Bound">i</a> <a id="18095" class="Symbol">→</a> <a id="18097" href="1Lab.Univalence.html#7883" class="Function">ua</a> <a id="18100" href="1Lab.Univalence.html#18024" class="Bound">e</a> <a id="18102" href="1Lab.Univalence.html#18093" class="Bound">i</a><a id="18103" class="Symbol">)</a> <a id="18105" href="1Lab.Univalence.html#18036" class="Bound">x</a> <a id="18107" href="1Lab.Univalence.html#18044" class="Bound">y</a><a id="18108" class="Symbol">)</a>
<a id="18110" href="1Lab.Univalence.html#17991" class="Function">uaPathP≃Path</a> <a id="18123" href="1Lab.Univalence.html#18123" class="Bound">eqv</a> <a id="18127" class="Symbol">.</a><a id="18128" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18132" class="Symbol">=</a> <a id="18134" href="1Lab.Univalence.html#17633" class="Function">Path→uaPathP</a> <a id="18147" href="1Lab.Univalence.html#18123" class="Bound">eqv</a>
<a id="18151" href="1Lab.Univalence.html#17991" class="Function">uaPathP≃Path</a> <a id="18164" href="1Lab.Univalence.html#18164" class="Bound">eqv</a> <a id="18168" class="Symbol">.</a><a id="18169" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18173" class="Symbol">.</a><a id="18174" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a id="18180" href="1Lab.Univalence.html#18180" class="Bound">y</a> <a id="18182" class="Symbol">.</a><a id="18183" href="1Lab.HLevel.html#1400" class="Field">centre</a> <a id="18190" class="Symbol">=</a> <a id="18192" href="1Lab.Equiv.html#2799" class="Function">strict-fibres</a> <a id="18206" class="Symbol">(</a><a id="18207" href="1Lab.Univalence.html#17456" class="Function">uaPathP→Path</a> <a id="18220" href="1Lab.Univalence.html#18164" class="Bound">eqv</a><a id="18223" class="Symbol">)</a> <a id="18225" href="1Lab.Univalence.html#18180" class="Bound">y</a> <a id="18227" class="Symbol">.</a><a id="18228" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
<a id="18232" href="1Lab.Univalence.html#17991" class="Function">uaPathP≃Path</a> <a id="18245" href="1Lab.Univalence.html#18245" class="Bound">eqv</a> <a id="18249" class="Symbol">.</a><a id="18250" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18254" class="Symbol">.</a><a id="18255" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a id="18261" href="1Lab.Univalence.html#18261" class="Bound">y</a> <a id="18263" class="Symbol">.</a><a id="18264" href="1Lab.HLevel.html#1415" class="Field">paths</a> <a id="18270" class="Symbol">=</a> <a id="18272" href="1Lab.Equiv.html#2799" class="Function">strict-fibres</a> <a id="18286" class="Symbol">(</a><a id="18287" href="1Lab.Univalence.html#17456" class="Function">uaPathP→Path</a> <a id="18300" href="1Lab.Univalence.html#18245" class="Bound">eqv</a><a id="18303" class="Symbol">)</a> <a id="18305" href="1Lab.Univalence.html#18261" class="Bound">y</a> <a id="18307" class="Symbol">.</a><a id="18308" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a>
</pre>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr></hr>
<ol>
<li id="fn1" role="doc-endnote"><p>Pardon the pun.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Not the fundamental theorem of engineering!<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </article>
</div>

</main>
</body>
</html>