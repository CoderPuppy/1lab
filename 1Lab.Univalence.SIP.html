<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>

<head>
  <meta charset="utf-8"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
  <meta name="keywords" content="Agda,categories,topos"></meta>

  <title>1Lab.Univalence.SIP - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css"></link>
  <link rel="stylesheet" href="/css/katex.min.css"></link>
  <link rel="stylesheet" href="/css/agda-cats.css"></link>

  <meta name="twitter:card" content="summary"></meta>
  <meta name="twitter:title" content="1Lab.Univalence.SIP - 1Lab"></meta>
  <meta name="twitter:image" content="https://cubical.1lab.dev/static/cube-128x.png"></meta>

  <meta name="og:title" content="1Lab.Univalence.SIP - 1Lab"></meta>
  <meta name="og:image" content="https://cubical.1lab.dev/static/cube-128x.png"></meta>
  <meta name="og:site-name" content="The 1Lab"></meta>
  <meta name="og:type" content="website"></meta>
    <meta name="og:description" content="&lt;p&gt;The structure identity principle characterises equality in “types-with-structure” as being exactly the equivalences that preserve that structure. In a sense, it augments univalence with the notion of preservation of structure.&lt;/p&gt;"></meta>
  <meta name="twitter:description" content="&lt;p&gt;The structure identity principle characterises equality in “types-with-structure” as being exactly the equivalences that preserve that structure. In a sense, it augments univalence with the notion of preservation of structure.&lt;/p&gt;"></meta>
  
  <script src="/equations.js" type="text/javascript"></script> 
  <script src="/highlight-hover.js" type="text/javascript"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0;">
                <a class="Module">1Lab.Univalence.SIP</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto; height: 32px;"></img>
      
      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr></hr>
      <ul class="incremental">
      <li><a href="#structure-identity-principle">Structure Identity Principle</a>
      <ul class="incremental">
      <li><a href="#the-principle">The principle</a></li>
      </ul></li>
      <li><a href="#structure-combinators">Structure Combinators</a>
      <ul class="incremental">
      <li><a href="#example-infty-magmas">Example: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magmas</a></li>
      </ul></li>
      <li><a href="#transport-structures">Transport Structures</a></li>
      <li><a href="#adding-axioms">Adding Axioms</a></li>
      <li><a href="#a-language-for-structures">A Language for Structures</a>
      <ul class="incremental">
      <li><a href="#descriptions-of-structures">Descriptions of Structures</a></li>
      </ul></li>
      </ul>
      <hr></hr>

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr></hr>

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/e8a5036abd8b717920913d468aa0218168c894d1/src/1Lab/Univalence/SIP.lagda.md">link to source</a> <br />
      </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="268" class="Keyword">open</a> <a id="273" class="Keyword">import</a> <a id="280" href="1Lab.Equiv.Embedding.html" class="Module">1Lab.Equiv.Embedding</a>
<a id="301" class="Keyword">open</a> <a id="306" class="Keyword">import</a> <a id="313" href="1Lab.Path.Groupoid.html" class="Module">1Lab.Path.Groupoid</a>
<a id="332" class="Keyword">open</a> <a id="337" class="Keyword">import</a> <a id="344" href="1Lab.Type.Sigma.html" class="Module">1Lab.Type.Sigma</a>
<a id="360" class="Keyword">open</a> <a id="365" class="Keyword">import</a> <a id="372" href="1Lab.Univalence.html" class="Module">1Lab.Univalence</a>
<a id="388" class="Keyword">open</a> <a id="393" class="Keyword">import</a> <a id="400" href="1Lab.Type.Pi.html" class="Module">1Lab.Type.Pi</a>
<a id="413" class="Keyword">open</a> <a id="418" class="Keyword">import</a> <a id="425" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="437" class="Keyword">open</a> <a id="442" class="Keyword">import</a> <a id="449" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a>
<a id="460" class="Keyword">open</a> <a id="465" class="Keyword">import</a> <a id="472" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="482" class="Keyword">open</a> <a id="487" class="Keyword">import</a> <a id="494" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="505" class="Keyword">module</a> <a id="512" href="1Lab.Univalence.SIP.html" class="Module">1Lab.Univalence.SIP</a> <a id="532" class="Keyword">where</a>
</pre>
<h1 id="structure-identity-principle">Structure Identity Principle</h1>
<p>In mathematics in general, it’s often <em>notationally</em> helpful to identify isomorphic <em>structures</em> (e.g.: groups) in a proof. However, when this mathematics is done using material set theory as a foundations, this identification is merely a shorthand — nothing <em>prevents</em> you from distinguishing isomorphic groups in ZFC by, for instance, asking about membership of a particular set in the underlying set of each group.</p>
<p>In univalent mathematics, it’s a theorem that no family of types can distinguish between isomorphic structures. <a href="1Lab.Univalence.html">Univalence</a> is this statement, but for <em>types</em>. For structures built out of types, it seems like we would need a bit more power, but in reality, we don’t!</p>
<p>“Structure Identity Principle” is the name for several related theorems in Homotopy Type Theory, which generically say that “paths on a structure are isomorphisms of that structure”.</p>
<p>For instance, the version in the HoTT Book says that if a structure <code>S</code> on the objects of a univalent category <code>S</code> can be described in a certain way, then the category of <code>S</code>-structured objects of <code>C</code> is univalent. As a benefit, the Book version of the SIP characterises the <em>homomorphisms</em> of <code>S</code>-structures, not just the <em>isomorphisms</em>. As a downside, it only applies to <a href="1Lab.HLevel.html#3342">set-level</a> structures.</p>
<pre class="Agda"><a id="1968" class="Keyword">record</a>
  <a id="Structure"></a><a id="1977" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="1987" class="Symbol">{</a><a id="1988" href="1Lab.Univalence.SIP.html#1988" class="Bound">ℓ₁</a> <a id="1991" href="1Lab.Univalence.SIP.html#1991" class="Bound">ℓ₂</a><a id="1993" class="Symbol">}</a> <a id="1995" class="Symbol">(</a><a id="1996" href="1Lab.Univalence.SIP.html#1996" class="Bound">ℓ₃</a> <a id="1999" class="Symbol">:</a> <a id="2001" class="Symbol">_)</a> <a id="2004" class="Symbol">(</a><a id="2005" href="1Lab.Univalence.SIP.html#2005" class="Bound">S</a> <a id="2007" class="Symbol">:</a> <a id="2009" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2014" href="1Lab.Univalence.SIP.html#1988" class="Bound">ℓ₁</a> <a id="2017" class="Symbol">→</a> <a id="2019" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2024" href="1Lab.Univalence.SIP.html#1991" class="Bound">ℓ₂</a><a id="2026" class="Symbol">)</a> <a id="2028" class="Symbol">:</a> <a id="2030" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2035" class="Symbol">(</a><a id="2036" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="2041" class="Symbol">(</a><a id="2042" href="1Lab.Univalence.SIP.html#1988" class="Bound">ℓ₁</a> <a id="2045" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="2047" href="1Lab.Univalence.SIP.html#1996" class="Bound">ℓ₃</a><a id="2049" class="Symbol">)</a> <a id="2051" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="2053" href="1Lab.Univalence.SIP.html#1991" class="Bound">ℓ₂</a><a id="2055" class="Symbol">)</a>
  <a id="2059" class="Keyword">where</a>

  <a id="2068" class="Keyword">constructor</a> <a id="HomT→Str"></a><a id="2080" href="1Lab.Univalence.SIP.html#2080" class="InductiveConstructor">HomT→Str</a>
  <a id="2091" class="Keyword">field</a>
</pre>
<p>The material on this page, especially the definition of <span class="Agda"><a href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a></span> and <span class="Agda"><a href="1Lab.Univalence.SIP.html#14134" class="Function">isTransportStr</a></span>, is adapted from <cite><a href="https://arxiv.org/abs/2009.05547">Internalizing Representation Independence with Univalence</a></cite>. The SIP formalised here says, very generically, that a <span class="Agda"><a href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a></span> is a family of types <code>S : Type → Type</code>, and a <span class="Agda"><a href="1Lab.Univalence.SIP.html#3349" class="Function">type with</a></span> structure is an inhabitant of the <a href="1Lab.Type.html#1649">total space</a> <code>Σ S</code>.</p>
<p>What sets a <span class="Agda"><a href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a></span> apart from a type family is a notion of <em>homomorphic equivalence</em>: Given an equivalence of the underlying types, the predicate <code>is-hom (A , x) (B , y) eqv</code> should represent what it means for <code>eqv</code> to take the <code>x</code>-structure on <code>A</code> to the <code>y</code>-structure on <code>B</code>.</p>
<pre class="Agda">   <a id="Structure.is-hom"></a><a id="2905" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="2912" class="Symbol">:</a> <a id="2914" class="Symbol">(</a><a id="2915" href="1Lab.Univalence.SIP.html#2915" class="Bound">A</a> <a id="2917" href="1Lab.Univalence.SIP.html#2917" class="Bound">B</a> <a id="2919" class="Symbol">:</a> <a id="2921" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="2923" href="1Lab.Univalence.SIP.html#2005" class="Bound">S</a><a id="2924" class="Symbol">)</a> <a id="2926" class="Symbol">→</a> <a id="2928" class="Symbol">(</a><a id="2929" href="1Lab.Univalence.SIP.html#2915" class="Bound">A</a> <a id="2931" class="Symbol">.</a><a id="2932" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="2936" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="2938" href="1Lab.Univalence.SIP.html#2917" class="Bound">B</a> <a id="2940" class="Symbol">.</a><a id="2941" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="2944" class="Symbol">)</a> <a id="2946" class="Symbol">→</a> <a id="2948" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2953" href="1Lab.Univalence.SIP.html#1996" class="Bound">ℓ₃</a>
</pre>
<p>As a grounding example, consider equipping types with group structure: If <code>(A , _⋆_)</code> and <code>(B , _*_)</code> are types with group structure (with many fields omitted!), and <code>f : A → B</code> is the underlying map of an equivalence <code>A ≃ B</code>, then <span class="Agda"><a href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a></span> would be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mo stretchy="false">(</mo><mi>x</mi><mi>y</mi><mspace></mspace><mspace width="0.1111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"></mspace><mi>A</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>⋆</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall (x y\colon A) f(x \star y) = f(x) * f(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋆</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> - the “usual” definition of group homomorphism.</p>
<pre class="Agda"><a id="3326" class="Keyword">open</a> <a id="3331" href="1Lab.Univalence.SIP.html#1977" class="Module">Structure</a> <a id="3341" class="Keyword">public</a>

<a id="TypeWith"></a><a id="3349" href="1Lab.Univalence.SIP.html#3349" class="Function">TypeWith</a> <a id="3358" class="Symbol">:</a> <a id="3360" class="Symbol">∀</a> <a id="3362" class="Symbol">{</a><a id="3363" href="1Lab.Univalence.SIP.html#3363" class="Bound">ℓ</a> <a id="3365" href="1Lab.Univalence.SIP.html#3365" class="Bound">ℓ₁</a> <a id="3368" href="1Lab.Univalence.SIP.html#3368" class="Bound">ℓ₂</a><a id="3370" class="Symbol">}</a> <a id="3372" class="Symbol">{</a><a id="3373" href="1Lab.Univalence.SIP.html#3373" class="Bound">S</a> <a id="3375" class="Symbol">:</a> <a id="3377" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3382" href="1Lab.Univalence.SIP.html#3363" class="Bound">ℓ</a> <a id="3384" class="Symbol">→</a> <a id="3386" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3391" href="1Lab.Univalence.SIP.html#3365" class="Bound">ℓ₁</a><a id="3393" class="Symbol">}</a> <a id="3395" class="Symbol">→</a> <a id="3397" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="3407" href="1Lab.Univalence.SIP.html#3368" class="Bound">ℓ₂</a> <a id="3410" href="1Lab.Univalence.SIP.html#3373" class="Bound">S</a> <a id="3412" class="Symbol">→</a> <a id="3414" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3419" class="Symbol">_</a>
<a id="3421" href="1Lab.Univalence.SIP.html#3349" class="Function">TypeWith</a> <a id="3430" class="Symbol">{</a><a id="3431" class="Argument">S</a> <a id="3433" class="Symbol">=</a> <a id="3435" href="1Lab.Univalence.SIP.html#3435" class="Bound">S</a><a id="3436" class="Symbol">}</a> <a id="3438" class="Symbol">_</a> <a id="3440" class="Symbol">=</a> <a id="3442" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="3444" href="1Lab.Univalence.SIP.html#3435" class="Bound">S</a>
</pre>
<!--
<pre class="Agda"><a id="3464" class="Keyword">private</a> <a id="3472" class="Keyword">variable</a>
  <a id="3483" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="3485" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a> <a id="3488" href="1Lab.Univalence.SIP.html#3488" class="Generalizable">ℓ₂</a> <a id="3491" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">ℓ₃</a> <a id="3494" class="Symbol">:</a> <a id="3496" href="Agda.Primitive.html#597" class="Postulate">Level</a>
  <a id="3504" href="1Lab.Univalence.SIP.html#3504" class="Generalizable">A</a> <a id="3506" class="Symbol">:</a> <a id="3508" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3513" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a>
  <a id="3517" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="3519" href="1Lab.Univalence.SIP.html#3519" class="Generalizable">T</a> <a id="3521" class="Symbol">:</a> <a id="3523" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3528" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="3530" class="Symbol">→</a> <a id="3532" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3537" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a>
</pre>-->
<p>A structure is said to be <strong>univalent</strong> if a homomorphic equivalence of structures <code>A</code>, <code>B</code> induces a path of the structures, over the univalence axiom — that is, if <span class="Agda"><a href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a></span> agrees with what it means for “S X” and “S Y” to be equal, where this equality is dependent on one induced by univalence.</p>
<pre class="Agda"><a id="isUnivalent"></a><a id="3864" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="3876" class="Symbol">:</a> <a id="3878" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="3888" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="3890" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="3892" class="Symbol">→</a> <a id="3894" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3899" class="Symbol">_</a>
<a id="3901" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="3913" class="Symbol">{</a><a id="3914" class="Argument">S</a> <a id="3916" class="Symbol">=</a> <a id="3918" href="1Lab.Univalence.SIP.html#3918" class="Bound">S</a><a id="3919" class="Symbol">}</a> <a id="3921" href="1Lab.Univalence.SIP.html#3921" class="Bound">ι</a> <a id="3923" class="Symbol">=</a>
  <a id="3927" class="Symbol">∀</a> <a id="3929" class="Symbol">{</a><a id="3930" href="1Lab.Univalence.SIP.html#3930" class="Bound">X</a> <a id="3932" href="1Lab.Univalence.SIP.html#3932" class="Bound">Y</a><a id="3933" class="Symbol">}</a>
  <a id="3937" class="Symbol">→</a> <a id="3939" class="Symbol">(</a><a id="3940" href="1Lab.Univalence.SIP.html#3940" class="Bound">f</a> <a id="3942" class="Symbol">:</a> <a id="3944" href="1Lab.Univalence.SIP.html#3930" class="Bound">X</a> <a id="3946" class="Symbol">.</a><a id="3947" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="3951" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="3953" href="1Lab.Univalence.SIP.html#3932" class="Bound">Y</a> <a id="3955" class="Symbol">.</a><a id="3956" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="3959" class="Symbol">)</a>
  <a id="3963" class="Symbol">→</a> <a id="3965" href="1Lab.Univalence.SIP.html#3921" class="Bound">ι</a> <a id="3967" class="Symbol">.</a><a id="3968" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="3975" href="1Lab.Univalence.SIP.html#3930" class="Bound">X</a> <a id="3977" href="1Lab.Univalence.SIP.html#3932" class="Bound">Y</a> <a id="3979" href="1Lab.Univalence.SIP.html#3940" class="Bound">f</a> <a id="3981" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="3983" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="3989" class="Symbol">(λ</a> <a id="3992" href="1Lab.Univalence.SIP.html#3992" class="Bound">i</a> <a id="3994" class="Symbol">→</a> <a id="3996" href="1Lab.Univalence.SIP.html#3918" class="Bound">S</a> <a id="3998" class="Symbol">(</a><a id="3999" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="4002" href="1Lab.Univalence.SIP.html#3940" class="Bound">f</a> <a id="4004" href="1Lab.Univalence.SIP.html#3992" class="Bound">i</a><a id="4005" class="Symbol">))</a> <a id="4008" class="Symbol">(</a><a id="4009" href="1Lab.Univalence.SIP.html#3930" class="Bound">X</a> <a id="4011" class="Symbol">.</a><a id="4012" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="4015" class="Symbol">)</a> <a id="4017" class="Symbol">(</a><a id="4018" href="1Lab.Univalence.SIP.html#3932" class="Bound">Y</a> <a id="4020" class="Symbol">.</a><a id="4021" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="4024" class="Symbol">)</a>
</pre>
<p>The notation <span class="Agda"><a href="1Lab.Univalence.SIP.html#4237" class="Function Operator">A ≃[ σ ] B</a></span> stands for the type of σ-homomorphic equivalences, i.e. those equivalences of the types underlying <code>A</code> and <code>B</code> that σ identifies as being homomorphic.</p>
<pre class="Agda"><a id="_≃[_]_"></a><a id="4237" href="1Lab.Univalence.SIP.html#4237" class="Function Operator">_≃[_]_</a> <a id="4244" class="Symbol">:</a> <a id="4246" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="4248" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="4250" class="Symbol">→</a> <a id="4252" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="4262" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="4264" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="4266" class="Symbol">→</a> <a id="4268" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="4270" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="4272" class="Symbol">→</a> <a id="4274" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4279" class="Symbol">_</a>
<a id="4281" href="1Lab.Univalence.SIP.html#4281" class="Bound">A</a> <a id="4283" href="1Lab.Univalence.SIP.html#4237" class="Function Operator">≃[</a> <a id="4286" href="1Lab.Univalence.SIP.html#4286" class="Bound">σ</a> <a id="4288" href="1Lab.Univalence.SIP.html#4237" class="Function Operator">]</a> <a id="4290" href="1Lab.Univalence.SIP.html#4290" class="Bound">B</a> <a id="4292" class="Symbol">=</a>
  <a id="4296" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="4299" href="1Lab.Univalence.SIP.html#4299" class="Bound">f</a> <a id="4301" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="4303" href="1Lab.Univalence.SIP.html#4281" class="Bound">A</a> <a id="4305" class="Symbol">.</a><a id="4306" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="4310" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="4312" href="1Lab.Univalence.SIP.html#4290" class="Bound">B</a> <a id="4314" class="Symbol">.</a><a id="4315" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="4319" href="1Lab.Type.html#1563" class="Function">]</a>
   <a id="4324" class="Symbol">(</a><a id="4325" href="1Lab.Univalence.SIP.html#4286" class="Bound">σ</a> <a id="4327" class="Symbol">.</a><a id="4328" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="4335" href="1Lab.Univalence.SIP.html#4281" class="Bound">A</a> <a id="4337" href="1Lab.Univalence.SIP.html#4290" class="Bound">B</a> <a id="4339" href="1Lab.Univalence.SIP.html#4299" class="Bound">f</a><a id="4340" class="Symbol">)</a>
</pre>
<h2 id="the-principle">The principle</h2>
<p>The <strong>structure identity principle</strong> says that, if <code>S</code> is a <span class="Agda"><a href="1Lab.Univalence.SIP.html#3864" class="Function">univalent structure</a></span>, then the path space of <code>Σ S</code> is equivalent to the space of S-homomorphic equivalences of types. Again using groups as a grounding example: equality of groups is group isomorphism.</p>
<pre class="Agda"><a id="SIP"></a><a id="4662" href="1Lab.Univalence.SIP.html#4662" class="Function">SIP</a> <a id="4666" class="Symbol">:</a> <a id="4668" class="Symbol">{</a><a id="4669" href="1Lab.Univalence.SIP.html#4669" class="Bound">σ</a> <a id="4671" class="Symbol">:</a> <a id="4673" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="4683" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="4685" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a><a id="4686" class="Symbol">}</a> <a id="4688" class="Symbol">→</a> <a id="4690" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="4702" href="1Lab.Univalence.SIP.html#4669" class="Bound">σ</a> <a id="4704" class="Symbol">→</a> <a id="4706" class="Symbol">{</a><a id="4707" href="1Lab.Univalence.SIP.html#4707" class="Bound">X</a> <a id="4709" href="1Lab.Univalence.SIP.html#4709" class="Bound">Y</a> <a id="4711" class="Symbol">:</a> <a id="4713" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="4715" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a><a id="4716" class="Symbol">}</a> <a id="4718" class="Symbol">→</a> <a id="4720" class="Symbol">(</a><a id="4721" href="1Lab.Univalence.SIP.html#4707" class="Bound">X</a> <a id="4723" href="1Lab.Univalence.SIP.html#4237" class="Function Operator">≃[</a> <a id="4726" href="1Lab.Univalence.SIP.html#4669" class="Bound">σ</a> <a id="4728" href="1Lab.Univalence.SIP.html#4237" class="Function Operator">]</a> <a id="4730" href="1Lab.Univalence.SIP.html#4709" class="Bound">Y</a><a id="4731" class="Symbol">)</a> <a id="4733" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="4735" class="Symbol">(</a><a id="4736" href="1Lab.Univalence.SIP.html#4707" class="Bound">X</a> <a id="4738" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4740" href="1Lab.Univalence.SIP.html#4709" class="Bound">Y</a><a id="4741" class="Symbol">)</a>
<a id="4743" href="1Lab.Univalence.SIP.html#4662" class="Function">SIP</a> <a id="4747" class="Symbol">{</a><a id="4748" class="Argument">S</a> <a id="4750" class="Symbol">=</a> <a id="4752" href="1Lab.Univalence.SIP.html#4752" class="Bound">S</a><a id="4753" class="Symbol">}</a> <a id="4755" class="Symbol">{</a><a id="4756" class="Argument">σ</a> <a id="4758" class="Symbol">=</a> <a id="4760" href="1Lab.Univalence.SIP.html#4760" class="Bound">σ</a><a id="4761" class="Symbol">}</a> <a id="4763" href="1Lab.Univalence.SIP.html#4763" class="Bound">is-univ</a> <a id="4771" class="Symbol">{</a><a id="4772" href="1Lab.Univalence.SIP.html#4772" class="Bound">X</a><a id="4773" class="Symbol">}</a> <a id="4775" class="Symbol">{</a><a id="4776" href="1Lab.Univalence.SIP.html#4776" class="Bound">Y</a><a id="4777" class="Symbol">}</a> <a id="4779" class="Symbol">=</a>
  <a id="4783" href="1Lab.Univalence.SIP.html#4772" class="Bound">X</a> <a id="4785" href="1Lab.Univalence.SIP.html#4237" class="Function Operator">≃[</a> <a id="4788" href="1Lab.Univalence.SIP.html#4760" class="Bound">σ</a> <a id="4790" href="1Lab.Univalence.SIP.html#4237" class="Function Operator">]</a> <a id="4792" href="1Lab.Univalence.SIP.html#4776" class="Bound">Y</a>                                                       <a id="4848" href="1Lab.Equiv.html#22946" class="Function Operator">≃⟨⟩</a>
  <a id="4854" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="4857" href="1Lab.Univalence.SIP.html#4857" class="Bound">e</a> <a id="4859" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="4861" href="1Lab.Univalence.SIP.html#4772" class="Bound">X</a> <a id="4863" class="Symbol">.</a><a id="4864" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="4868" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="4870" href="1Lab.Univalence.SIP.html#4776" class="Bound">Y</a> <a id="4872" class="Symbol">.</a><a id="4873" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="4877" href="1Lab.Type.html#1563" class="Function">]</a> <a id="4879" class="Symbol">(</a><a id="4880" href="1Lab.Univalence.SIP.html#4760" class="Bound">σ</a> <a id="4882" class="Symbol">.</a><a id="4883" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="4890" href="1Lab.Univalence.SIP.html#4772" class="Bound">X</a> <a id="4892" href="1Lab.Univalence.SIP.html#4776" class="Bound">Y</a> <a id="4894" href="1Lab.Univalence.SIP.html#4857" class="Bound">e</a><a id="4895" class="Symbol">)</a>                       <span class="reasoning-step"><span class="as-written Function Operator"><a id="4919" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a id="4922" href="1Lab.Type.Sigma.html#2031" class="Function">Σ-ap</a> <a id="4927" class="Symbol">(</a><a id="4928" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="4931" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4933" href="1Lab.Univalence.html#16792" class="Function">univalence⁻¹</a><a id="4945" class="Symbol">)</a> <a id="4947" href="1Lab.Univalence.SIP.html#4763" class="Bound">is-univ</a> <a id="4955" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="4959" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="4962" href="1Lab.Univalence.SIP.html#4962" class="Bound">p</a> <a id="4964" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="4966" href="1Lab.Univalence.SIP.html#4772" class="Bound">X</a> <a id="4968" class="Symbol">.</a><a id="4969" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="4973" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4975" href="1Lab.Univalence.SIP.html#4776" class="Bound">Y</a> <a id="4977" class="Symbol">.</a><a id="4978" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="4982" href="1Lab.Type.html#1563" class="Function">]</a> <a id="4984" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="4990" class="Symbol">(λ</a> <a id="4993" href="1Lab.Univalence.SIP.html#4993" class="Bound">i</a> <a id="4995" class="Symbol">→</a> <a id="4997" href="1Lab.Univalence.SIP.html#4752" class="Bound">S</a> <a id="4999" class="Symbol">(</a><a id="5000" href="1Lab.Univalence.SIP.html#4962" class="Bound">p</a> <a id="5002" href="1Lab.Univalence.SIP.html#4993" class="Bound">i</a><a id="5003" class="Symbol">))</a> <a id="5006" class="Symbol">(</a><a id="5007" href="1Lab.Univalence.SIP.html#4772" class="Bound">X</a> <a id="5009" class="Symbol">.</a><a id="5010" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="5013" class="Symbol">)</a> <a id="5015" class="Symbol">(</a><a id="5016" href="1Lab.Univalence.SIP.html#4776" class="Bound">Y</a> <a id="5018" class="Symbol">.</a><a id="5019" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="5022" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="5024" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a id="5027" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a id="5037" href="1Lab.Type.Sigma.html#474" class="Function">Σ-PathP-iso</a> <a id="5049" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="5053" class="Symbol">(</a><a id="5054" href="1Lab.Univalence.SIP.html#4772" class="Bound">X</a> <a id="5056" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5058" href="1Lab.Univalence.SIP.html#4776" class="Bound">Y</a><a id="5059" class="Symbol">)</a>                                                          <a id="5118" href="1Lab.Equiv.html#23023" class="Function Operator">≃∎</a>
</pre>
<p>The proof of the <span class="Agda"><a href="1Lab.Univalence.SIP.html#4662" class="Function">SIP</a></span> follows essentially from <span class="Agda"><a href="1Lab.Univalence.html#16792" class="Function">univalence</a></span>, and the fact that <span class="Agda"><a href="1Lab.Type.Sigma.html#2031" class="Function">Σ types respect equivalences</a></span>. In one fell swoop, we convert from the type of homomorphic equivalences to a dependent pair of paths. By the characterisation of <span class="Agda"><a href="1Lab.Type.Sigma.html#474" class="Function">path spaces of Σ types</a></span>, this latter pair is equivalent to <code>X ≡ Y</code>.</p>
<pre class="Agda"><a id="sip"></a><a id="5521" href="1Lab.Univalence.SIP.html#5521" class="Function">sip</a> <a id="5525" class="Symbol">:</a> <a id="5527" class="Symbol">{</a><a id="5528" href="1Lab.Univalence.SIP.html#5528" class="Bound">σ</a> <a id="5530" class="Symbol">:</a> <a id="5532" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="5542" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="5544" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a><a id="5545" class="Symbol">}</a> <a id="5547" class="Symbol">→</a> <a id="5549" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="5561" href="1Lab.Univalence.SIP.html#5528" class="Bound">σ</a> <a id="5563" class="Symbol">→</a> <a id="5565" class="Symbol">{</a><a id="5566" href="1Lab.Univalence.SIP.html#5566" class="Bound">X</a> <a id="5568" href="1Lab.Univalence.SIP.html#5568" class="Bound">Y</a> <a id="5570" class="Symbol">:</a> <a id="5572" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="5574" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a><a id="5575" class="Symbol">}</a> <a id="5577" class="Symbol">→</a> <a id="5579" class="Symbol">(</a><a id="5580" href="1Lab.Univalence.SIP.html#5566" class="Bound">X</a> <a id="5582" href="1Lab.Univalence.SIP.html#4237" class="Function Operator">≃[</a> <a id="5585" href="1Lab.Univalence.SIP.html#5528" class="Bound">σ</a> <a id="5587" href="1Lab.Univalence.SIP.html#4237" class="Function Operator">]</a> <a id="5589" href="1Lab.Univalence.SIP.html#5568" class="Bound">Y</a><a id="5590" class="Symbol">)</a> <a id="5592" class="Symbol">→</a> <a id="5594" class="Symbol">(</a><a id="5595" href="1Lab.Univalence.SIP.html#5566" class="Bound">X</a> <a id="5597" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5599" href="1Lab.Univalence.SIP.html#5568" class="Bound">Y</a><a id="5600" class="Symbol">)</a>
<a id="5602" href="1Lab.Univalence.SIP.html#5521" class="Function">sip</a> <a id="5606" href="1Lab.Univalence.SIP.html#5606" class="Bound">σ</a> <a id="5608" class="Symbol">=</a> <a id="5610" href="1Lab.Univalence.SIP.html#4662" class="Function">SIP</a> <a id="5614" href="1Lab.Univalence.SIP.html#5606" class="Bound">σ</a> <a id="5616" class="Symbol">.</a><a id="5617" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
</pre>
<h1 id="structure-combinators">Structure Combinators</h1>
<p>Univalent structures can be built up in an algebraic manner through the use of <em>structure combinators</em>. These express closure of structures under a number of type formers. For instance, if <code>S</code> and <code>T</code> are univalent structures, then so is <code>λ X → S X → T X</code>.</p>
<p>The simplest case of univalent structure is the <em>constant structure</em>, which is what you get when you equip a type <code>X</code> with a choice of inhabitant of some other type <code>Y</code>, unrelated to <code>X</code>. Since the given function is <code>f : A → B</code>, it can’t act on <code>T</code>, so the notion of homomorphism is independent of <code>f</code>.</p>
<pre class="Agda"><a id="constantStr"></a><a id="6221" href="1Lab.Univalence.SIP.html#6221" class="Function">constantStr</a> <a id="6233" class="Symbol">:</a> <a id="6235" class="Symbol">(</a><a id="6236" href="1Lab.Univalence.SIP.html#6236" class="Bound">A</a> <a id="6238" class="Symbol">:</a> <a id="6240" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="6245" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a><a id="6246" class="Symbol">)</a> <a id="6248" class="Symbol">→</a> <a id="6250" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="6260" class="Symbol">{</a><a id="6261" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a><a id="6263" class="Symbol">}</a> <a id="6265" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="6267" class="Symbol">(λ</a> <a id="6270" href="1Lab.Univalence.SIP.html#6270" class="Bound">X</a> <a id="6272" class="Symbol">→</a> <a id="6274" href="1Lab.Univalence.SIP.html#6236" class="Bound">A</a><a id="6275" class="Symbol">)</a>
<a id="6277" href="1Lab.Univalence.SIP.html#6221" class="Function">constantStr</a> <a id="6289" href="1Lab.Univalence.SIP.html#6289" class="Bound">T</a> <a id="6291" class="Symbol">.</a><a id="6292" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="6299" class="Symbol">(</a><a id="6300" href="1Lab.Univalence.SIP.html#6300" class="Bound">A</a> <a id="6302" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6304" href="1Lab.Univalence.SIP.html#6304" class="Bound">x</a><a id="6305" class="Symbol">)</a> <a id="6307" class="Symbol">(</a><a id="6308" href="1Lab.Univalence.SIP.html#6308" class="Bound">B</a> <a id="6310" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6312" href="1Lab.Univalence.SIP.html#6312" class="Bound">y</a><a id="6313" class="Symbol">)</a> <a id="6315" href="1Lab.Univalence.SIP.html#6315" class="Bound">f</a> <a id="6317" class="Symbol">=</a> <a id="6319" href="1Lab.Univalence.SIP.html#6304" class="Bound">x</a> <a id="6321" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="6323" href="1Lab.Univalence.SIP.html#6312" class="Bound">y</a>

<a id="constantStr-univalent"></a><a id="6326" href="1Lab.Univalence.SIP.html#6326" class="Function">constantStr-univalent</a> <a id="6348" class="Symbol">:</a> <a id="6350" class="Symbol">{</a><a id="6351" href="1Lab.Univalence.SIP.html#6351" class="Bound">A</a> <a id="6353" class="Symbol">:</a> <a id="6355" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="6360" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a><a id="6361" class="Symbol">}</a> <a id="6363" class="Symbol">→</a> <a id="6365" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="6377" class="Symbol">(</a><a id="6378" href="1Lab.Univalence.SIP.html#6221" class="Function">constantStr</a> <a id="6390" class="Symbol">{</a><a id="6391" class="Argument">ℓ₁</a> <a id="6394" class="Symbol">=</a> <a id="6396" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a><a id="6398" class="Symbol">}</a> <a id="6400" href="1Lab.Univalence.SIP.html#6351" class="Bound">A</a><a id="6401" class="Symbol">)</a>
<a id="6403" href="1Lab.Univalence.SIP.html#6326" class="Function">constantStr-univalent</a> <a id="6425" href="1Lab.Univalence.SIP.html#6425" class="Bound">f</a> <a id="6427" class="Symbol">=</a> <a id="6429" class="Symbol">_</a> <a id="6431" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6433" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>
</pre>
<p>The next simplest case is considering the identity function as a structure. In that case, the resulting structured type is that of a <em>pointed type</em>, whence the name <span class="Agda"><a href="1Lab.Univalence.SIP.html#7072" class="Function">pointedStr</a></span>.</p>
<p>The name <span class="Agda"><a href="1Lab.Univalence.SIP.html#7072" class="Function">pointedStr</a></span> breaks down when it is used with some of the other combinators: A type equipped with the <span class="Agda"><a href="1Lab.Univalence.SIP.html#7572" class="Function">product</a></span> of two <span class="Agda"><a href="1Lab.Univalence.SIP.html#7072" class="Function">pointed structures</a></span> is indeed a “bipointed structure”, but a type equipped with <span class="Agda"><a href="1Lab.Univalence.SIP.html#16955" class="Function">maps between</a></span> two <span class="Agda"><a href="1Lab.Univalence.SIP.html#7072" class="Function">pointed structures</a></span> is a type equipped with an endomorphism, which does not necessitate a point.</p>
<pre class="Agda"><a id="pointedStr"></a><a id="7072" href="1Lab.Univalence.SIP.html#7072" class="Function">pointedStr</a> <a id="7083" class="Symbol">:</a> <a id="7085" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="7095" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="7097" class="Symbol">(λ</a> <a id="7100" href="1Lab.Univalence.SIP.html#7100" class="Bound">X</a> <a id="7102" class="Symbol">→</a> <a id="7104" href="1Lab.Univalence.SIP.html#7100" class="Bound">X</a><a id="7105" class="Symbol">)</a>
<a id="7107" href="1Lab.Univalence.SIP.html#7072" class="Function">pointedStr</a> <a id="7118" class="Symbol">.</a><a id="7119" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="7126" class="Symbol">(</a><a id="7127" href="1Lab.Univalence.SIP.html#7127" class="Bound">A</a> <a id="7129" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7131" href="1Lab.Univalence.SIP.html#7131" class="Bound">x</a><a id="7132" class="Symbol">)</a> <a id="7134" class="Symbol">(</a><a id="7135" href="1Lab.Univalence.SIP.html#7135" class="Bound">B</a> <a id="7137" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7139" href="1Lab.Univalence.SIP.html#7139" class="Bound">y</a><a id="7140" class="Symbol">)</a> <a id="7142" href="1Lab.Univalence.SIP.html#7142" class="Bound">f</a> <a id="7144" class="Symbol">=</a> <a id="7146" href="1Lab.Univalence.SIP.html#7142" class="Bound">f</a> <a id="7148" class="Symbol">.</a><a id="7149" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="7153" href="1Lab.Univalence.SIP.html#7131" class="Bound">x</a> <a id="7155" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7157" href="1Lab.Univalence.SIP.html#7139" class="Bound">y</a>
</pre>
<p>This is univalent by <span class="Agda"><a href="1Lab.Univalence.html#14247" class="Function">uaPathP≃Path</a></span>, which says <code>PathP (ua f) x y</code> is equivalent to <code>f .fst x ≡ y</code>.</p>
<pre class="Agda"><a id="pointedStr-univalent"></a><a id="7280" href="1Lab.Univalence.SIP.html#7280" class="Function">pointedStr-univalent</a> <a id="7301" class="Symbol">:</a> <a id="7303" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="7315" class="Symbol">(</a><a id="7316" href="1Lab.Univalence.SIP.html#7072" class="Function">pointedStr</a> <a id="7327" class="Symbol">{</a><a id="7328" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a><a id="7329" class="Symbol">})</a>
<a id="7332" href="1Lab.Univalence.SIP.html#7280" class="Function">pointedStr-univalent</a> <a id="7353" href="1Lab.Univalence.SIP.html#7353" class="Bound">f</a> <a id="7355" class="Symbol">=</a> <a id="7357" href="1Lab.Univalence.html#14247" class="Function">uaPathP≃Path</a> <a id="7370" class="Symbol">_</a>
</pre>
<p>If <code>S</code> and <code>T</code> are univalent structures, then so is their pointwise product. The notion of a <code>S × T</code>-homomorphism is that of a function homomorphic for both <code>S</code> and <code>T</code>, simultaneously:</p>
<pre class="Agda"><a id="productStr"></a><a id="7572" href="1Lab.Univalence.SIP.html#7572" class="Function">productStr</a> <a id="7583" class="Symbol">:</a> <a id="7585" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="7595" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="7597" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="7599" class="Symbol">→</a> <a id="7601" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="7611" href="1Lab.Univalence.SIP.html#3488" class="Generalizable">ℓ₂</a> <a id="7614" href="1Lab.Univalence.SIP.html#3519" class="Generalizable">T</a> <a id="7616" class="Symbol">→</a> <a id="7618" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="7628" class="Symbol">_</a> <a id="7630" class="Symbol">(λ</a> <a id="7633" href="1Lab.Univalence.SIP.html#7633" class="Bound">X</a> <a id="7635" class="Symbol">→</a> <a id="7637" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="7639" href="1Lab.Univalence.SIP.html#7633" class="Bound">X</a> <a id="7641" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="7643" href="1Lab.Univalence.SIP.html#3519" class="Generalizable">T</a> <a id="7645" href="1Lab.Univalence.SIP.html#7633" class="Bound">X</a><a id="7646" class="Symbol">)</a>
<a id="7648" href="1Lab.Univalence.SIP.html#7572" class="Function">productStr</a> <a id="7659" href="1Lab.Univalence.SIP.html#7659" class="Bound">S</a> <a id="7661" href="1Lab.Univalence.SIP.html#7661" class="Bound">T</a> <a id="7663" class="Symbol">.</a><a id="7664" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="7671" class="Symbol">(</a><a id="7672" href="1Lab.Univalence.SIP.html#7672" class="Bound">A</a> <a id="7674" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7676" href="1Lab.Univalence.SIP.html#7676" class="Bound">x</a> <a id="7678" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7680" href="1Lab.Univalence.SIP.html#7680" class="Bound">y</a><a id="7681" class="Symbol">)</a> <a id="7683" class="Symbol">(</a><a id="7684" href="1Lab.Univalence.SIP.html#7684" class="Bound">B</a> <a id="7686" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7688" href="1Lab.Univalence.SIP.html#7688" class="Bound">x&#39;</a> <a id="7691" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7693" href="1Lab.Univalence.SIP.html#7693" class="Bound">y&#39;</a><a id="7695" class="Symbol">)</a> <a id="7697" href="1Lab.Univalence.SIP.html#7697" class="Bound">f</a> <a id="7699" class="Symbol">=</a>
  <a id="7703" href="1Lab.Univalence.SIP.html#7659" class="Bound">S</a> <a id="7705" class="Symbol">.</a><a id="7706" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="7713" class="Symbol">(</a><a id="7714" href="1Lab.Univalence.SIP.html#7672" class="Bound">A</a> <a id="7716" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7718" href="1Lab.Univalence.SIP.html#7676" class="Bound">x</a><a id="7719" class="Symbol">)</a> <a id="7721" class="Symbol">(</a><a id="7722" href="1Lab.Univalence.SIP.html#7684" class="Bound">B</a> <a id="7724" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7726" href="1Lab.Univalence.SIP.html#7688" class="Bound">x&#39;</a><a id="7728" class="Symbol">)</a> <a id="7730" href="1Lab.Univalence.SIP.html#7697" class="Bound">f</a> <a id="7732" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="7734" href="1Lab.Univalence.SIP.html#7661" class="Bound">T</a> <a id="7736" class="Symbol">.</a><a id="7737" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="7744" class="Symbol">(</a><a id="7745" href="1Lab.Univalence.SIP.html#7672" class="Bound">A</a> <a id="7747" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7749" href="1Lab.Univalence.SIP.html#7680" class="Bound">y</a><a id="7750" class="Symbol">)</a> <a id="7752" class="Symbol">(</a><a id="7753" href="1Lab.Univalence.SIP.html#7684" class="Bound">B</a> <a id="7755" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7757" href="1Lab.Univalence.SIP.html#7693" class="Bound">y&#39;</a><a id="7759" class="Symbol">)</a> <a id="7761" href="1Lab.Univalence.SIP.html#7697" class="Bound">f</a>

<a id="productStr-univalent"></a><a id="7764" href="1Lab.Univalence.SIP.html#7764" class="Function">productStr-univalent</a> <a id="7785" class="Symbol">:</a> <a id="7787" class="Symbol">{</a><a id="7788" href="1Lab.Univalence.SIP.html#7788" class="Bound">σ</a> <a id="7790" class="Symbol">:</a> <a id="7792" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="7802" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a> <a id="7805" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a><a id="7806" class="Symbol">}</a> <a id="7808" class="Symbol">{</a><a id="7809" href="1Lab.Univalence.SIP.html#7809" class="Bound">τ</a> <a id="7811" class="Symbol">:</a> <a id="7813" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="7823" href="1Lab.Univalence.SIP.html#3488" class="Generalizable">ℓ₂</a> <a id="7826" href="1Lab.Univalence.SIP.html#3519" class="Generalizable">T</a><a id="7827" class="Symbol">}</a>
                     <a id="7850" class="Symbol">→</a> <a id="7852" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="7864" href="1Lab.Univalence.SIP.html#7788" class="Bound">σ</a> <a id="7866" class="Symbol">→</a> <a id="7868" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="7880" href="1Lab.Univalence.SIP.html#7809" class="Bound">τ</a>
                     <a id="7903" class="Symbol">→</a> <a id="7905" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="7917" class="Symbol">(</a><a id="7918" href="1Lab.Univalence.SIP.html#7572" class="Function">productStr</a> <a id="7929" href="1Lab.Univalence.SIP.html#7788" class="Bound">σ</a> <a id="7931" href="1Lab.Univalence.SIP.html#7809" class="Bound">τ</a><a id="7932" class="Symbol">)</a>
<a id="7934" href="1Lab.Univalence.SIP.html#7764" class="Function">productStr-univalent</a> <a id="7955" class="Symbol">{</a><a id="7956" class="Argument">S</a> <a id="7958" class="Symbol">=</a> <a id="7960" href="1Lab.Univalence.SIP.html#7960" class="Bound">S</a><a id="7961" class="Symbol">}</a> <a id="7963" class="Symbol">{</a><a id="7964" class="Argument">T</a> <a id="7966" class="Symbol">=</a> <a id="7968" href="1Lab.Univalence.SIP.html#7968" class="Bound">T</a><a id="7969" class="Symbol">}</a> <a id="7971" class="Symbol">{</a><a id="7972" class="Argument">σ</a> <a id="7974" class="Symbol">=</a> <a id="7976" href="1Lab.Univalence.SIP.html#7976" class="Bound">σ</a><a id="7977" class="Symbol">}</a> <a id="7979" class="Symbol">{</a><a id="7980" href="1Lab.Univalence.SIP.html#7980" class="Bound">τ</a><a id="7981" class="Symbol">}</a> <a id="7983" href="1Lab.Univalence.SIP.html#7983" class="Bound">θ₁</a> <a id="7986" href="1Lab.Univalence.SIP.html#7986" class="Bound">θ₂</a> <a id="7989" class="Symbol">{</a><a id="7990" href="1Lab.Univalence.SIP.html#7990" class="Bound">X</a> <a id="7992" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7994" href="1Lab.Univalence.SIP.html#7994" class="Bound">x</a> <a id="7996" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7998" href="1Lab.Univalence.SIP.html#7998" class="Bound">y</a><a id="7999" class="Symbol">}</a> <a id="8001" class="Symbol">{</a><a id="8002" href="1Lab.Univalence.SIP.html#8002" class="Bound">Y</a> <a id="8004" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8006" href="1Lab.Univalence.SIP.html#8006" class="Bound">x&#39;</a> <a id="8009" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8011" href="1Lab.Univalence.SIP.html#8011" class="Bound">y&#39;</a><a id="8013" class="Symbol">}</a> <a id="8015" href="1Lab.Univalence.SIP.html#8015" class="Bound">f</a> <a id="8017" class="Symbol">=</a>
  <a id="8021" class="Symbol">(</a><a id="8022" href="1Lab.Univalence.SIP.html#7976" class="Bound">σ</a> <a id="8024" class="Symbol">.</a><a id="8025" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="8032" class="Symbol">(</a><a id="8033" href="1Lab.Univalence.SIP.html#7990" class="Bound">X</a> <a id="8035" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8037" href="1Lab.Univalence.SIP.html#7994" class="Bound">x</a><a id="8038" class="Symbol">)</a> <a id="8040" class="Symbol">(</a><a id="8041" href="1Lab.Univalence.SIP.html#8002" class="Bound">Y</a> <a id="8043" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8045" href="1Lab.Univalence.SIP.html#8006" class="Bound">x&#39;</a><a id="8047" class="Symbol">)</a> <a id="8049" class="Symbol">_</a> <a id="8051" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="8053" href="1Lab.Univalence.SIP.html#7980" class="Bound">τ</a> <a id="8055" class="Symbol">.</a><a id="8056" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="8063" class="Symbol">(</a><a id="8064" href="1Lab.Univalence.SIP.html#7990" class="Bound">X</a> <a id="8066" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8068" href="1Lab.Univalence.SIP.html#7998" class="Bound">y</a><a id="8069" class="Symbol">)</a> <a id="8071" class="Symbol">(</a><a id="8072" href="1Lab.Univalence.SIP.html#8002" class="Bound">Y</a> <a id="8074" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8076" href="1Lab.Univalence.SIP.html#8011" class="Bound">y&#39;</a><a id="8078" class="Symbol">)</a> <a id="8080" class="Symbol">_)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="8083" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a id="8086" href="1Lab.Type.Sigma.html#2031" class="Function">Σ-ap</a> <a id="8091" class="Symbol">(</a><a id="8092" href="1Lab.Univalence.SIP.html#7983" class="Bound">θ₁</a> <a id="8095" href="1Lab.Univalence.SIP.html#8015" class="Bound">f</a><a id="8096" class="Symbol">)</a> <a id="8098" class="Symbol">(λ</a> <a id="8101" href="1Lab.Univalence.SIP.html#8101" class="Bound">_</a> <a id="8103" class="Symbol">→</a> <a id="8105" href="1Lab.Univalence.SIP.html#7986" class="Bound">θ₂</a> <a id="8108" href="1Lab.Univalence.SIP.html#8015" class="Bound">f</a><a id="8109" class="Symbol">)</a> <a id="8111" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="8115" class="Symbol">(</a><a id="8116" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="8122" class="Symbol">_</a> <a id="8124" class="Symbol">_</a> <a id="8126" class="Symbol">_</a> <a id="8128" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="8130" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="8136" class="Symbol">_</a> <a id="8138" class="Symbol">_</a> <a id="8140" class="Symbol">_)</a>                                   <span class="reasoning-step"><span class="as-written Function Operator"><a id="8177" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a id="8180" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a id="8190" href="1Lab.Type.Sigma.html#474" class="Function">Σ-PathP-iso</a> <a id="8202" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="8206" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="8212" class="Symbol">(λ</a> <a id="8215" href="1Lab.Univalence.SIP.html#8215" class="Bound">i</a> <a id="8217" class="Symbol">→</a> <a id="8219" href="1Lab.Univalence.SIP.html#7960" class="Bound">S</a> <a id="8221" class="Symbol">(</a><a id="8222" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="8225" href="1Lab.Univalence.SIP.html#8015" class="Bound">f</a> <a id="8227" href="1Lab.Univalence.SIP.html#8215" class="Bound">i</a><a id="8228" class="Symbol">)</a> <a id="8230" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="8232" href="1Lab.Univalence.SIP.html#7968" class="Bound">T</a> <a id="8234" class="Symbol">(</a><a id="8235" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="8238" href="1Lab.Univalence.SIP.html#8015" class="Bound">f</a> <a id="8240" href="1Lab.Univalence.SIP.html#8215" class="Bound">i</a><a id="8241" class="Symbol">))</a> <a id="8244" class="Symbol">(</a><a id="8245" href="1Lab.Univalence.SIP.html#7994" class="Bound">x</a> <a id="8247" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8249" href="1Lab.Univalence.SIP.html#7998" class="Bound">y</a><a id="8250" class="Symbol">)</a> <a id="8252" class="Symbol">(</a><a id="8253" href="1Lab.Univalence.SIP.html#8006" class="Bound">x&#39;</a> <a id="8256" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8258" href="1Lab.Univalence.SIP.html#8011" class="Bound">y&#39;</a><a id="8260" class="Symbol">)</a>       <a id="8268" href="1Lab.Equiv.html#23023" class="Function Operator">≃∎</a>
</pre>
<p>If <code>S</code> and <code>T</code> are univalent structures, then so are the families of functions between them. For reasons we’ll see below, this is called <span class="Agda"><a href="1Lab.Univalence.SIP.html#8507" class="Function">Str-functionStr</a></span> (a rather redundant name!) instead of <span class="Agda"><a href="1Lab.Univalence.SIP.html#16955" class="Function">functionStr</a></span>.</p>
<pre class="Agda"><a id="Str-functionStr"></a><a id="8507" href="1Lab.Univalence.SIP.html#8507" class="Function">Str-functionStr</a> <a id="8523" class="Symbol">:</a> <a id="8525" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="8535" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a> <a id="8538" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="8540" class="Symbol">→</a> <a id="8542" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="8552" href="1Lab.Univalence.SIP.html#3488" class="Generalizable">ℓ₂</a> <a id="8555" href="1Lab.Univalence.SIP.html#3519" class="Generalizable">T</a> <a id="8557" class="Symbol">→</a> <a id="8559" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="8569" class="Symbol">_</a> <a id="8571" class="Symbol">(λ</a> <a id="8574" href="1Lab.Univalence.SIP.html#8574" class="Bound">X</a> <a id="8576" class="Symbol">→</a> <a id="8578" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="8580" href="1Lab.Univalence.SIP.html#8574" class="Bound">X</a> <a id="8582" class="Symbol">→</a> <a id="8584" href="1Lab.Univalence.SIP.html#3519" class="Generalizable">T</a> <a id="8586" href="1Lab.Univalence.SIP.html#8574" class="Bound">X</a><a id="8587" class="Symbol">)</a>
<a id="8589" href="1Lab.Univalence.SIP.html#8507" class="Function">Str-functionStr</a> <a id="8605" class="Symbol">{</a><a id="8606" class="Argument">S</a> <a id="8608" class="Symbol">=</a> <a id="8610" href="1Lab.Univalence.SIP.html#8610" class="Bound">S</a><a id="8611" class="Symbol">}</a> <a id="8613" href="1Lab.Univalence.SIP.html#8613" class="Bound">σ</a> <a id="8615" href="1Lab.Univalence.SIP.html#8615" class="Bound">τ</a> <a id="8617" class="Symbol">.</a><a id="8618" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="8625" class="Symbol">(</a><a id="8626" href="1Lab.Univalence.SIP.html#8626" class="Bound">A</a> <a id="8628" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8630" href="1Lab.Univalence.SIP.html#8630" class="Bound">f</a><a id="8631" class="Symbol">)</a> <a id="8633" class="Symbol">(</a><a id="8634" href="1Lab.Univalence.SIP.html#8634" class="Bound">B</a> <a id="8636" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8638" href="1Lab.Univalence.SIP.html#8638" class="Bound">g</a><a id="8639" class="Symbol">)</a> <a id="8641" href="1Lab.Univalence.SIP.html#8641" class="Bound">h</a> <a id="8643" class="Symbol">=</a>
  <a id="8647" class="Symbol">{</a><a id="8648" href="1Lab.Univalence.SIP.html#8648" class="Bound">s</a> <a id="8650" class="Symbol">:</a> <a id="8652" href="1Lab.Univalence.SIP.html#8610" class="Bound">S</a> <a id="8654" href="1Lab.Univalence.SIP.html#8626" class="Bound">A</a><a id="8655" class="Symbol">}</a> <a id="8657" class="Symbol">{</a><a id="8658" href="1Lab.Univalence.SIP.html#8658" class="Bound">t</a> <a id="8660" class="Symbol">:</a> <a id="8662" href="1Lab.Univalence.SIP.html#8610" class="Bound">S</a> <a id="8664" href="1Lab.Univalence.SIP.html#8634" class="Bound">B</a><a id="8665" class="Symbol">}</a> <a id="8667" class="Symbol">→</a> <a id="8669" href="1Lab.Univalence.SIP.html#8613" class="Bound">σ</a> <a id="8671" class="Symbol">.</a><a id="8672" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="8679" class="Symbol">(</a><a id="8680" href="1Lab.Univalence.SIP.html#8626" class="Bound">A</a> <a id="8682" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8684" href="1Lab.Univalence.SIP.html#8648" class="Bound">s</a><a id="8685" class="Symbol">)</a> <a id="8687" class="Symbol">(</a><a id="8688" href="1Lab.Univalence.SIP.html#8634" class="Bound">B</a> <a id="8690" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8692" href="1Lab.Univalence.SIP.html#8658" class="Bound">t</a><a id="8693" class="Symbol">)</a> <a id="8695" href="1Lab.Univalence.SIP.html#8641" class="Bound">h</a>
                      <a id="8719" class="Symbol">→</a> <a id="8721" href="1Lab.Univalence.SIP.html#8615" class="Bound">τ</a> <a id="8723" class="Symbol">.</a><a id="8724" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="8731" class="Symbol">(</a><a id="8732" href="1Lab.Univalence.SIP.html#8626" class="Bound">A</a> <a id="8734" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8736" href="1Lab.Univalence.SIP.html#8630" class="Bound">f</a> <a id="8738" href="1Lab.Univalence.SIP.html#8648" class="Bound">s</a><a id="8739" class="Symbol">)</a> <a id="8741" class="Symbol">(</a><a id="8742" href="1Lab.Univalence.SIP.html#8634" class="Bound">B</a> <a id="8744" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8746" href="1Lab.Univalence.SIP.html#8638" class="Bound">g</a> <a id="8748" href="1Lab.Univalence.SIP.html#8658" class="Bound">t</a><a id="8749" class="Symbol">)</a> <a id="8751" href="1Lab.Univalence.SIP.html#8641" class="Bound">h</a>

<a id="Str-functionStr-univalent"></a><a id="8754" href="1Lab.Univalence.SIP.html#8754" class="Function">Str-functionStr-univalent</a> <a id="8780" class="Symbol">:</a> <a id="8782" class="Symbol">{</a><a id="8783" href="1Lab.Univalence.SIP.html#8783" class="Bound">σ</a> <a id="8785" class="Symbol">:</a> <a id="8787" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="8797" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a> <a id="8800" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a><a id="8801" class="Symbol">}</a> <a id="8803" class="Symbol">{</a><a id="8804" href="1Lab.Univalence.SIP.html#8804" class="Bound">τ</a> <a id="8806" class="Symbol">:</a> <a id="8808" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="8818" href="1Lab.Univalence.SIP.html#3488" class="Generalizable">ℓ₂</a> <a id="8821" href="1Lab.Univalence.SIP.html#3519" class="Generalizable">T</a><a id="8822" class="Symbol">}</a>
                          <a id="8850" class="Symbol">→</a> <a id="8852" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="8864" href="1Lab.Univalence.SIP.html#8783" class="Bound">σ</a> <a id="8866" class="Symbol">→</a> <a id="8868" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="8880" href="1Lab.Univalence.SIP.html#8804" class="Bound">τ</a>
                          <a id="8908" class="Symbol">→</a> <a id="8910" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="8922" class="Symbol">(</a><a id="8923" href="1Lab.Univalence.SIP.html#8507" class="Function">Str-functionStr</a> <a id="8939" href="1Lab.Univalence.SIP.html#8783" class="Bound">σ</a> <a id="8941" href="1Lab.Univalence.SIP.html#8804" class="Bound">τ</a><a id="8942" class="Symbol">)</a>
<a id="8944" href="1Lab.Univalence.SIP.html#8754" class="Function">Str-functionStr-univalent</a> <a id="8970" class="Symbol">{</a><a id="8971" class="Argument">S</a> <a id="8973" class="Symbol">=</a> <a id="8975" href="1Lab.Univalence.SIP.html#8975" class="Bound">S</a><a id="8976" class="Symbol">}</a> <a id="8978" class="Symbol">{</a><a id="8979" class="Argument">T</a> <a id="8981" class="Symbol">=</a> <a id="8983" href="1Lab.Univalence.SIP.html#8983" class="Bound">T</a><a id="8984" class="Symbol">}</a> <a id="8986" class="Symbol">{</a><a id="8987" class="Argument">σ</a> <a id="8989" class="Symbol">=</a> <a id="8991" href="1Lab.Univalence.SIP.html#8991" class="Bound">σ</a><a id="8992" class="Symbol">}</a> <a id="8994" class="Symbol">{</a><a id="8995" href="1Lab.Univalence.SIP.html#8995" class="Bound">τ</a><a id="8996" class="Symbol">}</a> <a id="8998" href="1Lab.Univalence.SIP.html#8998" class="Bound">θ₁</a> <a id="9001" href="1Lab.Univalence.SIP.html#9001" class="Bound">θ₂</a> <a id="9004" href="1Lab.Univalence.SIP.html#9004" class="Bound">eqv</a> <a id="9008" class="Symbol">=</a>
  <a id="9012" href="1Lab.Type.Pi.html#1118" class="Function">Π-impl-cod≃</a> <a id="9024" class="Symbol">(λ</a> <a id="9027" href="1Lab.Univalence.SIP.html#9027" class="Bound">s</a> <a id="9029" class="Symbol">→</a> <a id="9031" href="1Lab.Type.Pi.html#1118" class="Function">Π-impl-cod≃</a> <a id="9043" class="Symbol">λ</a> <a id="9045" href="1Lab.Univalence.SIP.html#9045" class="Bound">t</a> <a id="9047" class="Symbol">→</a> <a id="9049" href="1Lab.Type.Pi.html#1721" class="Function">function≃</a> <a id="9059" class="Symbol">(</a><a id="9060" href="1Lab.Univalence.SIP.html#8998" class="Bound">θ₁</a> <a id="9063" href="1Lab.Univalence.SIP.html#9004" class="Bound">eqv</a><a id="9066" class="Symbol">)</a> <a id="9068" class="Symbol">(</a><a id="9069" href="1Lab.Univalence.SIP.html#9001" class="Bound">θ₂</a> <a id="9072" href="1Lab.Univalence.SIP.html#9004" class="Bound">eqv</a><a id="9075" class="Symbol">))</a> <a id="9078" href="1Lab.Equiv.html#21156" class="Function Operator">∙e</a> <a id="9081" href="1Lab.Type.Pi.html#3070" class="Function">funextDep≃</a>
</pre>
<h2 id="example-infty-magmas">Example: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magmas</h2>
<p>We provide an example of applying the SIP, and the structure combinators: <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magmas</strong>. Recall that a <a href="https://ncatlab.org/nlab/show/magma">magma</a> is a <a href="1Lab.HLevel.html#3398">Set</a> equipped with a binary operation, with no further conditions imposed. In HoTT, we can relax this even further: An <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magma is a <span class="Agda"><a href="1Lab.Type.html#394" class="Primitive">Type</a></span> - that is, an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-groupoid - equipped with a binary operation.</p>
<pre class="Agda"><a id="9555" class="Keyword">private</a>
  <a id="binop"></a><a id="9565" href="1Lab.Univalence.SIP.html#9565" class="Function">binop</a> <a id="9571" class="Symbol">:</a> <a id="9573" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="9578" class="Symbol">→</a> <a id="9580" href="1Lab.Type.html#394" class="Primitive">Type</a>
  <a id="9587" href="1Lab.Univalence.SIP.html#9565" class="Function">binop</a> <a id="9593" href="1Lab.Univalence.SIP.html#9593" class="Bound">X</a> <a id="9595" class="Symbol">=</a> <a id="9597" href="1Lab.Univalence.SIP.html#9593" class="Bound">X</a> <a id="9599" class="Symbol">→</a> <a id="9601" href="1Lab.Univalence.SIP.html#9593" class="Bound">X</a> <a id="9603" class="Symbol">→</a> <a id="9605" href="1Lab.Univalence.SIP.html#9593" class="Bound">X</a>
</pre>
<p>We can impose a <span class="Agda"><a href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a></span> on <span class="Agda"><a href="1Lab.Univalence.SIP.html#9565" class="Function">binop</a></span> by applying nested <span class="Agda"><a href="1Lab.Univalence.SIP.html#16955" class="Function">functionStr</a></span> and <span class="Agda"><a href="1Lab.Univalence.SIP.html#7072" class="Function">pointedStr</a></span>. Since this structure is built out of structure combinators, it’s automatically univalent:</p>
<pre class="Agda">  <a id="∞-Magma"></a><a id="9831" href="1Lab.Univalence.SIP.html#9831" class="Function">∞-Magma</a> <a id="9839" class="Symbol">:</a> <a id="9841" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="9851" href="Agda.Primitive.html#764" class="Primitive">lzero</a> <a id="9857" href="1Lab.Univalence.SIP.html#9565" class="Function">binop</a>
  <a id="9865" href="1Lab.Univalence.SIP.html#9831" class="Function">∞-Magma</a> <a id="9873" class="Symbol">=</a> <a id="9875" href="1Lab.Univalence.SIP.html#8507" class="Function">Str-functionStr</a> <a id="9891" href="1Lab.Univalence.SIP.html#7072" class="Function">pointedStr</a> <a id="9902" class="Symbol">(</a><a id="9903" href="1Lab.Univalence.SIP.html#8507" class="Function">Str-functionStr</a> <a id="9919" href="1Lab.Univalence.SIP.html#7072" class="Function">pointedStr</a> <a id="9930" href="1Lab.Univalence.SIP.html#7072" class="Function">pointedStr</a><a id="9940" class="Symbol">)</a>

  <a id="∞-Magma-univ"></a><a id="9945" href="1Lab.Univalence.SIP.html#9945" class="Function">∞-Magma-univ</a> <a id="9958" class="Symbol">:</a> <a id="9960" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="9972" href="1Lab.Univalence.SIP.html#9831" class="Function">∞-Magma</a>
  <a id="9982" href="1Lab.Univalence.SIP.html#9945" class="Function">∞-Magma-univ</a> <a id="9995" class="Symbol">=</a>
    <a id="10001" href="1Lab.Univalence.SIP.html#8754" class="Function">Str-functionStr-univalent</a> <a id="10027" class="Symbol">{</a><a id="10028" class="Argument">τ</a> <a id="10030" class="Symbol">=</a> <a id="10032" href="1Lab.Univalence.SIP.html#8507" class="Function">Str-functionStr</a> <a id="10048" href="1Lab.Univalence.SIP.html#7072" class="Function">pointedStr</a> <a id="10059" href="1Lab.Univalence.SIP.html#7072" class="Function">pointedStr</a><a id="10069" class="Symbol">}</a>
      <a id="10077" href="1Lab.Univalence.SIP.html#7280" class="Function">pointedStr-univalent</a>
      <a id="10104" class="Symbol">(</a><a id="10105" href="1Lab.Univalence.SIP.html#8754" class="Function">Str-functionStr-univalent</a> <a id="10131" class="Symbol">{</a><a id="10132" class="Argument">τ</a> <a id="10134" class="Symbol">=</a> <a id="10136" href="1Lab.Univalence.SIP.html#7072" class="Function">pointedStr</a><a id="10146" class="Symbol">}</a>
        <a id="10156" href="1Lab.Univalence.SIP.html#7280" class="Function">pointedStr-univalent</a>
        <a id="10185" href="1Lab.Univalence.SIP.html#7280" class="Function">pointedStr-univalent</a><a id="10205" class="Symbol">)</a>
</pre>
<p>The type of <span class="Agda"><a href="1Lab.Univalence.SIP.html#9831" class="Function">∞-Magma</a></span> homomorphisms generated by this equivalence is slightly inconvenient: Instead of getting <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>⋆</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mi>x</mi><mo>∗</mo><mi>f</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">f (x \star y) = f x * f y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋆</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>, we get something that is parameterised over two paths:</p>
<pre class="Agda">  <a id="10425" href="1Lab.Univalence.SIP.html#10425" class="Function">_</a> <a id="10427" class="Symbol">:</a> <a id="10429" class="Symbol">{</a><a id="10430" href="1Lab.Univalence.SIP.html#10430" class="Bound">A</a> <a id="10432" href="1Lab.Univalence.SIP.html#10432" class="Bound">B</a> <a id="10434" class="Symbol">:</a> <a id="10436" href="1Lab.Univalence.SIP.html#3349" class="Function">TypeWith</a> <a id="10445" href="1Lab.Univalence.SIP.html#9831" class="Function">∞-Magma</a><a id="10452" class="Symbol">}</a> <a id="10454" class="Symbol">{</a><a id="10455" href="1Lab.Univalence.SIP.html#10455" class="Bound">f</a> <a id="10457" class="Symbol">:</a> <a id="10459" href="1Lab.Univalence.SIP.html#10430" class="Bound">A</a> <a id="10461" class="Symbol">.</a><a id="10462" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10466" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="10468" href="1Lab.Univalence.SIP.html#10432" class="Bound">B</a> <a id="10470" class="Symbol">.</a><a id="10471" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10474" class="Symbol">}</a>
    <a id="10480" class="Symbol">→</a> <a id="10482" href="1Lab.Univalence.SIP.html#9831" class="Function">∞-Magma</a> <a id="10490" class="Symbol">.</a><a id="10491" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="10498" href="1Lab.Univalence.SIP.html#10430" class="Bound">A</a> <a id="10500" href="1Lab.Univalence.SIP.html#10432" class="Bound">B</a> <a id="10502" href="1Lab.Univalence.SIP.html#10455" class="Bound">f</a>
    <a id="10508" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10510" class="Symbol">(</a> <a id="10512" class="Symbol">{</a><a id="10513" href="1Lab.Univalence.SIP.html#10513" class="Bound">s</a> <a id="10515" class="Symbol">:</a> <a id="10517" href="1Lab.Univalence.SIP.html#10430" class="Bound">A</a> <a id="10519" class="Symbol">.</a><a id="10520" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10523" class="Symbol">}</a> <a id="10525" class="Symbol">{</a><a id="10526" href="1Lab.Univalence.SIP.html#10526" class="Bound">t</a> <a id="10528" class="Symbol">:</a> <a id="10530" href="1Lab.Univalence.SIP.html#10432" class="Bound">B</a> <a id="10532" class="Symbol">.</a><a id="10533" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10536" class="Symbol">}</a> <a id="10538" class="Symbol">→</a> <a id="10540" href="1Lab.Univalence.SIP.html#10455" class="Bound">f</a> <a id="10542" class="Symbol">.</a><a id="10543" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10547" href="1Lab.Univalence.SIP.html#10513" class="Bound">s</a> <a id="10549" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10551" href="1Lab.Univalence.SIP.html#10526" class="Bound">t</a>
      <a id="10559" class="Symbol">→</a> <a id="10561" class="Symbol">{</a><a id="10562" href="1Lab.Univalence.SIP.html#10562" class="Bound">x</a> <a id="10564" class="Symbol">:</a> <a id="10566" href="1Lab.Univalence.SIP.html#10430" class="Bound">A</a> <a id="10568" class="Symbol">.</a><a id="10569" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10572" class="Symbol">}</a> <a id="10574" class="Symbol">{</a><a id="10575" href="1Lab.Univalence.SIP.html#10575" class="Bound">y</a> <a id="10577" class="Symbol">:</a> <a id="10579" href="1Lab.Univalence.SIP.html#10432" class="Bound">B</a> <a id="10581" class="Symbol">.</a><a id="10582" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10585" class="Symbol">}</a> <a id="10587" class="Symbol">→</a> <a id="10589" href="1Lab.Univalence.SIP.html#10455" class="Bound">f</a> <a id="10591" class="Symbol">.</a><a id="10592" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10596" href="1Lab.Univalence.SIP.html#10562" class="Bound">x</a> <a id="10598" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10600" href="1Lab.Univalence.SIP.html#10575" class="Bound">y</a>
      <a id="10608" class="Symbol">→</a> <a id="10610" href="1Lab.Univalence.SIP.html#10455" class="Bound">f</a> <a id="10612" class="Symbol">.</a><a id="10613" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10617" class="Symbol">(</a><a id="10618" href="1Lab.Univalence.SIP.html#10430" class="Bound">A</a> <a id="10620" class="Symbol">.</a><a id="10621" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10625" href="1Lab.Univalence.SIP.html#10513" class="Bound">s</a> <a id="10627" href="1Lab.Univalence.SIP.html#10562" class="Bound">x</a><a id="10628" class="Symbol">)</a> <a id="10630" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10632" href="1Lab.Univalence.SIP.html#10432" class="Bound">B</a> <a id="10634" class="Symbol">.</a><a id="10635" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10639" href="1Lab.Univalence.SIP.html#10526" class="Bound">t</a> <a id="10641" href="1Lab.Univalence.SIP.html#10575" class="Bound">y</a><a id="10642" class="Symbol">)</a>
  <a id="10646" class="Symbol">_</a> <a id="10648" class="Symbol">=</a> <a id="10650" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>This condition, although it looks a lot more complicated, is essentially the same as the standard notion:</p>
<pre class="Agda">  <a id="fixup"></a><a id="10777" href="1Lab.Univalence.SIP.html#10777" class="Function">fixup</a> <a id="10783" class="Symbol">:</a> <a id="10785" class="Symbol">{</a><a id="10786" href="1Lab.Univalence.SIP.html#10786" class="Bound">A</a> <a id="10788" href="1Lab.Univalence.SIP.html#10788" class="Bound">B</a> <a id="10790" class="Symbol">:</a> <a id="10792" href="1Lab.Univalence.SIP.html#3349" class="Function">TypeWith</a> <a id="10801" href="1Lab.Univalence.SIP.html#9831" class="Function">∞-Magma</a><a id="10808" class="Symbol">}</a> <a id="10810" class="Symbol">{</a><a id="10811" href="1Lab.Univalence.SIP.html#10811" class="Bound">f</a> <a id="10813" class="Symbol">:</a> <a id="10815" href="1Lab.Univalence.SIP.html#10786" class="Bound">A</a> <a id="10817" class="Symbol">.</a><a id="10818" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10822" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="10824" href="1Lab.Univalence.SIP.html#10788" class="Bound">B</a> <a id="10826" class="Symbol">.</a><a id="10827" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10830" class="Symbol">}</a>
        <a id="10840" class="Symbol">→</a> <a id="10842" class="Symbol">((</a><a id="10844" href="1Lab.Univalence.SIP.html#10844" class="Bound">x</a> <a id="10846" href="1Lab.Univalence.SIP.html#10846" class="Bound">y</a> <a id="10848" class="Symbol">:</a> <a id="10850" href="1Lab.Univalence.SIP.html#10786" class="Bound">A</a> <a id="10852" class="Symbol">.</a><a id="10853" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10856" class="Symbol">)</a> <a id="10858" class="Symbol">→</a> <a id="10860" href="1Lab.Univalence.SIP.html#10811" class="Bound">f</a> <a id="10862" class="Symbol">.</a><a id="10863" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10867" class="Symbol">(</a><a id="10868" href="1Lab.Univalence.SIP.html#10786" class="Bound">A</a> <a id="10870" class="Symbol">.</a><a id="10871" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10875" href="1Lab.Univalence.SIP.html#10844" class="Bound">x</a> <a id="10877" href="1Lab.Univalence.SIP.html#10846" class="Bound">y</a><a id="10878" class="Symbol">)</a> <a id="10880" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10882" href="1Lab.Univalence.SIP.html#10788" class="Bound">B</a> <a id="10884" class="Symbol">.</a><a id="10885" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10889" class="Symbol">(</a><a id="10890" href="1Lab.Univalence.SIP.html#10811" class="Bound">f</a> <a id="10892" class="Symbol">.</a><a id="10893" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10897" href="1Lab.Univalence.SIP.html#10844" class="Bound">x</a><a id="10898" class="Symbol">)</a> <a id="10900" class="Symbol">(</a><a id="10901" href="1Lab.Univalence.SIP.html#10811" class="Bound">f</a> <a id="10903" class="Symbol">.</a><a id="10904" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10908" href="1Lab.Univalence.SIP.html#10846" class="Bound">y</a><a id="10909" class="Symbol">))</a>
        <a id="10920" class="Symbol">→</a> <a id="10922" href="1Lab.Univalence.SIP.html#9831" class="Function">∞-Magma</a> <a id="10930" class="Symbol">.</a><a id="10931" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="10938" href="1Lab.Univalence.SIP.html#10786" class="Bound">A</a> <a id="10940" href="1Lab.Univalence.SIP.html#10788" class="Bound">B</a> <a id="10942" href="1Lab.Univalence.SIP.html#10811" class="Bound">f</a>
  <a id="10946" href="1Lab.Univalence.SIP.html#10777" class="Function">fixup</a> <a id="10952" class="Symbol">{</a><a id="10953" class="Argument">A</a> <a id="10955" class="Symbol">=</a> <a id="10957" href="1Lab.Univalence.SIP.html#10957" class="Bound">A</a><a id="10958" class="Symbol">}</a> <a id="10960" class="Symbol">{</a><a id="10961" href="1Lab.Univalence.SIP.html#10961" class="Bound">B</a><a id="10962" class="Symbol">}</a> <a id="10964" class="Symbol">{</a><a id="10965" href="1Lab.Univalence.SIP.html#10965" class="Bound">f</a><a id="10966" class="Symbol">}</a> <a id="10968" href="1Lab.Univalence.SIP.html#10968" class="Bound">path</a> <a id="10973" class="Symbol">{</a><a id="10974" href="1Lab.Univalence.SIP.html#10974" class="Bound">s</a><a id="10975" class="Symbol">}</a> <a id="10977" class="Symbol">{</a><a id="10978" href="1Lab.Univalence.SIP.html#10978" class="Bound">t</a><a id="10979" class="Symbol">}</a> <a id="10981" href="1Lab.Univalence.SIP.html#10981" class="Bound">p</a> <a id="10983" class="Symbol">{</a><a id="10984" href="1Lab.Univalence.SIP.html#10984" class="Bound">s₁</a><a id="10986" class="Symbol">}</a> <a id="10988" class="Symbol">{</a><a id="10989" href="1Lab.Univalence.SIP.html#10989" class="Bound">t₁</a><a id="10991" class="Symbol">}</a> <a id="10993" href="1Lab.Univalence.SIP.html#10993" class="Bound">q</a> <a id="10995" class="Symbol">=</a>
    <a id="11001" href="1Lab.Univalence.SIP.html#10965" class="Bound">f</a> <a id="11003" class="Symbol">.</a><a id="11004" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11008" class="Symbol">(</a><a id="11009" href="1Lab.Univalence.SIP.html#10957" class="Bound">A</a> <a id="11011" class="Symbol">.</a><a id="11012" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11016" href="1Lab.Univalence.SIP.html#10974" class="Bound">s</a> <a id="11018" href="1Lab.Univalence.SIP.html#10984" class="Bound">s₁</a><a id="11020" class="Symbol">)</a>     <span class="reasoning-step"><span class="as-written Function Operator"><a id="11026" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a id="11029" href="1Lab.Univalence.SIP.html#10968" class="Bound">path</a> <a id="11034" class="Symbol">_</a> <a id="11036" class="Symbol">_</a> <a id="11038" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
    <a id="11044" href="1Lab.Univalence.SIP.html#10961" class="Bound">B</a> <a id="11046" class="Symbol">.</a><a id="11047" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11051" class="Symbol">(</a><a id="11052" href="1Lab.Univalence.SIP.html#10965" class="Bound">f</a> <a id="11054" class="Symbol">.</a><a id="11055" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11059" href="1Lab.Univalence.SIP.html#10974" class="Bound">s</a><a id="11060" class="Symbol">)</a> <a id="11062" class="Symbol">(</a><a id="11063" href="1Lab.Univalence.SIP.html#10965" class="Bound">f</a> <a id="11065" class="Symbol">.</a><a id="11066" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11070" href="1Lab.Univalence.SIP.html#10984" class="Bound">s₁</a><a id="11072" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="11074" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a id="11077" href="1Lab.Path.html#19695" class="Function">ap₂</a> <a id="11081" class="Symbol">(</a><a id="11082" href="1Lab.Univalence.SIP.html#10961" class="Bound">B</a> <a id="11084" class="Symbol">.</a><a id="11085" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="11088" class="Symbol">)</a> <a id="11090" href="1Lab.Univalence.SIP.html#10981" class="Bound">p</a> <a id="11092" href="1Lab.Univalence.SIP.html#10993" class="Bound">q</a> <a id="11094" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
    <a id="11100" href="1Lab.Univalence.SIP.html#10961" class="Bound">B</a> <a id="11102" class="Symbol">.</a><a id="11103" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11107" href="1Lab.Univalence.SIP.html#10978" class="Bound">t</a>     <a id="11113" href="1Lab.Univalence.SIP.html#10989" class="Bound">t₁</a>     <a id="11120" href="1Lab.Path.html#45365" class="Function Operator">∎</a>
</pre>
<p>As an example, we equip the type of booleans with two ∞-magma structures, one given by conjunction, one by disjunction, and prove that <span class="Agda"><a href="Data.Bool.html#1190" class="Function">not</a></span> makes them equal as ∞-magmas:</p>
<div class="mathpar">
<pre class="Agda">  <a id="11336" class="Keyword">open</a> <a id="11341" class="Keyword">import</a> <a id="11348" href="Data.Bool.html" class="Module">Data.Bool</a>
</pre>
</pre>
</div>
<div class="mathpar">
<pre class="Agda">  <a id="Conj"></a><a id="11406" href="1Lab.Univalence.SIP.html#11406" class="Function">Conj</a> <a id="11411" class="Symbol">:</a> <a id="11413" href="1Lab.Univalence.SIP.html#3349" class="Function">TypeWith</a> <a id="11422" href="1Lab.Univalence.SIP.html#9831" class="Function">∞-Magma</a>
  <a id="11432" href="1Lab.Univalence.SIP.html#11406" class="Function">Conj</a> <a id="11437" class="Symbol">.</a><a id="11438" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11442" class="Symbol">=</a> <a id="11444" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="11451" href="1Lab.Univalence.SIP.html#11406" class="Function">Conj</a> <a id="11456" class="Symbol">.</a><a id="11457" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11461" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11467" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11473" class="Symbol">=</a> <a id="11475" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="11483" href="1Lab.Univalence.SIP.html#11406" class="Function">Conj</a> <a id="11488" class="Symbol">.</a><a id="11489" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11493" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11499" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11505" class="Symbol">=</a> <a id="11507" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="11515" href="1Lab.Univalence.SIP.html#11406" class="Function">Conj</a> <a id="11520" class="Symbol">.</a><a id="11521" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11525" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11531" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11537" class="Symbol">=</a> <a id="11539" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="11547" href="1Lab.Univalence.SIP.html#11406" class="Function">Conj</a> <a id="11552" class="Symbol">.</a><a id="11553" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11557" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11563" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11569" class="Symbol">=</a> <a id="11571" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
</pre>
<pre class="Agda">  <a id="Disj"></a><a id="11591" href="1Lab.Univalence.SIP.html#11591" class="Function">Disj</a> <a id="11596" class="Symbol">:</a> <a id="11598" href="1Lab.Univalence.SIP.html#3349" class="Function">TypeWith</a> <a id="11607" href="1Lab.Univalence.SIP.html#9831" class="Function">∞-Magma</a>
  <a id="11617" href="1Lab.Univalence.SIP.html#11591" class="Function">Disj</a> <a id="11622" class="Symbol">.</a><a id="11623" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11627" class="Symbol">=</a> <a id="11629" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="11636" href="1Lab.Univalence.SIP.html#11591" class="Function">Disj</a> <a id="11641" class="Symbol">.</a><a id="11642" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11646" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11652" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11658" class="Symbol">=</a> <a id="11660" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="11668" href="1Lab.Univalence.SIP.html#11591" class="Function">Disj</a> <a id="11673" class="Symbol">.</a><a id="11674" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11678" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11684" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11690" class="Symbol">=</a> <a id="11692" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="11699" href="1Lab.Univalence.SIP.html#11591" class="Function">Disj</a> <a id="11704" class="Symbol">.</a><a id="11705" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11709" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11715" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11721" class="Symbol">=</a> <a id="11723" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="11730" href="1Lab.Univalence.SIP.html#11591" class="Function">Disj</a> <a id="11735" class="Symbol">.</a><a id="11736" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11740" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11746" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11752" class="Symbol">=</a> <a id="11754" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
</pre>
</div>
<p>I claim that <span class="Agda"><a href="Data.Bool.html#1190" class="Function">not</a></span> is a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magma isomorphism between <span class="Agda"><a href="1Lab.Univalence.SIP.html#11406" class="Function">Conj</a></span> and <span class="Agda"><a href="1Lab.Univalence.SIP.html#11591" class="Function">Disj</a></span>:</p>
<pre class="Agda">  <a id="not-iso"></a><a id="11881" href="1Lab.Univalence.SIP.html#11881" class="Function">not-iso</a> <a id="11889" class="Symbol">:</a> <a id="11891" href="1Lab.Univalence.SIP.html#11406" class="Function">Conj</a> <a id="11896" href="1Lab.Univalence.SIP.html#4237" class="Function Operator">≃[</a> <a id="11899" href="1Lab.Univalence.SIP.html#9831" class="Function">∞-Magma</a> <a id="11907" href="1Lab.Univalence.SIP.html#4237" class="Function Operator">]</a> <a id="11909" href="1Lab.Univalence.SIP.html#11591" class="Function">Disj</a>
  <a id="11916" href="1Lab.Univalence.SIP.html#11881" class="Function">not-iso</a> <a id="11924" class="Symbol">.</a><a id="11925" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11929" class="Symbol">=</a> <a id="11931" href="Data.Bool.html#1190" class="Function">not</a> <a id="11935" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11937" href="Data.Bool.html#7030" class="Function">isEquiv-not</a>
  <a id="11951" href="1Lab.Univalence.SIP.html#11881" class="Function">not-iso</a> <a id="11959" class="Symbol">.</a><a id="11960" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11964" class="Symbol">=</a> <a id="11966" href="1Lab.Univalence.SIP.html#10777" class="Function">fixup</a> <a id="11972" class="Symbol">{</a><a id="11973" class="Argument">A</a> <a id="11975" class="Symbol">=</a> <a id="11977" href="1Lab.Univalence.SIP.html#11406" class="Function">Conj</a><a id="11981" class="Symbol">}</a> <a id="11983" class="Symbol">{</a><a id="11984" class="Argument">B</a> <a id="11986" class="Symbol">=</a> <a id="11988" href="1Lab.Univalence.SIP.html#11591" class="Function">Disj</a><a id="11992" class="Symbol">}</a> <a id="11994" class="Symbol">{</a><a id="11995" class="Argument">f</a> <a id="11997" class="Symbol">=</a> <a id="11999" class="Symbol">_</a> <a id="12001" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="12003" href="Data.Bool.html#7030" class="Function">isEquiv-not</a><a id="12014" class="Symbol">}</a> <a id="12016" class="Symbol">λ</a> <a id="12018" class="Keyword">where</a>
    <a id="12028" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12034" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12040" class="Symbol">→</a> <a id="12042" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a id="12051" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12057" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="12062" class="Symbol">→</a> <a id="12064" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a id="12073" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="12078" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12084" class="Symbol">→</a> <a id="12086" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a id="12095" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="12100" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="12105" class="Symbol">→</a> <a id="12107" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>It’s not clear that this should be the case, especially since the case analysis obfuscates the result further. However, writing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\land</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∧</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∨</mo></mrow><annotation encoding="application/x-tex">\lor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∨</span></span></span></span> for the actions of <span class="Agda"><a href="1Lab.Univalence.SIP.html#11406" class="Function">Conj</a></span> and <span class="Agda"><a href="1Lab.Univalence.SIP.html#11591" class="Function">Disj</a></span> (as one should!), then we see that <span class="Agda"><a href="1Lab.Univalence.SIP.html#11881" class="Function">not-iso</a></span> says exactly that</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>x</mi><mo>∧</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">¬</mi><mi>x</mi><mo>∨</mo><mi mathvariant="normal">¬</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">\neg (x \land y) = \neg x \lor \neg y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">¬</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></span></p>
<p>From this and the SIP we get that <span class="Agda"><a href="1Lab.Univalence.SIP.html#11406" class="Function">Conj</a></span> and <span class="Agda"><a href="1Lab.Univalence.SIP.html#11591" class="Function">Disj</a></span> are the same <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magma:</p>
<pre class="Agda">  <a id="Conj≡Disj"></a><a id="12537" href="1Lab.Univalence.SIP.html#12537" class="Function">Conj≡Disj</a> <a id="12547" class="Symbol">:</a> <a id="12549" href="1Lab.Univalence.SIP.html#11406" class="Function">Conj</a> <a id="12554" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="12556" href="1Lab.Univalence.SIP.html#11591" class="Function">Disj</a>
  <a id="12563" href="1Lab.Univalence.SIP.html#12537" class="Function">Conj≡Disj</a> <a id="12573" class="Symbol">=</a> <a id="12575" href="1Lab.Univalence.SIP.html#5521" class="Function">sip</a> <a id="12579" href="1Lab.Univalence.SIP.html#9945" class="Function">∞-Magma-univ</a> <a id="12592" href="1Lab.Univalence.SIP.html#11881" class="Function">not-iso</a>
</pre>
<p>We have a similar phenomenon that happens with NAND and NOR:</p>
<div class="mathpar">
<pre class="Agda">  <a id="Nand"></a><a id="12697" href="1Lab.Univalence.SIP.html#12697" class="Function">Nand</a> <a id="12702" class="Symbol">:</a> <a id="12704" href="1Lab.Univalence.SIP.html#3349" class="Function">TypeWith</a> <a id="12713" href="1Lab.Univalence.SIP.html#9831" class="Function">∞-Magma</a>
  <a id="12723" href="1Lab.Univalence.SIP.html#12697" class="Function">Nand</a> <a id="12728" class="Symbol">.</a><a id="12729" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="12733" class="Symbol">=</a> <a id="12735" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="12742" href="1Lab.Univalence.SIP.html#12697" class="Function">Nand</a> <a id="12747" class="Symbol">.</a><a id="12748" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="12752" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12758" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12764" class="Symbol">=</a> <a id="12766" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="12773" href="1Lab.Univalence.SIP.html#12697" class="Function">Nand</a> <a id="12778" class="Symbol">.</a><a id="12779" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="12783" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12789" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="12795" class="Symbol">=</a> <a id="12797" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="12804" href="1Lab.Univalence.SIP.html#12697" class="Function">Nand</a> <a id="12809" class="Symbol">.</a><a id="12810" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="12814" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="12820" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12826" class="Symbol">=</a> <a id="12828" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="12835" href="1Lab.Univalence.SIP.html#12697" class="Function">Nand</a> <a id="12840" class="Symbol">.</a><a id="12841" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="12845" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="12851" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="12857" class="Symbol">=</a> <a id="12859" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
</pre>
<pre class="Agda">  <a id="Nor"></a><a id="12880" href="1Lab.Univalence.SIP.html#12880" class="Function">Nor</a> <a id="12884" class="Symbol">:</a> <a id="12886" href="1Lab.Univalence.SIP.html#3349" class="Function">TypeWith</a> <a id="12895" href="1Lab.Univalence.SIP.html#9831" class="Function">∞-Magma</a>
  <a id="12905" href="1Lab.Univalence.SIP.html#12880" class="Function">Nor</a> <a id="12909" class="Symbol">.</a><a id="12910" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="12914" class="Symbol">=</a> <a id="12916" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="12923" href="1Lab.Univalence.SIP.html#12880" class="Function">Nor</a> <a id="12927" class="Symbol">.</a><a id="12928" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="12932" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12938" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12944" class="Symbol">=</a> <a id="12946" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="12953" href="1Lab.Univalence.SIP.html#12880" class="Function">Nor</a> <a id="12957" class="Symbol">.</a><a id="12958" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="12962" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12968" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="12974" class="Symbol">=</a> <a id="12976" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="12984" href="1Lab.Univalence.SIP.html#12880" class="Function">Nor</a> <a id="12988" class="Symbol">.</a><a id="12989" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="12993" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="12999" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="13005" class="Symbol">=</a> <a id="13007" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="13015" href="1Lab.Univalence.SIP.html#12880" class="Function">Nor</a> <a id="13019" class="Symbol">.</a><a id="13020" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="13024" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="13030" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="13036" class="Symbol">=</a> <a id="13038" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
</pre>
</div>
<pre class="Agda">  <a id="not-iso&#39;"></a><a id="13066" href="1Lab.Univalence.SIP.html#13066" class="Function">not-iso&#39;</a> <a id="13075" class="Symbol">:</a> <a id="13077" href="1Lab.Univalence.SIP.html#12697" class="Function">Nand</a> <a id="13082" href="1Lab.Univalence.SIP.html#4237" class="Function Operator">≃[</a> <a id="13085" href="1Lab.Univalence.SIP.html#9831" class="Function">∞-Magma</a> <a id="13093" href="1Lab.Univalence.SIP.html#4237" class="Function Operator">]</a> <a id="13095" href="1Lab.Univalence.SIP.html#12880" class="Function">Nor</a>
  <a id="13101" href="1Lab.Univalence.SIP.html#13066" class="Function">not-iso&#39;</a> <a id="13110" class="Symbol">.</a><a id="13111" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="13115" class="Symbol">=</a> <a id="13117" href="Data.Bool.html#1190" class="Function">not</a> <a id="13121" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="13123" href="Data.Bool.html#7030" class="Function">isEquiv-not</a>
  <a id="13137" href="1Lab.Univalence.SIP.html#13066" class="Function">not-iso&#39;</a> <a id="13146" class="Symbol">.</a><a id="13147" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="13151" class="Symbol">=</a> <a id="13153" href="1Lab.Univalence.SIP.html#10777" class="Function">fixup</a> <a id="13159" class="Symbol">{</a><a id="13160" class="Argument">A</a> <a id="13162" class="Symbol">=</a> <a id="13164" href="1Lab.Univalence.SIP.html#12697" class="Function">Nand</a><a id="13168" class="Symbol">}</a> <a id="13170" class="Symbol">{</a><a id="13171" class="Argument">B</a> <a id="13173" class="Symbol">=</a> <a id="13175" href="1Lab.Univalence.SIP.html#12880" class="Function">Nor</a><a id="13178" class="Symbol">}</a> <a id="13180" class="Symbol">{</a><a id="13181" class="Argument">f</a> <a id="13183" class="Symbol">=</a> <a id="13185" class="Symbol">_</a> <a id="13187" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="13189" href="Data.Bool.html#7030" class="Function">isEquiv-not</a><a id="13200" class="Symbol">}</a> <a id="13202" class="Symbol">λ</a> <a id="13204" class="Keyword">where</a>
    <a id="13214" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="13220" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="13226" class="Symbol">→</a> <a id="13228" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a id="13237" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="13243" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="13248" class="Symbol">→</a> <a id="13250" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a id="13259" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="13264" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="13270" class="Symbol">→</a> <a id="13272" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a id="13281" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="13286" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="13291" class="Symbol">→</a> <a id="13293" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<h1 id="transport-structures">Transport Structures</h1>
<p>As an alternative to equipping a type family <code>S : Type → Type</code> with a notion of S-homomorphism, we can equip it with a notion of <em>action</em>. Equipping a structure with a notion of action canonically equips it with a notion of homomorphism:</p>
<pre class="Agda"><a id="EqvAction"></a><a id="13574" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="13584" class="Symbol">:</a> <a id="13586" class="Symbol">(</a><a id="13587" href="1Lab.Univalence.SIP.html#13587" class="Bound">S</a> <a id="13589" class="Symbol">:</a> <a id="13591" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13596" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="13598" class="Symbol">→</a> <a id="13600" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13605" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a><a id="13607" class="Symbol">)</a> <a id="13609" class="Symbol">→</a> <a id="13611" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13616" class="Symbol">_</a>
<a id="13618" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="13628" class="Symbol">{</a><a id="13629" class="Argument">ℓ</a> <a id="13631" class="Symbol">=</a> <a id="13633" href="1Lab.Univalence.SIP.html#13633" class="Bound">ℓ</a><a id="13634" class="Symbol">}</a> <a id="13636" href="1Lab.Univalence.SIP.html#13636" class="Bound">S</a> <a id="13638" class="Symbol">=</a> <a id="13640" class="Symbol">{</a><a id="13641" href="1Lab.Univalence.SIP.html#13641" class="Bound">X</a> <a id="13643" href="1Lab.Univalence.SIP.html#13643" class="Bound">Y</a> <a id="13645" class="Symbol">:</a> <a id="13647" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13652" href="1Lab.Univalence.SIP.html#13633" class="Bound">ℓ</a><a id="13653" class="Symbol">}</a> <a id="13655" class="Symbol">→</a> <a id="13657" class="Symbol">(</a><a id="13658" href="1Lab.Univalence.SIP.html#13641" class="Bound">X</a> <a id="13660" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="13662" href="1Lab.Univalence.SIP.html#13643" class="Bound">Y</a><a id="13663" class="Symbol">)</a> <a id="13665" class="Symbol">→</a> <a id="13667" class="Symbol">(</a><a id="13668" href="1Lab.Univalence.SIP.html#13636" class="Bound">S</a> <a id="13670" href="1Lab.Univalence.SIP.html#13641" class="Bound">X</a> <a id="13672" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="13674" href="1Lab.Univalence.SIP.html#13636" class="Bound">S</a> <a id="13676" href="1Lab.Univalence.SIP.html#13643" class="Bound">Y</a><a id="13677" class="Symbol">)</a>

<a id="Action→Structure"></a><a id="13680" href="1Lab.Univalence.SIP.html#13680" class="Function">Action→Structure</a> <a id="13697" class="Symbol">:</a> <a id="13699" class="Symbol">{</a><a id="13700" href="1Lab.Univalence.SIP.html#13700" class="Bound">S</a> <a id="13702" class="Symbol">:</a> <a id="13704" href="1Lab.Type.html#394" class="Primitive">Type</a>  <a id="13710" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="13712" class="Symbol">→</a> <a id="13714" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13719" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a><a id="13721" class="Symbol">}</a> <a id="13723" class="Symbol">→</a> <a id="13725" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="13735" href="1Lab.Univalence.SIP.html#13700" class="Bound">S</a> <a id="13737" class="Symbol">→</a> <a id="13739" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="13749" class="Symbol">_</a> <a id="13751" href="1Lab.Univalence.SIP.html#13700" class="Bound">S</a>
<a id="13753" href="1Lab.Univalence.SIP.html#13680" class="Function">Action→Structure</a> <a id="13770" href="1Lab.Univalence.SIP.html#13770" class="Bound">act</a> <a id="13774" class="Symbol">.</a><a id="13775" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="13782" class="Symbol">(</a><a id="13783" href="1Lab.Univalence.SIP.html#13783" class="Bound">A</a> <a id="13785" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="13787" href="1Lab.Univalence.SIP.html#13787" class="Bound">x</a><a id="13788" class="Symbol">)</a> <a id="13790" class="Symbol">(</a><a id="13791" href="1Lab.Univalence.SIP.html#13791" class="Bound">B</a> <a id="13793" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="13795" href="1Lab.Univalence.SIP.html#13795" class="Bound">y</a><a id="13796" class="Symbol">)</a> <a id="13798" href="1Lab.Univalence.SIP.html#13798" class="Bound">f</a> <a id="13800" class="Symbol">=</a> <a id="13802" href="1Lab.Univalence.SIP.html#13770" class="Bound">act</a> <a id="13806" href="1Lab.Univalence.SIP.html#13798" class="Bound">f</a> <a id="13808" class="Symbol">.</a><a id="13809" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="13813" href="1Lab.Univalence.SIP.html#13787" class="Bound">x</a> <a id="13815" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="13817" href="1Lab.Univalence.SIP.html#13795" class="Bound">y</a>
</pre>
<p>A <strong>transport structure</strong> is a structure <code>S : Type → Type</code> with a choice of equivalence action <code>α : EqvAction S</code> which agrees with the “intrinsic” notion of equivalence action that is induced by <a href="1Lab.Path.html#computation">the computation rules for transport</a>.</p>
<pre class="Agda"><a id="isTransportStr"></a><a id="14134" href="1Lab.Univalence.SIP.html#14134" class="Function">isTransportStr</a> <a id="14149" class="Symbol">:</a> <a id="14151" class="Symbol">{</a><a id="14152" href="1Lab.Univalence.SIP.html#14152" class="Bound">S</a> <a id="14154" class="Symbol">:</a> <a id="14156" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14161" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="14163" class="Symbol">→</a> <a id="14165" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14170" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a><a id="14172" class="Symbol">}</a> <a id="14174" class="Symbol">→</a> <a id="14176" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="14186" href="1Lab.Univalence.SIP.html#14152" class="Bound">S</a> <a id="14188" class="Symbol">→</a> <a id="14190" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14195" class="Symbol">_</a>
<a id="14197" href="1Lab.Univalence.SIP.html#14134" class="Function">isTransportStr</a> <a id="14212" class="Symbol">{</a><a id="14213" class="Argument">ℓ</a> <a id="14215" class="Symbol">=</a> <a id="14217" href="1Lab.Univalence.SIP.html#14217" class="Bound">ℓ</a><a id="14218" class="Symbol">}</a> <a id="14220" class="Symbol">{</a><a id="14221" class="Argument">S</a> <a id="14223" class="Symbol">=</a> <a id="14225" href="1Lab.Univalence.SIP.html#14225" class="Bound">S</a><a id="14226" class="Symbol">}</a> <a id="14228" href="1Lab.Univalence.SIP.html#14228" class="Bound">act</a> <a id="14232" class="Symbol">=</a>
  <a id="14236" class="Symbol">{</a><a id="14237" href="1Lab.Univalence.SIP.html#14237" class="Bound">X</a> <a id="14239" href="1Lab.Univalence.SIP.html#14239" class="Bound">Y</a> <a id="14241" class="Symbol">:</a> <a id="14243" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14248" href="1Lab.Univalence.SIP.html#14217" class="Bound">ℓ</a><a id="14249" class="Symbol">}</a> <a id="14251" class="Symbol">(</a><a id="14252" href="1Lab.Univalence.SIP.html#14252" class="Bound">e</a> <a id="14254" class="Symbol">:</a> <a id="14256" href="1Lab.Univalence.SIP.html#14237" class="Bound">X</a> <a id="14258" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="14260" href="1Lab.Univalence.SIP.html#14239" class="Bound">Y</a><a id="14261" class="Symbol">)</a> <a id="14263" class="Symbol">(</a><a id="14264" href="1Lab.Univalence.SIP.html#14264" class="Bound">s</a> <a id="14266" class="Symbol">:</a> <a id="14268" href="1Lab.Univalence.SIP.html#14225" class="Bound">S</a> <a id="14270" href="1Lab.Univalence.SIP.html#14237" class="Bound">X</a><a id="14271" class="Symbol">)</a> <a id="14273" class="Symbol">→</a> <a id="14275" href="1Lab.Univalence.SIP.html#14228" class="Bound">act</a> <a id="14279" href="1Lab.Univalence.SIP.html#14252" class="Bound">e</a> <a id="14281" class="Symbol">.</a><a id="14282" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="14286" href="1Lab.Univalence.SIP.html#14264" class="Bound">s</a> <a id="14288" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="14290" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="14296" href="1Lab.Univalence.SIP.html#14225" class="Bound">S</a> <a id="14298" class="Symbol">(</a><a id="14299" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="14302" href="1Lab.Univalence.SIP.html#14252" class="Bound">e</a><a id="14303" class="Symbol">)</a> <a id="14305" href="1Lab.Univalence.SIP.html#14264" class="Bound">s</a>
</pre>
<p>While the above definition of <code class="sourceCode agda">transport structure</code> is natural, it can sometimes be unwieldy to work with. Using <span class="Agda"><a href="1Lab.Univalence.html#19754" class="Function">univalence</a></span>, the condition for being a transport structure can be weakened to “preserves the identity equivalence”, with no loss of generality:</p>
<pre class="Agda"><a id="preservesId"></a><a id="14606" href="1Lab.Univalence.SIP.html#14606" class="Function">preservesId</a> <a id="14618" class="Symbol">:</a> <a id="14620" class="Symbol">{</a><a id="14621" href="1Lab.Univalence.SIP.html#14621" class="Bound">S</a> <a id="14623" class="Symbol">:</a> <a id="14625" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14630" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="14632" class="Symbol">→</a> <a id="14634" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14639" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a><a id="14640" class="Symbol">}</a> <a id="14642" class="Symbol">→</a> <a id="14644" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="14654" href="1Lab.Univalence.SIP.html#14621" class="Bound">S</a> <a id="14656" class="Symbol">→</a> <a id="14658" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14663" class="Symbol">_</a>
<a id="14665" href="1Lab.Univalence.SIP.html#14606" class="Function">preservesId</a> <a id="14677" class="Symbol">{</a><a id="14678" class="Argument">ℓ</a> <a id="14680" class="Symbol">=</a> <a id="14682" href="1Lab.Univalence.SIP.html#14682" class="Bound">ℓ</a><a id="14683" class="Symbol">}</a> <a id="14685" class="Symbol">{</a><a id="14686" class="Argument">S</a> <a id="14688" class="Symbol">=</a> <a id="14690" href="1Lab.Univalence.SIP.html#14690" class="Bound">S</a><a id="14691" class="Symbol">}</a> <a id="14693" href="1Lab.Univalence.SIP.html#14693" class="Bound">act</a> <a id="14697" class="Symbol">=</a>
  <a id="14701" class="Symbol">{</a><a id="14702" href="1Lab.Univalence.SIP.html#14702" class="Bound">X</a> <a id="14704" class="Symbol">:</a> <a id="14706" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14711" href="1Lab.Univalence.SIP.html#14682" class="Bound">ℓ</a><a id="14712" class="Symbol">}</a> <a id="14714" class="Symbol">(</a><a id="14715" href="1Lab.Univalence.SIP.html#14715" class="Bound">s</a> <a id="14717" class="Symbol">:</a> <a id="14719" href="1Lab.Univalence.SIP.html#14690" class="Bound">S</a> <a id="14721" href="1Lab.Univalence.SIP.html#14702" class="Bound">X</a><a id="14722" class="Symbol">)</a> <a id="14724" class="Symbol">→</a> <a id="14726" href="1Lab.Univalence.SIP.html#14693" class="Bound">act</a> <a id="14730" class="Symbol">(</a><a id="14731" href="1Lab.Type.html#2348" class="Function">id</a> <a id="14734" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="14736" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="14743" class="Symbol">)</a> <a id="14745" class="Symbol">.</a><a id="14746" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="14750" href="1Lab.Univalence.SIP.html#14715" class="Bound">s</a> <a id="14752" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="14754" href="1Lab.Univalence.SIP.html#14715" class="Bound">s</a>
</pre>
<p>The proof is by equivalence induction: To show something about all <code>Y : Type, x : X ≃ Y</code> (with X fixed), it suffices to cover the case where <code>Y</code> is <code>X</code> and <code>e</code> is the identity equivalence. This case is by the assumption that <span class="Agda"><a href="1Lab.Univalence.SIP.html#14606" class="Function">σ preserves id</a></span>.</p>
<pre class="Agda"><a id="preservesId→isTransportStr"></a><a id="15038" href="1Lab.Univalence.SIP.html#15038" class="Function">preservesId→isTransportStr</a> <a id="15065" class="Symbol">:</a> <a id="15067" class="Symbol">(</a><a id="15068" href="1Lab.Univalence.SIP.html#15068" class="Bound">σ</a> <a id="15070" class="Symbol">:</a> <a id="15072" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="15082" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a><a id="15083" class="Symbol">)</a> <a id="15085" class="Symbol">→</a> <a id="15087" href="1Lab.Univalence.SIP.html#14606" class="Function">preservesId</a> <a id="15099" href="1Lab.Univalence.SIP.html#15068" class="Bound">σ</a> <a id="15101" class="Symbol">→</a> <a id="15103" href="1Lab.Univalence.SIP.html#14134" class="Function">isTransportStr</a> <a id="15118" href="1Lab.Univalence.SIP.html#15068" class="Bound">σ</a>
<a id="15120" href="1Lab.Univalence.SIP.html#15038" class="Function">preservesId→isTransportStr</a> <a id="15147" class="Symbol">{</a><a id="15148" class="Argument">S</a> <a id="15150" class="Symbol">=</a> <a id="15152" href="1Lab.Univalence.SIP.html#15152" class="Bound">S</a><a id="15153" class="Symbol">}</a> <a id="15155" href="1Lab.Univalence.SIP.html#15155" class="Bound">σ</a> <a id="15157" href="1Lab.Univalence.SIP.html#15157" class="Bound">pres-id</a> <a id="15165" href="1Lab.Univalence.SIP.html#15165" class="Bound">e</a> <a id="15167" href="1Lab.Univalence.SIP.html#15167" class="Bound">s</a> <a id="15169" class="Symbol">=</a>
  <a id="15173" href="1Lab.Univalence.html#19754" class="Function">EquivJ</a> <a id="15180" class="Symbol">(λ</a> <a id="15183" href="1Lab.Univalence.SIP.html#15183" class="Bound">_</a> <a id="15185" href="1Lab.Univalence.SIP.html#15185" class="Bound">e</a> <a id="15187" class="Symbol">→</a> <a id="15189" href="1Lab.Univalence.SIP.html#15155" class="Bound">σ</a> <a id="15191" href="1Lab.Univalence.SIP.html#15185" class="Bound">e</a> <a id="15193" class="Symbol">.</a><a id="15194" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="15198" href="1Lab.Univalence.SIP.html#15167" class="Bound">s</a> <a id="15200" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="15202" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="15208" href="1Lab.Univalence.SIP.html#15152" class="Bound">S</a> <a id="15210" class="Symbol">(</a><a id="15211" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="15214" href="1Lab.Univalence.SIP.html#15185" class="Bound">e</a><a id="15215" class="Symbol">)</a> <a id="15217" href="1Lab.Univalence.SIP.html#15167" class="Bound">s</a><a id="15218" class="Symbol">)</a> <a id="15220" href="1Lab.Univalence.SIP.html#15414" class="Function">lemma&#39;</a> <a id="15227" href="1Lab.Univalence.SIP.html#15165" class="Bound">e</a>
  <a id="15231" class="Keyword">where</a>
</pre>
<p>Unfortunately we can not directly use the assumption that <code>σ</code> preserves <span class="Agda"><a href="1Lab.Type.html#2348" class="Function">id</a></span> in the proof, but it can be used as the final step in an equational proof:</p>
<pre class="Agda">    <a id="15414" href="1Lab.Univalence.SIP.html#15414" class="Function">lemma&#39;</a> <a id="15421" class="Symbol">:</a> <a id="15423" href="1Lab.Univalence.SIP.html#15155" class="Bound">σ</a> <a id="15425" class="Symbol">(</a><a id="15426" href="1Lab.Type.html#2348" class="Function">id</a> <a id="15429" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="15431" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15438" class="Symbol">)</a> <a id="15440" class="Symbol">.</a><a id="15441" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="15445" href="1Lab.Univalence.SIP.html#15167" class="Bound">s</a> <a id="15447" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="15449" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="15455" href="1Lab.Univalence.SIP.html#15152" class="Bound">S</a> <a id="15457" class="Symbol">(</a><a id="15458" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="15461" class="Symbol">(</a><a id="15462" href="1Lab.Type.html#2348" class="Function">id</a> <a id="15465" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="15467" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15474" class="Symbol">))</a> <a id="15477" href="1Lab.Univalence.SIP.html#15167" class="Bound">s</a>
    <a id="15483" href="1Lab.Univalence.SIP.html#15414" class="Function">lemma&#39;</a> <a id="15490" class="Symbol">=</a>
      <a id="15498" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="15502" class="Symbol">(</a>
        <a id="15512" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="15518" href="1Lab.Univalence.SIP.html#15152" class="Bound">S</a> <a id="15520" class="Symbol">(</a><a id="15521" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="15524" class="Symbol">(</a><a id="15525" href="1Lab.Type.html#2348" class="Function">id</a> <a id="15528" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="15530" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15537" class="Symbol">))</a> <a id="15540" href="1Lab.Univalence.SIP.html#15167" class="Bound">s</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="15542" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a id="15545" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="15548" class="Symbol">(λ</a> <a id="15551" href="1Lab.Univalence.SIP.html#15551" class="Bound">p</a> <a id="15553" class="Symbol">→</a> <a id="15555" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="15561" href="1Lab.Univalence.SIP.html#15152" class="Bound">S</a> <a id="15563" href="1Lab.Univalence.SIP.html#15551" class="Bound">p</a> <a id="15565" href="1Lab.Univalence.SIP.html#15167" class="Bound">s</a><a id="15566" class="Symbol">)</a> <a id="15568" href="1Lab.Univalence.html#16217" class="Function">uaIdEquiv</a> <a id="15578" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
        <a id="15588" href="1Lab.Path.html#10335" class="Function">transport</a> <a id="15598" href="1Lab.Path.html#2137" class="Function">refl</a> <a id="15603" href="1Lab.Univalence.SIP.html#15167" class="Bound">s</a>              <span class="reasoning-step"><span class="as-written Function Operator"><a id="15618" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a id="15621" href="1Lab.Path.html#12012" class="Function">transport-refl</a> <a id="15636" class="Symbol">_</a> <a id="15638" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
        <a id="15648" href="1Lab.Univalence.SIP.html#15167" class="Bound">s</a>                             <span class="reasoning-step"><span class="as-written Function Operator"><a id="15678" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a id="15681" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="15685" class="Symbol">(</a><a id="15686" href="1Lab.Univalence.SIP.html#15157" class="Bound">pres-id</a> <a id="15694" href="1Lab.Univalence.SIP.html#15167" class="Bound">s</a><a id="15695" class="Symbol">)</a> <a id="15697" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span> 
        <a id="15708" href="1Lab.Univalence.SIP.html#15155" class="Bound">σ</a> <a id="15710" class="Symbol">(</a><a id="15711" href="1Lab.Type.html#2348" class="Function">id</a> <a id="15714" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="15716" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15723" class="Symbol">)</a> <a id="15725" class="Symbol">.</a><a id="15726" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="15730" href="1Lab.Univalence.SIP.html#15167" class="Bound">s</a>       <a id="15738" href="1Lab.Path.html#45365" class="Function Operator">∎</a>
      <a id="15746" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda"><a id="transportStr⁻¹"></a><a id="15766" href="1Lab.Univalence.SIP.html#15766" class="Function">transportStr⁻¹</a> <a id="15781" class="Symbol">:</a>
  <a id="15785" class="Symbol">{</a><a id="15786" href="1Lab.Univalence.SIP.html#15786" class="Bound">S</a> <a id="15788" class="Symbol">:</a> <a id="15790" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15795" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="15797" class="Symbol">→</a> <a id="15799" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15804" href="1Lab.Univalence.SIP.html#3488" class="Generalizable">ℓ₂</a><a id="15806" class="Symbol">}</a> <a id="15808" class="Symbol">(</a><a id="15809" href="1Lab.Univalence.SIP.html#15809" class="Bound">α</a> <a id="15811" class="Symbol">:</a> <a id="15813" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="15823" href="1Lab.Univalence.SIP.html#15786" class="Bound">S</a><a id="15824" class="Symbol">)</a> <a id="15826" class="Symbol">(</a><a id="15827" href="1Lab.Univalence.SIP.html#15827" class="Bound">τ</a> <a id="15829" class="Symbol">:</a> <a id="15831" href="1Lab.Univalence.SIP.html#14134" class="Function">isTransportStr</a> <a id="15846" href="1Lab.Univalence.SIP.html#15809" class="Bound">α</a><a id="15847" class="Symbol">)</a>
  <a id="15851" class="Symbol">{</a><a id="15852" href="1Lab.Univalence.SIP.html#15852" class="Bound">X</a> <a id="15854" href="1Lab.Univalence.SIP.html#15854" class="Bound">Y</a> <a id="15856" class="Symbol">:</a> <a id="15858" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15863" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a><a id="15864" class="Symbol">}</a> <a id="15866" class="Symbol">(</a><a id="15867" href="1Lab.Univalence.SIP.html#15867" class="Bound">e</a> <a id="15869" class="Symbol">:</a> <a id="15871" href="1Lab.Univalence.SIP.html#15852" class="Bound">X</a> <a id="15873" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="15875" href="1Lab.Univalence.SIP.html#15854" class="Bound">Y</a><a id="15876" class="Symbol">)</a> <a id="15878" class="Symbol">(</a><a id="15879" href="1Lab.Univalence.SIP.html#15879" class="Bound">t</a> <a id="15881" class="Symbol">:</a> <a id="15883" href="1Lab.Univalence.SIP.html#15786" class="Bound">S</a> <a id="15885" href="1Lab.Univalence.SIP.html#15854" class="Bound">Y</a><a id="15886" class="Symbol">)</a>
  <a id="15890" class="Symbol">→</a> <a id="15892" href="1Lab.Equiv.html#6391" class="Function">equiv→inverse</a> <a id="15906" class="Symbol">(</a><a id="15907" href="1Lab.Univalence.SIP.html#15809" class="Bound">α</a> <a id="15909" href="1Lab.Univalence.SIP.html#15867" class="Bound">e</a> <a id="15911" class="Symbol">.</a><a id="15912" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="15915" class="Symbol">)</a> <a id="15917" href="1Lab.Univalence.SIP.html#15879" class="Bound">t</a> <a id="15919" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="15921" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="15927" href="1Lab.Univalence.SIP.html#15786" class="Bound">S</a> <a id="15929" class="Symbol">(</a><a id="15930" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="15934" class="Symbol">(</a><a id="15935" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="15938" href="1Lab.Univalence.SIP.html#15867" class="Bound">e</a><a id="15939" class="Symbol">))</a> <a id="15942" href="1Lab.Univalence.SIP.html#15879" class="Bound">t</a>
<a id="15944" href="1Lab.Univalence.SIP.html#15766" class="Function">transportStr⁻¹</a> <a id="15959" class="Symbol">{</a><a id="15960" class="Argument">S</a> <a id="15962" class="Symbol">=</a> <a id="15964" href="1Lab.Univalence.SIP.html#15964" class="Bound">S</a><a id="15965" class="Symbol">}</a> <a id="15967" href="1Lab.Univalence.SIP.html#15967" class="Bound">α</a> <a id="15969" href="1Lab.Univalence.SIP.html#15969" class="Bound">τ</a> <a id="15971" href="1Lab.Univalence.SIP.html#15971" class="Bound">e</a> <a id="15973" href="1Lab.Univalence.SIP.html#15973" class="Bound">t</a> <a id="15975" class="Symbol">=</a>
     <a id="15982" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="15986" class="Symbol">(</a><a id="15987" href="1Lab.Path.html#13290" class="Function">transport⁻Transport</a> <a id="16007" class="Symbol">(</a><a id="16008" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="16011" href="1Lab.Univalence.SIP.html#15964" class="Bound">S</a> <a id="16013" class="Symbol">(</a><a id="16014" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="16017" href="1Lab.Univalence.SIP.html#15971" class="Bound">e</a><a id="16018" class="Symbol">))</a> <a id="16021" class="Symbol">(</a><a id="16022" href="1Lab.Equiv.html#6391" class="Function">equiv→inverse</a> <a id="16036" class="Symbol">(</a><a id="16037" href="1Lab.Univalence.SIP.html#15967" class="Bound">α</a> <a id="16039" href="1Lab.Univalence.SIP.html#15971" class="Bound">e</a> <a id="16041" class="Symbol">.</a><a id="16042" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="16045" class="Symbol">)</a> <a id="16047" href="1Lab.Univalence.SIP.html#15973" class="Bound">t</a><a id="16048" class="Symbol">))</a>
  <a id="16053" href="1Lab.Path.html#36860" class="Function Operator">··</a> <a id="16056" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="16060" class="Symbol">(</a><a id="16061" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="16064" class="Symbol">(</a><a id="16065" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="16071" href="1Lab.Univalence.SIP.html#15964" class="Bound">S</a> <a id="16073" class="Symbol">(</a><a id="16074" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="16078" class="Symbol">(</a><a id="16079" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="16082" href="1Lab.Univalence.SIP.html#15971" class="Bound">e</a><a id="16083" class="Symbol">)))</a> <a id="16087" class="Symbol">(</a><a id="16088" href="1Lab.Univalence.SIP.html#15969" class="Bound">τ</a> <a id="16090" href="1Lab.Univalence.SIP.html#15971" class="Bound">e</a> <a id="16092" class="Symbol">(</a><a id="16093" href="1Lab.Equiv.html#6391" class="Function">equiv→inverse</a> <a id="16107" class="Symbol">(</a><a id="16108" href="1Lab.Univalence.SIP.html#15967" class="Bound">α</a> <a id="16110" href="1Lab.Univalence.SIP.html#15971" class="Bound">e</a> <a id="16112" class="Symbol">.</a><a id="16113" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="16116" class="Symbol">)</a> <a id="16118" href="1Lab.Univalence.SIP.html#15973" class="Bound">t</a><a id="16119" class="Symbol">)))</a>
  <a id="16125" href="1Lab.Path.html#36860" class="Function Operator">··</a> <a id="16128" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="16131" class="Symbol">(</a><a id="16132" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="16138" href="1Lab.Univalence.SIP.html#15964" class="Bound">S</a> <a id="16140" class="Symbol">(</a><a id="16141" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="16145" class="Symbol">(</a><a id="16146" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="16149" href="1Lab.Univalence.SIP.html#15971" class="Bound">e</a><a id="16150" class="Symbol">)))</a> <a id="16154" class="Symbol">(</a><a id="16155" href="1Lab.Equiv.html#6488" class="Function">equiv→section</a> <a id="16169" class="Symbol">(</a><a id="16170" href="1Lab.Univalence.SIP.html#15967" class="Bound">α</a> <a id="16172" href="1Lab.Univalence.SIP.html#15971" class="Bound">e</a> <a id="16174" class="Symbol">.</a><a id="16175" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="16178" class="Symbol">)</a> <a id="16180" href="1Lab.Univalence.SIP.html#15973" class="Bound">t</a><a id="16181" class="Symbol">)</a>
</pre>-->
<p>If <code>S</code> is a <code class="sourceCode agda" id="isTransportStr">transport structure</code>, then its canonical equipment as a <span class="Agda"><a href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a></span> is univalent:</p>
<pre class="Agda"><a id="isTransp→isUnivalent"></a><a id="16328" href="1Lab.Univalence.SIP.html#16328" class="Function">isTransp→isUnivalent</a> <a id="16349" class="Symbol">:</a> <a id="16351" class="Symbol">{</a><a id="16352" href="1Lab.Univalence.SIP.html#16352" class="Bound">S</a> <a id="16354" class="Symbol">:</a> <a id="16356" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="16361" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="16363" class="Symbol">→</a> <a id="16365" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="16370" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a><a id="16372" class="Symbol">}</a> <a id="16374" class="Symbol">(</a><a id="16375" href="1Lab.Univalence.SIP.html#16375" class="Bound">a</a> <a id="16377" class="Symbol">:</a> <a id="16379" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="16389" href="1Lab.Univalence.SIP.html#16352" class="Bound">S</a><a id="16390" class="Symbol">)</a>
                     <a id="16413" class="Symbol">→</a> <a id="16415" href="1Lab.Univalence.SIP.html#14134" class="Function">isTransportStr</a> <a id="16430" href="1Lab.Univalence.SIP.html#16375" class="Bound">a</a>
                     <a id="16453" class="Symbol">→</a> <a id="16455" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="16467" class="Symbol">(</a><a id="16468" href="1Lab.Univalence.SIP.html#13680" class="Function">Action→Structure</a> <a id="16485" href="1Lab.Univalence.SIP.html#16375" class="Bound">a</a><a id="16486" class="Symbol">)</a>
<a id="16488" href="1Lab.Univalence.SIP.html#16328" class="Function">isTransp→isUnivalent</a> <a id="16509" class="Symbol">{</a><a id="16510" class="Argument">S</a> <a id="16512" class="Symbol">=</a> <a id="16514" href="1Lab.Univalence.SIP.html#16514" class="Bound">S</a><a id="16515" class="Symbol">}</a> <a id="16517" href="1Lab.Univalence.SIP.html#16517" class="Bound">act</a> <a id="16521" href="1Lab.Univalence.SIP.html#16521" class="Bound">is-tr</a> <a id="16527" class="Symbol">{</a><a id="16528" href="1Lab.Univalence.SIP.html#16528" class="Bound">X</a> <a id="16530" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="16532" href="1Lab.Univalence.SIP.html#16532" class="Bound">s</a><a id="16533" class="Symbol">}</a> <a id="16535" class="Symbol">{</a><a id="16536" href="1Lab.Univalence.SIP.html#16536" class="Bound">Y</a> <a id="16538" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="16540" href="1Lab.Univalence.SIP.html#16540" class="Bound">t</a><a id="16541" class="Symbol">}</a> <a id="16543" href="1Lab.Univalence.SIP.html#16543" class="Bound">eqv</a> <a id="16547" class="Symbol">=</a>
  <a id="16551" href="1Lab.Univalence.SIP.html#16517" class="Bound">act</a> <a id="16555" href="1Lab.Univalence.SIP.html#16543" class="Bound">eqv</a> <a id="16559" class="Symbol">.</a><a id="16560" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="16564" href="1Lab.Univalence.SIP.html#16532" class="Bound">s</a> <a id="16566" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16568" href="1Lab.Univalence.SIP.html#16540" class="Bound">t</a>              <span class="reasoning-step"><span class="as-written Function Operator"><a id="16583" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a id="16586" href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a> <a id="16598" class="Symbol">(</a><a id="16599" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="16602" class="Symbol">(</a><a id="16603" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">_≡</a> <a id="16606" href="1Lab.Univalence.SIP.html#16540" class="Bound">t</a><a id="16607" class="Symbol">)</a> <a id="16609" class="Symbol">(</a><a id="16610" href="1Lab.Univalence.SIP.html#16521" class="Bound">is-tr</a> <a id="16616" href="1Lab.Univalence.SIP.html#16543" class="Bound">eqv</a> <a id="16620" href="1Lab.Univalence.SIP.html#16532" class="Bound">s</a><a id="16621" class="Symbol">))</a> <a id="16624" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="16628" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="16634" href="1Lab.Univalence.SIP.html#16514" class="Bound">S</a> <a id="16636" class="Symbol">(</a><a id="16637" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="16640" href="1Lab.Univalence.SIP.html#16543" class="Bound">eqv</a><a id="16643" class="Symbol">)</a> <a id="16645" href="1Lab.Univalence.SIP.html#16532" class="Bound">s</a> <a id="16647" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16649" href="1Lab.Univalence.SIP.html#16540" class="Bound">t</a>          <span class="reasoning-step"><span class="as-written Function Operator"><a id="16660" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a id="16663" href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a> <a id="16675" class="Symbol">(</a><a id="16676" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="16680" class="Symbol">(</a><a id="16681" href="1Lab.Path.html#47552" class="Function">PathP≡Path</a> <a id="16692" class="Symbol">(λ</a> <a id="16695" href="1Lab.Univalence.SIP.html#16695" class="Bound">i</a> <a id="16697" class="Symbol">→</a> <a id="16699" href="1Lab.Univalence.SIP.html#16514" class="Bound">S</a> <a id="16701" class="Symbol">(</a><a id="16702" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="16705" href="1Lab.Univalence.SIP.html#16543" class="Bound">eqv</a> <a id="16709" href="1Lab.Univalence.SIP.html#16695" class="Bound">i</a><a id="16710" class="Symbol">))</a> <a id="16713" href="1Lab.Univalence.SIP.html#16532" class="Bound">s</a> <a id="16715" href="1Lab.Univalence.SIP.html#16540" class="Bound">t</a><a id="16716" class="Symbol">))</a> <a id="16719" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="16723" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="16729" class="Symbol">(λ</a> <a id="16732" href="1Lab.Univalence.SIP.html#16732" class="Bound">i</a> <a id="16734" class="Symbol">→</a> <a id="16736" href="1Lab.Univalence.SIP.html#16514" class="Bound">S</a> <a id="16738" class="Symbol">(</a><a id="16739" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="16742" href="1Lab.Univalence.SIP.html#16543" class="Bound">eqv</a> <a id="16746" href="1Lab.Univalence.SIP.html#16732" class="Bound">i</a><a id="16747" class="Symbol">))</a> <a id="16750" href="1Lab.Univalence.SIP.html#16532" class="Bound">s</a> <a id="16752" href="1Lab.Univalence.SIP.html#16540" class="Bound">t</a>  <a id="16755" href="1Lab.Equiv.html#23023" class="Function Operator">≃∎</a>
</pre>
<p>We can mix and match these different notions of structure at will. For example, a more convenient definition of function univalent structure uses an equivalence action on the domain:</p>
<pre class="Agda"><a id="functionStr"></a><a id="16955" href="1Lab.Univalence.SIP.html#16955" class="Function">functionStr</a> <a id="16967" class="Symbol">:</a> <a id="16969" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="16979" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="16981" class="Symbol">→</a> <a id="16983" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="16993" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="16995" href="1Lab.Univalence.SIP.html#3519" class="Generalizable">T</a> <a id="16997" class="Symbol">→</a> <a id="16999" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="17009" class="Symbol">_</a> <a id="17011" class="Symbol">(λ</a> <a id="17014" href="1Lab.Univalence.SIP.html#17014" class="Bound">X</a> <a id="17016" class="Symbol">→</a> <a id="17018" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="17020" href="1Lab.Univalence.SIP.html#17014" class="Bound">X</a> <a id="17022" class="Symbol">→</a> <a id="17024" href="1Lab.Univalence.SIP.html#3519" class="Generalizable">T</a> <a id="17026" href="1Lab.Univalence.SIP.html#17014" class="Bound">X</a><a id="17027" class="Symbol">)</a>
<a id="17029" href="1Lab.Univalence.SIP.html#16955" class="Function">functionStr</a> <a id="17041" class="Symbol">{</a><a id="17042" class="Argument">S</a> <a id="17044" class="Symbol">=</a> <a id="17046" href="1Lab.Univalence.SIP.html#17046" class="Bound">S</a><a id="17047" class="Symbol">}</a> <a id="17049" href="1Lab.Univalence.SIP.html#17049" class="Bound">act</a> <a id="17053" href="1Lab.Univalence.SIP.html#17053" class="Bound">str</a> <a id="17057" class="Symbol">.</a><a id="17058" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="17065" class="Symbol">(</a><a id="17066" href="1Lab.Univalence.SIP.html#17066" class="Bound">A</a> <a id="17068" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17070" href="1Lab.Univalence.SIP.html#17070" class="Bound">f</a><a id="17071" class="Symbol">)</a> <a id="17073" class="Symbol">(</a><a id="17074" href="1Lab.Univalence.SIP.html#17074" class="Bound">B</a> <a id="17076" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17078" href="1Lab.Univalence.SIP.html#17078" class="Bound">g</a><a id="17079" class="Symbol">)</a> <a id="17081" href="1Lab.Univalence.SIP.html#17081" class="Bound">e</a> <a id="17083" class="Symbol">=</a>
  <a id="17087" class="Symbol">(</a><a id="17088" href="1Lab.Univalence.SIP.html#17088" class="Bound">s</a> <a id="17090" class="Symbol">:</a> <a id="17092" href="1Lab.Univalence.SIP.html#17046" class="Bound">S</a> <a id="17094" href="1Lab.Univalence.SIP.html#17066" class="Bound">A</a><a id="17095" class="Symbol">)</a> <a id="17097" class="Symbol">→</a> <a id="17099" href="1Lab.Univalence.SIP.html#17053" class="Bound">str</a> <a id="17103" class="Symbol">.</a><a id="17104" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="17111" class="Symbol">(</a><a id="17112" href="1Lab.Univalence.SIP.html#17066" class="Bound">A</a> <a id="17114" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17116" href="1Lab.Univalence.SIP.html#17070" class="Bound">f</a> <a id="17118" href="1Lab.Univalence.SIP.html#17088" class="Bound">s</a><a id="17119" class="Symbol">)</a> <a id="17121" class="Symbol">(</a><a id="17122" href="1Lab.Univalence.SIP.html#17074" class="Bound">B</a> <a id="17124" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17126" href="1Lab.Univalence.SIP.html#17078" class="Bound">g</a> <a id="17128" class="Symbol">(</a><a id="17129" href="1Lab.Univalence.SIP.html#17049" class="Bound">act</a> <a id="17133" href="1Lab.Univalence.SIP.html#17081" class="Bound">e</a> <a id="17135" class="Symbol">.</a><a id="17136" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="17140" href="1Lab.Univalence.SIP.html#17088" class="Bound">s</a><a id="17141" class="Symbol">))</a> <a id="17144" href="1Lab.Univalence.SIP.html#17081" class="Bound">e</a>
</pre>
<p>This alternative definition of structure is univalent when <code>T</code> is a univalent structure and <code>S</code> is a transport structure:</p>
<pre class="Agda"><a id="functionStr-univalent"></a><a id="17282" href="1Lab.Univalence.SIP.html#17282" class="Function">functionStr-univalent</a> <a id="17304" class="Symbol">:</a> <a id="17306" class="Symbol">(</a><a id="17307" href="1Lab.Univalence.SIP.html#17307" class="Bound">α</a> <a id="17309" class="Symbol">:</a> <a id="17311" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="17321" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a><a id="17322" class="Symbol">)</a> <a id="17324" class="Symbol">→</a> <a id="17326" href="1Lab.Univalence.SIP.html#14134" class="Function">isTransportStr</a> <a id="17341" href="1Lab.Univalence.SIP.html#17307" class="Bound">α</a>
                      <a id="17365" class="Symbol">→</a> <a id="17367" class="Symbol">(</a><a id="17368" href="1Lab.Univalence.SIP.html#17368" class="Bound">τ</a> <a id="17370" class="Symbol">:</a> <a id="17372" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="17382" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="17384" href="1Lab.Univalence.SIP.html#3519" class="Generalizable">T</a><a id="17385" class="Symbol">)</a> <a id="17387" class="Symbol">→</a> <a id="17389" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="17401" href="1Lab.Univalence.SIP.html#17368" class="Bound">τ</a>
                      <a id="17425" class="Symbol">→</a> <a id="17427" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="17439" class="Symbol">(</a><a id="17440" href="1Lab.Univalence.SIP.html#16955" class="Function">functionStr</a> <a id="17452" href="1Lab.Univalence.SIP.html#17307" class="Bound">α</a> <a id="17454" href="1Lab.Univalence.SIP.html#17368" class="Bound">τ</a><a id="17455" class="Symbol">)</a>
<a id="17457" href="1Lab.Univalence.SIP.html#17282" class="Function">functionStr-univalent</a> <a id="17479" class="Symbol">{</a><a id="17480" class="Argument">S</a> <a id="17482" class="Symbol">=</a> <a id="17484" href="1Lab.Univalence.SIP.html#17484" class="Bound">S</a><a id="17485" class="Symbol">}</a> <a id="17487" class="Symbol">{</a><a id="17488" class="Argument">T</a> <a id="17490" class="Symbol">=</a> <a id="17492" href="1Lab.Univalence.SIP.html#17492" class="Bound">T</a><a id="17493" class="Symbol">}</a> <a id="17495" href="1Lab.Univalence.SIP.html#17495" class="Bound">α</a> <a id="17497" href="1Lab.Univalence.SIP.html#17497" class="Bound">α-tr</a> <a id="17502" href="1Lab.Univalence.SIP.html#17502" class="Bound">τ</a> <a id="17504" href="1Lab.Univalence.SIP.html#17504" class="Bound">τ-univ</a> <a id="17511" class="Symbol">{</a><a id="17512" href="1Lab.Univalence.SIP.html#17512" class="Bound">X</a> <a id="17514" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17516" href="1Lab.Univalence.SIP.html#17516" class="Bound">f</a><a id="17517" class="Symbol">}</a> <a id="17519" class="Symbol">{</a><a id="17520" href="1Lab.Univalence.SIP.html#17520" class="Bound">Y</a> <a id="17522" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17524" href="1Lab.Univalence.SIP.html#17524" class="Bound">g</a><a id="17525" class="Symbol">}</a> <a id="17527" href="1Lab.Univalence.SIP.html#17527" class="Bound">eqv</a> <a id="17531" class="Symbol">=</a>
  <a id="17535" class="Symbol">((</a><a id="17537" href="1Lab.Univalence.SIP.html#17537" class="Bound">s</a> <a id="17539" class="Symbol">:</a> <a id="17541" href="1Lab.Univalence.SIP.html#17484" class="Bound">S</a> <a id="17543" href="1Lab.Univalence.SIP.html#17512" class="Bound">X</a><a id="17544" class="Symbol">)</a> <a id="17546" class="Symbol">→</a> <a id="17548" href="1Lab.Univalence.SIP.html#17502" class="Bound">τ</a> <a id="17550" class="Symbol">.</a><a id="17551" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="17558" class="Symbol">(</a><a id="17559" href="1Lab.Univalence.SIP.html#17512" class="Bound">X</a> <a id="17561" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17563" href="1Lab.Univalence.SIP.html#17516" class="Bound">f</a> <a id="17565" href="1Lab.Univalence.SIP.html#17537" class="Bound">s</a><a id="17566" class="Symbol">)</a> <a id="17568" class="Symbol">(</a><a id="17569" href="1Lab.Univalence.SIP.html#17520" class="Bound">Y</a> <a id="17571" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17573" class="Symbol">_)</a> <a id="17576" href="1Lab.Univalence.SIP.html#17527" class="Bound">eqv</a><a id="17579" class="Symbol">)</a>     <span class="reasoning-step"><span class="as-written Function Operator"><a id="17585" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a id="17588" href="1Lab.Type.Pi.html#663" class="Function">Π-cod≃</a> <a id="17595" class="Symbol">(λ</a> <a id="17598" href="1Lab.Univalence.SIP.html#17598" class="Bound">s</a> <a id="17600" class="Symbol">→</a> <a id="17602" href="1Lab.Univalence.SIP.html#17504" class="Bound">τ-univ</a> <a id="17609" href="1Lab.Univalence.SIP.html#17527" class="Bound">eqv</a> <a id="17613" href="1Lab.Equiv.html#21156" class="Function Operator">∙e</a> <a id="17616" href="1Lab.Univalence.html#15435" class="Function">pathToEquiv</a> <a id="17628" class="Symbol">(</a><a id="17629" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="17632" class="Symbol">(</a><a id="17633" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="17639" class="Symbol">(λ</a> <a id="17642" href="1Lab.Univalence.SIP.html#17642" class="Bound">i</a> <a id="17644" class="Symbol">→</a> <a id="17646" href="1Lab.Univalence.SIP.html#17492" class="Bound">T</a> <a id="17648" class="Symbol">(</a><a id="17649" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="17652" href="1Lab.Univalence.SIP.html#17527" class="Bound">eqv</a> <a id="17656" href="1Lab.Univalence.SIP.html#17642" class="Bound">i</a><a id="17657" class="Symbol">))</a> <a id="17660" class="Symbol">(</a><a id="17661" href="1Lab.Univalence.SIP.html#17516" class="Bound">f</a> <a id="17663" href="1Lab.Univalence.SIP.html#17598" class="Bound">s</a><a id="17664" class="Symbol">)</a> <a id="17666" href="1Lab.Type.html#2217" class="Function Operator">∘</a> <a id="17668" href="1Lab.Univalence.SIP.html#17524" class="Bound">g</a><a id="17669" class="Symbol">)</a> <a id="17671" class="Symbol">(</a><a id="17672" href="1Lab.Univalence.SIP.html#17497" class="Bound">α-tr</a> <a id="17677" class="Symbol">_</a> <a id="17679" class="Symbol">_)))</a> <a id="17684" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="17688" class="Symbol">((</a><a id="17690" href="1Lab.Univalence.SIP.html#17690" class="Bound">s</a> <a id="17692" class="Symbol">:</a> <a id="17694" href="1Lab.Univalence.SIP.html#17484" class="Bound">S</a> <a id="17696" href="1Lab.Univalence.SIP.html#17512" class="Bound">X</a><a id="17697" class="Symbol">)</a> <a id="17699" class="Symbol">→</a> <a id="17701" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="17707" class="Symbol">(λ</a> <a id="17710" href="1Lab.Univalence.SIP.html#17710" class="Bound">i</a> <a id="17712" class="Symbol">→</a> <a id="17714" href="1Lab.Univalence.SIP.html#17492" class="Bound">T</a> <a id="17716" class="Symbol">(</a><a id="17717" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="17720" href="1Lab.Univalence.SIP.html#17527" class="Bound">eqv</a> <a id="17724" href="1Lab.Univalence.SIP.html#17710" class="Bound">i</a><a id="17725" class="Symbol">))</a> <a id="17728" class="Symbol">(</a><a id="17729" href="1Lab.Univalence.SIP.html#17516" class="Bound">f</a> <a id="17731" href="1Lab.Univalence.SIP.html#17690" class="Bound">s</a><a id="17732" class="Symbol">)</a> <a id="17734" class="Symbol">_)</a>  <span class="reasoning-step"><span class="as-written Function Operator"><a id="17738" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a id="17741" class="Symbol">(</a><a id="17742" href="1Lab.Type.Pi.html#4266" class="Function">heteroHomotopy≃Homotopy</a> <a id="17766" href="1Lab.Equiv.html#21246" class="Function Operator">e⁻¹</a><a id="17769" class="Symbol">)</a> <a id="17771" href="1Lab.Equiv.html#21156" class="Function Operator">∙e</a> <a id="17774" href="1Lab.Type.Pi.html#3070" class="Function">funextDep≃</a> <a id="17785" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="17789" class="Symbol">_</a>                                                 <a id="17839" href="1Lab.Equiv.html#23023" class="Function Operator">≃∎</a>
</pre>
<p>To see why <span class="Agda"><a href="1Lab.Univalence.SIP.html#16955" class="Function">functionStr</a></span> is more convenient than <span class="Agda"><a href="1Lab.Univalence.SIP.html#8507" class="Function">the previous definition</a></span> - which is why it gets the shorter name - it’s convenient to consider how the <span class="Agda"><a href="1Lab.Univalence.SIP.html#7072" class="Function">pointed structure</a></span> acts on equivvalences: <em>not at all</em>. Recall the definition of ∞-magma equivalence generated by <span class="Agda"><a href="1Lab.Univalence.SIP.html#8507" class="Function">Str-functionStr</a></span>:</p>
<pre class="Agda"><a id="18228" class="Keyword">private</a>
  <a id="18238" href="1Lab.Univalence.SIP.html#18238" class="Function">_</a> <a id="18240" class="Symbol">:</a> <a id="18242" class="Symbol">{</a><a id="18243" href="1Lab.Univalence.SIP.html#18243" class="Bound">A</a> <a id="18245" href="1Lab.Univalence.SIP.html#18245" class="Bound">B</a> <a id="18247" class="Symbol">:</a> <a id="18249" href="1Lab.Univalence.SIP.html#3349" class="Function">TypeWith</a> <a id="18258" href="1Lab.Univalence.SIP.html#9831" class="Function">∞-Magma</a><a id="18265" class="Symbol">}</a> <a id="18267" class="Symbol">{</a><a id="18268" href="1Lab.Univalence.SIP.html#18268" class="Bound">f</a> <a id="18270" class="Symbol">:</a> <a id="18272" href="1Lab.Univalence.SIP.html#18243" class="Bound">A</a> <a id="18274" class="Symbol">.</a><a id="18275" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18279" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="18281" href="1Lab.Univalence.SIP.html#18245" class="Bound">B</a> <a id="18283" class="Symbol">.</a><a id="18284" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18287" class="Symbol">}</a>
    <a id="18293" class="Symbol">→</a> <a id="18295" href="1Lab.Univalence.SIP.html#9831" class="Function">∞-Magma</a> <a id="18303" class="Symbol">.</a><a id="18304" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="18311" href="1Lab.Univalence.SIP.html#18243" class="Bound">A</a> <a id="18313" href="1Lab.Univalence.SIP.html#18245" class="Bound">B</a> <a id="18315" href="1Lab.Univalence.SIP.html#18268" class="Bound">f</a>
    <a id="18321" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18323" class="Symbol">(</a> <a id="18325" class="Symbol">{</a><a id="18326" href="1Lab.Univalence.SIP.html#18326" class="Bound">s</a> <a id="18328" class="Symbol">:</a> <a id="18330" href="1Lab.Univalence.SIP.html#18243" class="Bound">A</a> <a id="18332" class="Symbol">.</a><a id="18333" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18336" class="Symbol">}</a> <a id="18338" class="Symbol">{</a><a id="18339" href="1Lab.Univalence.SIP.html#18339" class="Bound">t</a> <a id="18341" class="Symbol">:</a> <a id="18343" href="1Lab.Univalence.SIP.html#18245" class="Bound">B</a> <a id="18345" class="Symbol">.</a><a id="18346" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18349" class="Symbol">}</a> <a id="18351" class="Symbol">→</a> <a id="18353" href="1Lab.Univalence.SIP.html#18268" class="Bound">f</a> <a id="18355" class="Symbol">.</a><a id="18356" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18360" href="1Lab.Univalence.SIP.html#18326" class="Bound">s</a> <a id="18362" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18364" href="1Lab.Univalence.SIP.html#18339" class="Bound">t</a>
      <a id="18372" class="Symbol">→</a> <a id="18374" class="Symbol">{</a><a id="18375" href="1Lab.Univalence.SIP.html#18375" class="Bound">x</a> <a id="18377" class="Symbol">:</a> <a id="18379" href="1Lab.Univalence.SIP.html#18243" class="Bound">A</a> <a id="18381" class="Symbol">.</a><a id="18382" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18385" class="Symbol">}</a> <a id="18387" class="Symbol">{</a><a id="18388" href="1Lab.Univalence.SIP.html#18388" class="Bound">y</a> <a id="18390" class="Symbol">:</a> <a id="18392" href="1Lab.Univalence.SIP.html#18245" class="Bound">B</a> <a id="18394" class="Symbol">.</a><a id="18395" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18398" class="Symbol">}</a> <a id="18400" class="Symbol">→</a> <a id="18402" href="1Lab.Univalence.SIP.html#18268" class="Bound">f</a> <a id="18404" class="Symbol">.</a><a id="18405" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18409" href="1Lab.Univalence.SIP.html#18375" class="Bound">x</a> <a id="18411" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18413" href="1Lab.Univalence.SIP.html#18388" class="Bound">y</a>
      <a id="18421" class="Symbol">→</a> <a id="18423" href="1Lab.Univalence.SIP.html#18268" class="Bound">f</a> <a id="18425" class="Symbol">.</a><a id="18426" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18430" class="Symbol">(</a><a id="18431" href="1Lab.Univalence.SIP.html#18243" class="Bound">A</a> <a id="18433" class="Symbol">.</a><a id="18434" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18438" href="1Lab.Univalence.SIP.html#18326" class="Bound">s</a> <a id="18440" href="1Lab.Univalence.SIP.html#18375" class="Bound">x</a><a id="18441" class="Symbol">)</a> <a id="18443" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18445" href="1Lab.Univalence.SIP.html#18245" class="Bound">B</a> <a id="18447" class="Symbol">.</a><a id="18448" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18452" href="1Lab.Univalence.SIP.html#18339" class="Bound">t</a> <a id="18454" href="1Lab.Univalence.SIP.html#18388" class="Bound">y</a><a id="18455" class="Symbol">)</a>
  <a id="18459" class="Symbol">_</a> <a id="18461" class="Symbol">=</a> <a id="18463" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>Let’s rewrite <span class="Agda"><a href="1Lab.Univalence.SIP.html#9831" class="Function">∞-Magma</a></span> using <span class="Agda"><a href="1Lab.Univalence.SIP.html#16955" class="Function">functionStr</a></span> to see how it compares:</p>
<pre class="Agda">  <a id="∞-Magma′"></a><a id="18566" href="1Lab.Univalence.SIP.html#18566" class="Function">∞-Magma′</a> <a id="18575" class="Symbol">:</a> <a id="18577" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="18587" href="Agda.Primitive.html#764" class="Primitive">lzero</a> <a id="18593" href="1Lab.Univalence.SIP.html#9565" class="Function">binop</a>
  <a id="18601" href="1Lab.Univalence.SIP.html#18566" class="Function">∞-Magma′</a> <a id="18610" class="Symbol">=</a> <a id="18612" href="1Lab.Univalence.SIP.html#16955" class="Function">functionStr</a> <a id="18624" href="1Lab.Type.html#2348" class="Function">id</a> <a id="18627" class="Symbol">(</a><a id="18628" href="1Lab.Univalence.SIP.html#16955" class="Function">functionStr</a> <a id="18640" href="1Lab.Type.html#2348" class="Function">id</a> <a id="18643" href="1Lab.Univalence.SIP.html#7072" class="Function">pointedStr</a><a id="18653" class="Symbol">)</a>

  <a id="18658" href="1Lab.Univalence.SIP.html#18658" class="Function">_</a> <a id="18660" class="Symbol">:</a> <a id="18662" class="Symbol">{</a><a id="18663" href="1Lab.Univalence.SIP.html#18663" class="Bound">A</a> <a id="18665" href="1Lab.Univalence.SIP.html#18665" class="Bound">B</a> <a id="18667" class="Symbol">:</a> <a id="18669" href="1Lab.Univalence.SIP.html#3349" class="Function">TypeWith</a> <a id="18678" href="1Lab.Univalence.SIP.html#9831" class="Function">∞-Magma</a><a id="18685" class="Symbol">}</a> <a id="18687" class="Symbol">{</a><a id="18688" href="1Lab.Univalence.SIP.html#18688" class="Bound">f</a> <a id="18690" class="Symbol">:</a> <a id="18692" href="1Lab.Univalence.SIP.html#18663" class="Bound">A</a> <a id="18694" class="Symbol">.</a><a id="18695" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18699" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="18701" href="1Lab.Univalence.SIP.html#18665" class="Bound">B</a> <a id="18703" class="Symbol">.</a><a id="18704" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18707" class="Symbol">}</a>
    <a id="18713" class="Symbol">→</a> <a id="18715" href="1Lab.Univalence.SIP.html#18566" class="Function">∞-Magma′</a> <a id="18724" class="Symbol">.</a><a id="18725" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="18732" href="1Lab.Univalence.SIP.html#18663" class="Bound">A</a> <a id="18734" href="1Lab.Univalence.SIP.html#18665" class="Bound">B</a> <a id="18736" href="1Lab.Univalence.SIP.html#18688" class="Bound">f</a>
    <a id="18742" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18744" class="Symbol">(</a> <a id="18746" class="Symbol">(</a><a id="18747" href="1Lab.Univalence.SIP.html#18747" class="Bound">x</a> <a id="18749" href="1Lab.Univalence.SIP.html#18749" class="Bound">y</a> <a id="18751" class="Symbol">:</a> <a id="18753" href="1Lab.Univalence.SIP.html#18663" class="Bound">A</a> <a id="18755" class="Symbol">.</a><a id="18756" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18759" class="Symbol">)</a> <a id="18761" class="Symbol">→</a> <a id="18763" href="1Lab.Univalence.SIP.html#18688" class="Bound">f</a> <a id="18765" class="Symbol">.</a><a id="18766" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18770" class="Symbol">(</a><a id="18771" href="1Lab.Univalence.SIP.html#18663" class="Bound">A</a> <a id="18773" class="Symbol">.</a><a id="18774" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18778" href="1Lab.Univalence.SIP.html#18747" class="Bound">x</a> <a id="18780" href="1Lab.Univalence.SIP.html#18749" class="Bound">y</a><a id="18781" class="Symbol">)</a> <a id="18783" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18785" href="1Lab.Univalence.SIP.html#18665" class="Bound">B</a> <a id="18787" class="Symbol">.</a><a id="18788" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18792" class="Symbol">(</a><a id="18793" href="1Lab.Univalence.SIP.html#18688" class="Bound">f</a> <a id="18795" class="Symbol">.</a><a id="18796" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18800" href="1Lab.Univalence.SIP.html#18747" class="Bound">x</a><a id="18801" class="Symbol">)</a> <a id="18803" class="Symbol">(</a><a id="18804" href="1Lab.Univalence.SIP.html#18688" class="Bound">f</a> <a id="18806" class="Symbol">.</a><a id="18807" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18811" href="1Lab.Univalence.SIP.html#18749" class="Bound">y</a><a id="18812" class="Symbol">))</a>
  <a id="18817" class="Symbol">_</a> <a id="18819" class="Symbol">=</a> <a id="18821" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>Much better! This gets rid of all those redundant paths that were previously present, using the fact that <code>λ X → X</code> <em>does not need to act on equivalences</em>.</p>
<p>In general, transport structures are closed under all of the same operations as univalent structures, which begs the question: Why mention univalent structures at all? The reason is that a definition of structure homomorphism is very often needed, and the data of a univalent structure is perfect to use in the definition of <span class="Agda"><a href="1Lab.Univalence.SIP.html#4662" class="Function">SIP</a></span>.</p>
<details>
<summary>
The closure properties of transport structures are in this <code>&lt;details&gt;</code> tag to keep the length of the page shorter
</summary>
<pre class="Agda"><a id="constantAction"></a><a id="19481" href="1Lab.Univalence.SIP.html#19481" class="Function">constantAction</a> <a id="19496" class="Symbol">:</a> <a id="19498" class="Symbol">(</a><a id="19499" href="1Lab.Univalence.SIP.html#19499" class="Bound">A</a> <a id="19501" class="Symbol">:</a> <a id="19503" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19508" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a><a id="19509" class="Symbol">)</a> <a id="19511" class="Symbol">→</a> <a id="19513" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="19523" class="Symbol">{</a><a id="19524" class="Argument">ℓ</a> <a id="19526" class="Symbol">=</a> <a id="19528" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a><a id="19530" class="Symbol">}</a> <a id="19532" class="Symbol">(λ</a> <a id="19535" href="1Lab.Univalence.SIP.html#19535" class="Bound">X</a> <a id="19537" class="Symbol">→</a> <a id="19539" href="1Lab.Univalence.SIP.html#19499" class="Bound">A</a><a id="19540" class="Symbol">)</a>
<a id="19542" href="1Lab.Univalence.SIP.html#19481" class="Function">constantAction</a> <a id="19557" href="1Lab.Univalence.SIP.html#19557" class="Bound">A</a> <a id="19559" href="1Lab.Univalence.SIP.html#19559" class="Bound">eqv</a> <a id="19563" class="Symbol">=</a> <a id="19565" class="Symbol">_</a> <a id="19567" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19569" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>

<a id="constantAction-isTransp"></a><a id="19578" href="1Lab.Univalence.SIP.html#19578" class="Function">constantAction-isTransp</a> <a id="19602" class="Symbol">:</a> <a id="19604" class="Symbol">{</a><a id="19605" href="1Lab.Univalence.SIP.html#19605" class="Bound">A</a> <a id="19607" class="Symbol">:</a> <a id="19609" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19614" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a><a id="19615" class="Symbol">}</a> <a id="19617" class="Symbol">→</a> <a id="19619" href="1Lab.Univalence.SIP.html#14134" class="Function">isTransportStr</a> <a id="19634" class="Symbol">{</a><a id="19635" class="Argument">ℓ</a> <a id="19637" class="Symbol">=</a> <a id="19639" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a><a id="19641" class="Symbol">}</a> <a id="19643" class="Symbol">(</a><a id="19644" href="1Lab.Univalence.SIP.html#19481" class="Function">constantAction</a> <a id="19659" href="1Lab.Univalence.SIP.html#19605" class="Bound">A</a><a id="19660" class="Symbol">)</a>
<a id="19662" href="1Lab.Univalence.SIP.html#19578" class="Function">constantAction-isTransp</a> <a id="19686" href="1Lab.Univalence.SIP.html#19686" class="Bound">f</a> <a id="19688" href="1Lab.Univalence.SIP.html#19688" class="Bound">s</a> <a id="19690" class="Symbol">=</a> <a id="19692" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="19696" class="Symbol">(</a><a id="19697" href="1Lab.Path.html#12012" class="Function">transport-refl</a> <a id="19712" class="Symbol">_)</a>

<a id="idAction-isTransp"></a><a id="19716" href="1Lab.Univalence.SIP.html#19716" class="Function">idAction-isTransp</a> <a id="19734" class="Symbol">:</a> <a id="19736" href="1Lab.Univalence.SIP.html#14134" class="Function">isTransportStr</a> <a id="19751" class="Symbol">{</a><a id="19752" class="Argument">ℓ</a> <a id="19754" class="Symbol">=</a> <a id="19756" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a><a id="19757" class="Symbol">}</a> <a id="19759" class="Symbol">{</a><a id="19760" class="Argument">ℓ₁</a> <a id="19763" class="Symbol">=</a> <a id="19765" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a><a id="19766" class="Symbol">}</a> <a id="19768" href="1Lab.Type.html#2348" class="Function">id</a>
<a id="19771" href="1Lab.Univalence.SIP.html#19716" class="Function">idAction-isTransp</a> <a id="19789" href="1Lab.Univalence.SIP.html#19789" class="Bound">f</a> <a id="19791" href="1Lab.Univalence.SIP.html#19791" class="Bound">s</a> <a id="19793" class="Symbol">=</a> <a id="19795" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="19799" class="Symbol">(</a><a id="19800" href="1Lab.Path.html#12012" class="Function">transport-refl</a> <a id="19815" class="Symbol">_)</a>

<a id="productAction"></a><a id="19819" href="1Lab.Univalence.SIP.html#19819" class="Function">productAction</a> <a id="19833" class="Symbol">:</a> <a id="19835" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="19845" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="19847" class="Symbol">→</a> <a id="19849" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="19859" href="1Lab.Univalence.SIP.html#3519" class="Generalizable">T</a> <a id="19861" class="Symbol">→</a> <a id="19863" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="19873" class="Symbol">(λ</a> <a id="19876" href="1Lab.Univalence.SIP.html#19876" class="Bound">X</a> <a id="19878" class="Symbol">→</a> <a id="19880" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="19882" href="1Lab.Univalence.SIP.html#19876" class="Bound">X</a> <a id="19884" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="19886" href="1Lab.Univalence.SIP.html#3519" class="Generalizable">T</a> <a id="19888" href="1Lab.Univalence.SIP.html#19876" class="Bound">X</a><a id="19889" class="Symbol">)</a>
<a id="19891" href="1Lab.Univalence.SIP.html#19819" class="Function">productAction</a> <a id="19905" href="1Lab.Univalence.SIP.html#19905" class="Bound">actx</a> <a id="19910" href="1Lab.Univalence.SIP.html#19910" class="Bound">acty</a> <a id="19915" href="1Lab.Univalence.SIP.html#19915" class="Bound">eqv</a> <a id="19919" class="Symbol">=</a> <a id="19921" href="1Lab.Type.Sigma.html#2031" class="Function">Σ-ap</a> <a id="19926" class="Symbol">(</a><a id="19927" href="1Lab.Univalence.SIP.html#19905" class="Bound">actx</a> <a id="19932" href="1Lab.Univalence.SIP.html#19915" class="Bound">eqv</a><a id="19935" class="Symbol">)</a> <a id="19937" class="Symbol">λ</a> <a id="19939" href="1Lab.Univalence.SIP.html#19939" class="Bound">x</a> <a id="19941" class="Symbol">→</a> <a id="19943" href="1Lab.Univalence.SIP.html#19910" class="Bound">acty</a> <a id="19948" href="1Lab.Univalence.SIP.html#19915" class="Bound">eqv</a>

<a id="productAction-isTransp"></a><a id="19953" href="1Lab.Univalence.SIP.html#19953" class="Function">productAction-isTransp</a> <a id="19976" class="Symbol">:</a> <a id="19978" class="Symbol">{</a><a id="19979" href="1Lab.Univalence.SIP.html#19979" class="Bound">α</a> <a id="19981" class="Symbol">:</a> <a id="19983" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="19993" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a><a id="19994" class="Symbol">}</a> <a id="19996" class="Symbol">{</a><a id="19997" href="1Lab.Univalence.SIP.html#19997" class="Bound">β</a> <a id="19999" class="Symbol">:</a> <a id="20001" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="20011" href="1Lab.Univalence.SIP.html#3519" class="Generalizable">T</a><a id="20012" class="Symbol">}</a>
                       <a id="20037" class="Symbol">→</a> <a id="20039" href="1Lab.Univalence.SIP.html#14134" class="Function">isTransportStr</a> <a id="20054" href="1Lab.Univalence.SIP.html#19979" class="Bound">α</a> <a id="20056" class="Symbol">→</a> <a id="20058" href="1Lab.Univalence.SIP.html#14134" class="Function">isTransportStr</a> <a id="20073" href="1Lab.Univalence.SIP.html#19997" class="Bound">β</a>
                       <a id="20098" class="Symbol">→</a> <a id="20100" href="1Lab.Univalence.SIP.html#14134" class="Function">isTransportStr</a> <a id="20115" class="Symbol">(</a><a id="20116" href="1Lab.Univalence.SIP.html#19819" class="Function">productAction</a> <a id="20130" href="1Lab.Univalence.SIP.html#19979" class="Bound">α</a> <a id="20132" href="1Lab.Univalence.SIP.html#19997" class="Bound">β</a><a id="20133" class="Symbol">)</a>
<a id="20135" href="1Lab.Univalence.SIP.html#19953" class="Function">productAction-isTransp</a> <a id="20158" href="1Lab.Univalence.SIP.html#20158" class="Bound">α-tr</a> <a id="20163" href="1Lab.Univalence.SIP.html#20163" class="Bound">β-tr</a> <a id="20168" href="1Lab.Univalence.SIP.html#20168" class="Bound">e</a> <a id="20170" href="1Lab.Univalence.SIP.html#20170" class="Bound">s</a> <a id="20172" class="Symbol">=</a> <a id="20174" href="1Lab.Path.html#55230" class="Function">Σ-PathP</a> <a id="20182" class="Symbol">(</a><a id="20183" href="1Lab.Univalence.SIP.html#20158" class="Bound">α-tr</a> <a id="20188" href="1Lab.Univalence.SIP.html#20168" class="Bound">e</a> <a id="20190" class="Symbol">(</a><a id="20191" href="1Lab.Univalence.SIP.html#20170" class="Bound">s</a> <a id="20193" class="Symbol">.</a><a id="20194" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="20197" class="Symbol">))</a> <a id="20200" class="Symbol">(</a><a id="20201" href="1Lab.Univalence.SIP.html#20163" class="Bound">β-tr</a> <a id="20206" href="1Lab.Univalence.SIP.html#20168" class="Bound">e</a> <a id="20208" class="Symbol">(</a><a id="20209" href="1Lab.Univalence.SIP.html#20170" class="Bound">s</a> <a id="20211" class="Symbol">.</a><a id="20212" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="20215" class="Symbol">))</a>

<a id="functionAction"></a><a id="20219" href="1Lab.Univalence.SIP.html#20219" class="Function">functionAction</a> <a id="20234" class="Symbol">:</a> <a id="20236" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="20246" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="20248" class="Symbol">→</a> <a id="20250" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="20260" href="1Lab.Univalence.SIP.html#3519" class="Generalizable">T</a> <a id="20262" class="Symbol">→</a> <a id="20264" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="20274" class="Symbol">(λ</a> <a id="20277" href="1Lab.Univalence.SIP.html#20277" class="Bound">X</a> <a id="20279" class="Symbol">→</a> <a id="20281" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="20283" href="1Lab.Univalence.SIP.html#20277" class="Bound">X</a> <a id="20285" class="Symbol">→</a> <a id="20287" href="1Lab.Univalence.SIP.html#3519" class="Generalizable">T</a> <a id="20289" href="1Lab.Univalence.SIP.html#20277" class="Bound">X</a><a id="20290" class="Symbol">)</a>
<a id="20292" href="1Lab.Univalence.SIP.html#20219" class="Function">functionAction</a> <a id="20307" href="1Lab.Univalence.SIP.html#20307" class="Bound">actx</a> <a id="20312" href="1Lab.Univalence.SIP.html#20312" class="Bound">acty</a> <a id="20317" href="1Lab.Univalence.SIP.html#20317" class="Bound">eqv</a> <a id="20321" class="Symbol">=</a> <a id="20323" href="1Lab.Type.Pi.html#1721" class="Function">function≃</a> <a id="20333" class="Symbol">(</a><a id="20334" href="1Lab.Univalence.SIP.html#20307" class="Bound">actx</a> <a id="20339" href="1Lab.Univalence.SIP.html#20317" class="Bound">eqv</a><a id="20342" class="Symbol">)</a> <a id="20344" class="Symbol">(</a><a id="20345" href="1Lab.Univalence.SIP.html#20312" class="Bound">acty</a> <a id="20350" href="1Lab.Univalence.SIP.html#20317" class="Bound">eqv</a><a id="20353" class="Symbol">)</a>

<a id="functionAction-isTransp"></a><a id="20356" href="1Lab.Univalence.SIP.html#20356" class="Function">functionAction-isTransp</a> <a id="20380" class="Symbol">:</a> <a id="20382" class="Symbol">{</a><a id="20383" href="1Lab.Univalence.SIP.html#20383" class="Bound">α</a> <a id="20385" class="Symbol">:</a> <a id="20387" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="20397" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a><a id="20398" class="Symbol">}</a> <a id="20400" class="Symbol">{</a><a id="20401" href="1Lab.Univalence.SIP.html#20401" class="Bound">β</a> <a id="20403" class="Symbol">:</a> <a id="20405" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="20415" href="1Lab.Univalence.SIP.html#3519" class="Generalizable">T</a><a id="20416" class="Symbol">}</a>
                        <a id="20442" class="Symbol">→</a> <a id="20444" href="1Lab.Univalence.SIP.html#14134" class="Function">isTransportStr</a> <a id="20459" href="1Lab.Univalence.SIP.html#20383" class="Bound">α</a> <a id="20461" class="Symbol">→</a> <a id="20463" href="1Lab.Univalence.SIP.html#14134" class="Function">isTransportStr</a> <a id="20478" href="1Lab.Univalence.SIP.html#20401" class="Bound">β</a>
                        <a id="20504" class="Symbol">→</a> <a id="20506" href="1Lab.Univalence.SIP.html#14134" class="Function">isTransportStr</a> <a id="20521" class="Symbol">(</a><a id="20522" href="1Lab.Univalence.SIP.html#20219" class="Function">functionAction</a> <a id="20537" href="1Lab.Univalence.SIP.html#20383" class="Bound">α</a> <a id="20539" href="1Lab.Univalence.SIP.html#20401" class="Bound">β</a><a id="20540" class="Symbol">)</a>
<a id="20542" href="1Lab.Univalence.SIP.html#20356" class="Function">functionAction-isTransp</a> <a id="20566" class="Symbol">{</a><a id="20567" class="Argument">S</a> <a id="20569" class="Symbol">=</a> <a id="20571" href="1Lab.Univalence.SIP.html#20571" class="Bound">S</a><a id="20572" class="Symbol">}</a> <a id="20574" class="Symbol">{</a><a id="20575" class="Argument">α</a> <a id="20577" class="Symbol">=</a> <a id="20579" href="1Lab.Univalence.SIP.html#20579" class="Bound">α</a><a id="20580" class="Symbol">}</a> <a id="20582" class="Symbol">{</a><a id="20583" class="Argument">β</a> <a id="20585" class="Symbol">=</a> <a id="20587" href="1Lab.Univalence.SIP.html#20587" class="Bound">β</a><a id="20588" class="Symbol">}</a> <a id="20590" href="1Lab.Univalence.SIP.html#20590" class="Bound">α-tr</a> <a id="20595" href="1Lab.Univalence.SIP.html#20595" class="Bound">β-tr</a> <a id="20600" href="1Lab.Univalence.SIP.html#20600" class="Bound">eqv</a> <a id="20604" href="1Lab.Univalence.SIP.html#20604" class="Bound">f</a> <a id="20606" class="Symbol">=</a>
  <a id="20610" href="1Lab.Path.html#56431" class="Function">funext</a> <a id="20617" class="Symbol">λ</a> <a id="20619" href="1Lab.Univalence.SIP.html#20619" class="Bound">x</a> <a id="20621" class="Symbol">→</a> <a id="20623" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="20626" class="Symbol">(</a><a id="20627" href="1Lab.Univalence.SIP.html#20587" class="Bound">β</a> <a id="20629" href="1Lab.Univalence.SIP.html#20600" class="Bound">eqv</a> <a id="20633" class="Symbol">.</a><a id="20634" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="20638" href="1Lab.Type.html#2217" class="Function Operator">∘</a> <a id="20640" href="1Lab.Univalence.SIP.html#20604" class="Bound">f</a><a id="20641" class="Symbol">)</a> <a id="20643" class="Symbol">(</a><a id="20644" href="1Lab.Univalence.SIP.html#15766" class="Function">transportStr⁻¹</a> <a id="20659" href="1Lab.Univalence.SIP.html#20579" class="Bound">α</a> <a id="20661" href="1Lab.Univalence.SIP.html#20590" class="Bound">α-tr</a> <a id="20666" href="1Lab.Univalence.SIP.html#20600" class="Bound">eqv</a> <a id="20670" href="1Lab.Univalence.SIP.html#20619" class="Bound">x</a><a id="20671" class="Symbol">)</a>
             <a id="20686" href="1Lab.Path.html#38031" class="Function Operator">∙</a> <a id="20688" href="1Lab.Univalence.SIP.html#20595" class="Bound">β-tr</a> <a id="20693" href="1Lab.Univalence.SIP.html#20600" class="Bound">eqv</a> <a id="20697" class="Symbol">(</a><a id="20698" href="1Lab.Univalence.SIP.html#20604" class="Bound">f</a> <a id="20700" class="Symbol">(</a><a id="20701" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="20707" href="1Lab.Univalence.SIP.html#20571" class="Bound">S</a> <a id="20709" class="Symbol">(</a><a id="20710" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="20714" class="Symbol">(</a><a id="20715" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="20718" href="1Lab.Univalence.SIP.html#20600" class="Bound">eqv</a><a id="20721" class="Symbol">))</a> <a id="20724" href="1Lab.Univalence.SIP.html#20619" class="Bound">x</a><a id="20725" class="Symbol">))</a>
</pre>
</details>
<h1 id="adding-axioms">Adding Axioms</h1>
<p>Most mathematical objects of interest aren’t merely sets with structure. More often, the objects we’re interested in have <em>stuff</em> (the underlying type), <em>structure</em> (such as a <code class="sourceCode agda">SNS</code>), and <em>properties</em> - for instance, equations imposed on the structure. A concrete example may help:</p>
<ul class="incremental">
<li><p>A <strong>pointed <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magma</strong> is a pointed type equipped with a binary operation;</p></li>
<li><p>A <strong>monoid</strong> is a pointed <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magma with additional data witnessing that a) the type is a set; b) the operation is associative; and c) the point acts as a left- and right- identity for the operation.</p></li>
</ul>
<p>Fortunately, the SIP again applies here: If you augment a standard notion of structure with <em>axioms</em>, then equality of structures with axioms is still isomorphism of the underlying structures. For this, we require that the axioms be <a href="1Lab.HLevel.html#2594">valued in propositions</a>.</p>
<pre class="Agda"><a id="21638" class="Keyword">module</a> <a id="21645" href="1Lab.Univalence.SIP.html#21645" class="Module">_</a>
  <a id="21649" class="Symbol">(</a><a id="21650" href="1Lab.Univalence.SIP.html#21650" class="Bound">σ</a> <a id="21652" class="Symbol">:</a> <a id="21654" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="21664" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="21666" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a><a id="21667" class="Symbol">)</a>
  <a id="21671" class="Symbol">(</a><a id="21672" href="1Lab.Univalence.SIP.html#21672" class="Bound">axioms</a> <a id="21679" class="Symbol">:</a> <a id="21681" class="Symbol">(</a><a id="21682" href="1Lab.Univalence.SIP.html#21682" class="Bound">X</a> <a id="21684" class="Symbol">:</a> <a id="21686" class="Symbol">_)</a> <a id="21689" class="Symbol">→</a> <a id="21691" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="21693" href="1Lab.Univalence.SIP.html#21682" class="Bound">X</a> <a id="21695" class="Symbol">→</a> <a id="21697" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="21702" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">ℓ₃</a><a id="21704" class="Symbol">)</a>
  <a id="21708" class="Keyword">where</a>
</pre>
<p>First, the notion of structure that you get is just a lifting of the underlying structure <code>σ</code> to ignore the witnesses for the axioms:</p>
<pre class="Agda">  <a id="21864" href="1Lab.Univalence.SIP.html#21864" class="Function">axiomsStr</a> <a id="21874" class="Symbol">:</a> <a id="21876" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="21886" href="1Lab.Univalence.SIP.html#21664" class="Bound">ℓ</a> <a id="21888" class="Symbol">(λ</a> <a id="21891" href="1Lab.Univalence.SIP.html#21891" class="Bound">X</a> <a id="21893" class="Symbol">→</a> <a id="21895" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="21898" href="1Lab.Univalence.SIP.html#21898" class="Bound">s</a> <a id="21900" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="21902" href="1Lab.Univalence.SIP.html#21666" class="Bound">S</a> <a id="21904" href="1Lab.Univalence.SIP.html#21891" class="Bound">X</a> <a id="21906" href="1Lab.Type.html#1563" class="Function">]</a> <a id="21908" class="Symbol">(</a><a id="21909" href="1Lab.Univalence.SIP.html#21672" class="Bound">axioms</a> <a id="21916" href="1Lab.Univalence.SIP.html#21891" class="Bound">X</a> <a id="21918" href="1Lab.Univalence.SIP.html#21898" class="Bound">s</a><a id="21919" class="Symbol">))</a>
  <a id="21924" href="1Lab.Univalence.SIP.html#21864" class="Function">axiomsStr</a> <a id="21934" class="Symbol">.</a><a id="21935" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="21942" class="Symbol">(</a><a id="21943" href="1Lab.Univalence.SIP.html#21943" class="Bound">A</a> <a id="21945" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21947" href="1Lab.Univalence.SIP.html#21947" class="Bound">s</a> <a id="21949" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21951" href="1Lab.Univalence.SIP.html#21951" class="Bound">a</a><a id="21952" class="Symbol">)</a> <a id="21954" class="Symbol">(</a><a id="21955" href="1Lab.Univalence.SIP.html#21955" class="Bound">B</a> <a id="21957" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21959" href="1Lab.Univalence.SIP.html#21959" class="Bound">t</a> <a id="21961" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21963" href="1Lab.Univalence.SIP.html#21963" class="Bound">b</a><a id="21964" class="Symbol">)</a> <a id="21966" href="1Lab.Univalence.SIP.html#21966" class="Bound">f</a> <a id="21968" class="Symbol">=</a>
    <a id="21974" href="1Lab.Univalence.SIP.html#21650" class="Bound">σ</a> <a id="21976" class="Symbol">.</a><a id="21977" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="21984" class="Symbol">(</a><a id="21985" href="1Lab.Univalence.SIP.html#21943" class="Bound">A</a> <a id="21987" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21989" href="1Lab.Univalence.SIP.html#21947" class="Bound">s</a><a id="21990" class="Symbol">)</a> <a id="21992" class="Symbol">(</a><a id="21993" href="1Lab.Univalence.SIP.html#21955" class="Bound">B</a> <a id="21995" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21997" href="1Lab.Univalence.SIP.html#21959" class="Bound">t</a><a id="21998" class="Symbol">)</a> <a id="22000" href="1Lab.Univalence.SIP.html#21966" class="Bound">f</a>
</pre>
<p>Then, if the axioms are propositional, a calculation by equivalence reasoning concludes what we wanted: <span class="Agda"><a href="1Lab.Univalence.SIP.html#21864" class="Function">axiomsStr</a></span> is univalent.</p>
<pre class="Agda">  <a id="22155" class="Keyword">module</a> <a id="22162" href="1Lab.Univalence.SIP.html#22162" class="Module">_</a>
    <a id="22168" class="Symbol">(</a><a id="22169" href="1Lab.Univalence.SIP.html#22169" class="Bound">univ</a> <a id="22174" class="Symbol">:</a> <a id="22176" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="22188" href="1Lab.Univalence.SIP.html#21650" class="Bound">σ</a><a id="22189" class="Symbol">)</a>
    <a id="22195" class="Symbol">(</a><a id="22196" href="1Lab.Univalence.SIP.html#22196" class="Bound">axioms-prop</a> <a id="22208" class="Symbol">:</a> <a id="22210" class="Symbol">∀</a> <a id="22212" class="Symbol">{</a><a id="22213" href="1Lab.Univalence.SIP.html#22213" class="Bound">X</a><a id="22214" class="Symbol">}</a> <a id="22216" class="Symbol">{</a><a id="22217" href="1Lab.Univalence.SIP.html#22217" class="Bound">s</a><a id="22218" class="Symbol">}</a> <a id="22220" class="Symbol">→</a> <a id="22222" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="22229" class="Symbol">(</a><a id="22230" href="1Lab.Univalence.SIP.html#21672" class="Bound">axioms</a> <a id="22237" href="1Lab.Univalence.SIP.html#22213" class="Bound">X</a> <a id="22239" href="1Lab.Univalence.SIP.html#22217" class="Bound">s</a><a id="22240" class="Symbol">))</a> <a id="22243" class="Keyword">where</a>
    <a id="22253" href="1Lab.Univalence.SIP.html#22253" class="Function">axiomsStr-univalent</a> <a id="22273" class="Symbol">:</a> <a id="22275" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="22287" href="1Lab.Univalence.SIP.html#21864" class="Function">axiomsStr</a>
    <a id="22301" href="1Lab.Univalence.SIP.html#22253" class="Function">axiomsStr-univalent</a> <a id="22321" class="Symbol">{</a><a id="22322" class="Argument">X</a> <a id="22324" class="Symbol">=</a> <a id="22326" href="1Lab.Univalence.SIP.html#22326" class="Bound">A</a> <a id="22328" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22330" href="1Lab.Univalence.SIP.html#22330" class="Bound">s</a> <a id="22332" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22334" href="1Lab.Univalence.SIP.html#22334" class="Bound">a</a><a id="22335" class="Symbol">}</a> <a id="22337" class="Symbol">{</a><a id="22338" class="Argument">Y</a> <a id="22340" class="Symbol">=</a> <a id="22342" href="1Lab.Univalence.SIP.html#22342" class="Bound">B</a> <a id="22344" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22346" href="1Lab.Univalence.SIP.html#22346" class="Bound">t</a> <a id="22348" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22350" href="1Lab.Univalence.SIP.html#22350" class="Bound">b</a><a id="22351" class="Symbol">}</a> <a id="22353" href="1Lab.Univalence.SIP.html#22353" class="Bound">f</a> <a id="22355" class="Symbol">=</a>
      <a id="22363" href="1Lab.Univalence.SIP.html#21650" class="Bound">σ</a> <a id="22365" class="Symbol">.</a><a id="22366" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="22373" class="Symbol">(</a><a id="22374" href="1Lab.Univalence.SIP.html#22326" class="Bound">A</a> <a id="22376" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22378" href="1Lab.Univalence.SIP.html#22330" class="Bound">s</a><a id="22379" class="Symbol">)</a> <a id="22381" class="Symbol">(</a><a id="22382" href="1Lab.Univalence.SIP.html#22342" class="Bound">B</a> <a id="22384" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22386" href="1Lab.Univalence.SIP.html#22346" class="Bound">t</a><a id="22387" class="Symbol">)</a> <a id="22389" href="1Lab.Univalence.SIP.html#22353" class="Bound">f</a>
        <span class="reasoning-step"><span class="as-written Function Operator"><a id="22399" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a id="22402" href="1Lab.Univalence.SIP.html#22169" class="Bound">univ</a> <a id="22407" href="1Lab.Univalence.SIP.html#22353" class="Bound">f</a> <a id="22409" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
      <a id="22417" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="22423" class="Symbol">(λ</a> <a id="22426" href="1Lab.Univalence.SIP.html#22426" class="Bound">i</a> <a id="22428" class="Symbol">→</a> <a id="22430" href="1Lab.Univalence.SIP.html#21666" class="Bound">S</a> <a id="22432" class="Symbol">(</a><a id="22433" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="22436" href="1Lab.Univalence.SIP.html#22353" class="Bound">f</a> <a id="22438" href="1Lab.Univalence.SIP.html#22426" class="Bound">i</a><a id="22439" class="Symbol">))</a> <a id="22442" href="1Lab.Univalence.SIP.html#22330" class="Bound">s</a> <a id="22444" href="1Lab.Univalence.SIP.html#22346" class="Bound">t</a> 
        <span class="reasoning-step"><span class="as-written Function Operator"><a id="22455" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a id="22458" href="1Lab.Type.Sigma.html#6114" class="Function">Σ-contract</a> <a id="22469" class="Symbol">(λ</a> <a id="22472" href="1Lab.Univalence.SIP.html#22472" class="Bound">x</a> <a id="22474" class="Symbol">→</a> <a id="22476" href="1Lab.HLevel.html#9918" class="Function">isHLevelPathP</a> <a id="22490" class="Number">0</a> <a id="22492" class="Symbol">(</a><a id="22493" href="1Lab.HLevel.html#1382" class="InductiveConstructor">contr</a> <a id="22499" href="1Lab.Univalence.SIP.html#22350" class="Bound">b</a> <a id="22501" class="Symbol">(</a><a id="22502" href="1Lab.Univalence.SIP.html#22196" class="Bound">axioms-prop</a> <a id="22514" href="1Lab.Univalence.SIP.html#22350" class="Bound">b</a><a id="22515" class="Symbol">)))</a> <a id="22519" href="1Lab.Equiv.html#21246" class="Function Operator">e⁻¹</a> <a id="22523" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
      <a id="22531" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="22534" href="1Lab.Univalence.SIP.html#22534" class="Bound">p</a> <a id="22536" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="22538" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="22544" class="Symbol">(λ</a> <a id="22547" href="1Lab.Univalence.SIP.html#22547" class="Bound">i</a> <a id="22549" class="Symbol">→</a> <a id="22551" href="1Lab.Univalence.SIP.html#21666" class="Bound">S</a> <a id="22553" class="Symbol">(</a><a id="22554" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="22557" href="1Lab.Univalence.SIP.html#22353" class="Bound">f</a> <a id="22559" href="1Lab.Univalence.SIP.html#22547" class="Bound">i</a><a id="22560" class="Symbol">))</a> <a id="22563" href="1Lab.Univalence.SIP.html#22330" class="Bound">s</a> <a id="22565" href="1Lab.Univalence.SIP.html#22346" class="Bound">t</a> <a id="22567" href="1Lab.Type.html#1563" class="Function">]</a> <a id="22569" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="22575" class="Symbol">(λ</a> <a id="22578" href="1Lab.Univalence.SIP.html#22578" class="Bound">i</a> <a id="22580" class="Symbol">→</a> <a id="22582" href="1Lab.Univalence.SIP.html#21672" class="Bound">axioms</a> <a id="22589" class="Symbol">(</a><a id="22590" href="1Lab.Univalence.html#8768" class="Function">ua</a> <a id="22593" href="1Lab.Univalence.SIP.html#22353" class="Bound">f</a> <a id="22595" href="1Lab.Univalence.SIP.html#22578" class="Bound">i</a><a id="22596" class="Symbol">)</a> <a id="22598" class="Symbol">(</a><a id="22599" href="1Lab.Univalence.SIP.html#22534" class="Bound">p</a> <a id="22601" href="1Lab.Univalence.SIP.html#22578" class="Bound">i</a><a id="22602" class="Symbol">))</a> <a id="22605" href="1Lab.Univalence.SIP.html#22334" class="Bound">a</a> <a id="22607" href="1Lab.Univalence.SIP.html#22350" class="Bound">b</a>
        <span class="reasoning-step"><span class="as-written Function Operator"><a id="22617" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a id="22620" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a id="22630" href="1Lab.Type.Sigma.html#474" class="Function">Σ-PathP-iso</a> <a id="22642" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
      <a id="22650" class="Symbol">_</a>
        <a id="22660" href="1Lab.Equiv.html#23023" class="Function Operator">≃∎</a>
</pre>
<p>Here, another facet of the trade-offs between transport and univalent structures make themselves clear: It’s possible (albeit less than straightforward) to add axioms to a <em>univalent</em> structure, but without imposing further structure on the axioms themselves, it is not clear how to add axioms to a <em>transport</em> structure.</p>
<p>Regardless, a very useful consequence of the SIP is that axioms can be lifted from equivalent underlying structures. For instance: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> can be defined as both unary numbers (the construction of <code class="sourceCode agda">Nat</code>), or as binary numbers. If you prove that <code class="sourceCode agda">Nat</code> is a monoid, and <code>Nat ≃ Bin</code> as pointed ∞-magmas, then <code>Bin</code> inherits the monoid structure.</p>
<pre class="Agda"><a id="transferAxioms"></a><a id="23362" href="1Lab.Univalence.SIP.html#23362" class="Function">transferAxioms</a> 
  <a id="23380" class="Symbol">:</a> <a id="23382" class="Symbol">{</a><a id="23383" href="1Lab.Univalence.SIP.html#23383" class="Bound">σ</a> <a id="23385" class="Symbol">:</a> <a id="23387" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="23397" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="23399" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a><a id="23400" class="Symbol">}</a> <a id="23402" class="Symbol">{</a><a id="23403" href="1Lab.Univalence.SIP.html#23403" class="Bound">univ</a> <a id="23408" class="Symbol">:</a> <a id="23410" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="23422" href="1Lab.Univalence.SIP.html#23383" class="Bound">σ</a><a id="23423" class="Symbol">}</a>
    <a id="23429" class="Symbol">{</a><a id="23430" href="1Lab.Univalence.SIP.html#23430" class="Bound">axioms</a> <a id="23437" class="Symbol">:</a> <a id="23439" class="Symbol">(</a><a id="23440" href="1Lab.Univalence.SIP.html#23440" class="Bound">X</a> <a id="23442" class="Symbol">:</a> <a id="23444" class="Symbol">_)</a> <a id="23447" class="Symbol">→</a> <a id="23449" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="23451" href="1Lab.Univalence.SIP.html#23440" class="Bound">X</a> <a id="23453" class="Symbol">→</a> <a id="23455" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="23460" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">ℓ₃</a><a id="23462" class="Symbol">}</a>
  <a id="23466" class="Symbol">→</a> <a id="23468" class="Symbol">(</a><a id="23469" href="1Lab.Univalence.SIP.html#23469" class="Bound">A</a> <a id="23471" class="Symbol">:</a> <a id="23473" href="1Lab.Univalence.SIP.html#3349" class="Function">TypeWith</a> <a id="23482" class="Symbol">(</a><a id="23483" href="1Lab.Univalence.SIP.html#21864" class="Function">axiomsStr</a> <a id="23493" href="1Lab.Univalence.SIP.html#23383" class="Bound">σ</a> <a id="23495" href="1Lab.Univalence.SIP.html#23430" class="Bound">axioms</a><a id="23501" class="Symbol">))</a> <a id="23504" class="Symbol">(</a><a id="23505" href="1Lab.Univalence.SIP.html#23505" class="Bound">B</a> <a id="23507" class="Symbol">:</a> <a id="23509" href="1Lab.Univalence.SIP.html#3349" class="Function">TypeWith</a> <a id="23518" href="1Lab.Univalence.SIP.html#23383" class="Bound">σ</a><a id="23519" class="Symbol">)</a>
  <a id="23523" class="Symbol">→</a> <a id="23525" class="Symbol">(</a><a id="23526" href="1Lab.Univalence.SIP.html#23469" class="Bound">A</a> <a id="23528" class="Symbol">.</a><a id="23529" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="23533" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23535" href="1Lab.Univalence.SIP.html#23469" class="Bound">A</a> <a id="23537" class="Symbol">.</a><a id="23538" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23542" class="Symbol">.</a><a id="23543" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="23546" class="Symbol">)</a> <a id="23548" href="1Lab.Univalence.SIP.html#4237" class="Function Operator">≃[</a> <a id="23551" href="1Lab.Univalence.SIP.html#23383" class="Bound">σ</a> <a id="23553" href="1Lab.Univalence.SIP.html#4237" class="Function Operator">]</a> <a id="23555" href="1Lab.Univalence.SIP.html#23505" class="Bound">B</a>
  <a id="23559" class="Symbol">→</a> <a id="23561" href="1Lab.Univalence.SIP.html#23430" class="Bound">axioms</a> <a id="23568" class="Symbol">(</a><a id="23569" href="1Lab.Univalence.SIP.html#23505" class="Bound">B</a> <a id="23571" class="Symbol">.</a><a id="23572" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="23575" class="Symbol">)</a> <a id="23577" class="Symbol">(</a><a id="23578" href="1Lab.Univalence.SIP.html#23505" class="Bound">B</a> <a id="23580" class="Symbol">.</a><a id="23581" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="23584" class="Symbol">)</a>
<a id="23586" href="1Lab.Univalence.SIP.html#23362" class="Function">transferAxioms</a> <a id="23601" class="Symbol">{</a><a id="23602" class="Argument">univ</a> <a id="23607" class="Symbol">=</a> <a id="23609" href="1Lab.Univalence.SIP.html#23609" class="Bound">univ</a><a id="23613" class="Symbol">}</a> <a id="23615" class="Symbol">{</a><a id="23616" class="Argument">axioms</a> <a id="23623" class="Symbol">=</a> <a id="23625" href="1Lab.Univalence.SIP.html#23625" class="Bound">axioms</a><a id="23631" class="Symbol">}</a> <a id="23633" href="1Lab.Univalence.SIP.html#23633" class="Bound">A</a> <a id="23635" href="1Lab.Univalence.SIP.html#23635" class="Bound">B</a> <a id="23637" href="1Lab.Univalence.SIP.html#23637" class="Bound">eqv</a> <a id="23641" class="Symbol">=</a>
  <a id="23645" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="23651" class="Symbol">(λ</a> <a id="23654" class="Symbol">{</a> <a id="23656" class="Symbol">(</a><a id="23657" href="1Lab.Univalence.SIP.html#23657" class="Bound">x</a> <a id="23659" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23661" href="1Lab.Univalence.SIP.html#23661" class="Bound">y</a><a id="23662" class="Symbol">)</a> <a id="23664" class="Symbol">→</a> <a id="23666" href="1Lab.Univalence.SIP.html#23625" class="Bound">axioms</a> <a id="23673" href="1Lab.Univalence.SIP.html#23657" class="Bound">x</a> <a id="23675" href="1Lab.Univalence.SIP.html#23661" class="Bound">y</a> <a id="23677" class="Symbol">})</a> <a id="23680" class="Symbol">(</a><a id="23681" href="1Lab.Univalence.SIP.html#5521" class="Function">sip</a> <a id="23685" href="1Lab.Univalence.SIP.html#23609" class="Bound">univ</a> <a id="23690" href="1Lab.Univalence.SIP.html#23637" class="Bound">eqv</a><a id="23693" class="Symbol">)</a> <a id="23695" class="Symbol">(</a><a id="23696" href="1Lab.Univalence.SIP.html#23633" class="Bound">A</a> <a id="23698" class="Symbol">.</a><a id="23699" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23703" class="Symbol">.</a><a id="23704" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="23707" class="Symbol">)</a>
</pre>
<h1 id="a-language-for-structures">A Language for Structures</h1>
<p>The structure combinators can be abstracted away into a <em>language</em> for defining structures. A <span class="Agda"><a href="1Lab.Univalence.SIP.html#24012" class="Datatype">StrTm</a></span> describes a structure, that may be <code class="sourceCode agda" data-ident="interp">interpreted</code> into a family of types, and defines both transport and univalent structures.</p>
<pre class="Agda"><a id="24007" class="Keyword">data</a> <a id="StrTm"></a><a id="24012" href="1Lab.Univalence.SIP.html#24012" class="Datatype">StrTm</a> <a id="24018" href="1Lab.Univalence.SIP.html#24018" class="Bound">ℓ</a> <a id="24020" class="Symbol">:</a> <a id="24022" class="Symbol">(</a><a id="24023" href="1Lab.Univalence.SIP.html#24023" class="Bound">ℓ₁</a> <a id="24026" class="Symbol">:</a> <a id="24028" href="Agda.Primitive.html#597" class="Postulate">Level</a><a id="24033" class="Symbol">)</a> <a id="24035" class="Symbol">→</a> <a id="24037" class="Symbol">(</a><a id="24038" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24043" href="1Lab.Univalence.SIP.html#24018" class="Bound">ℓ</a> <a id="24045" class="Symbol">→</a> <a id="24047" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24052" href="1Lab.Univalence.SIP.html#24023" class="Bound">ℓ₁</a><a id="24054" class="Symbol">)</a> <a id="24056" class="Symbol">→</a> <a id="24058" href="1Lab.Type.html#409" class="Primitive">Typeω</a> <a id="24064" class="Keyword">where</a>
  <a id="StrTm.s-const"></a><a id="24072" href="1Lab.Univalence.SIP.html#24072" class="InductiveConstructor">s-const</a> <a id="24080" class="Symbol">:</a> <a id="24082" class="Symbol">∀</a> <a id="24084" class="Symbol">{</a><a id="24085" href="1Lab.Univalence.SIP.html#24085" class="Bound">ℓ₁</a><a id="24087" class="Symbol">}</a> <a id="24089" class="Symbol">(</a><a id="24090" href="1Lab.Univalence.SIP.html#24090" class="Bound">A</a> <a id="24092" class="Symbol">:</a> <a id="24094" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24099" href="1Lab.Univalence.SIP.html#24085" class="Bound">ℓ₁</a><a id="24101" class="Symbol">)</a> <a id="24103" class="Symbol">→</a> <a id="24105" href="1Lab.Univalence.SIP.html#24012" class="Datatype">StrTm</a> <a id="24111" href="1Lab.Univalence.SIP.html#24018" class="Bound">ℓ</a> <a id="24113" href="1Lab.Univalence.SIP.html#24085" class="Bound">ℓ₁</a> <a id="24116" class="Symbol">(λ</a> <a id="24119" href="1Lab.Univalence.SIP.html#24119" class="Bound">X</a> <a id="24121" class="Symbol">→</a> <a id="24123" href="1Lab.Univalence.SIP.html#24090" class="Bound">A</a><a id="24124" class="Symbol">)</a>
  <a id="StrTm.s∙"></a><a id="24128" href="1Lab.Univalence.SIP.html#24128" class="InductiveConstructor">s∙</a>      <a id="24136" class="Symbol">:</a> <a id="24138" href="1Lab.Univalence.SIP.html#24012" class="Datatype">StrTm</a> <a id="24144" href="1Lab.Univalence.SIP.html#24018" class="Bound">ℓ</a> <a id="24146" href="1Lab.Univalence.SIP.html#24018" class="Bound">ℓ</a> <a id="24148" class="Symbol">(λ</a> <a id="24151" href="1Lab.Univalence.SIP.html#24151" class="Bound">X</a> <a id="24153" class="Symbol">→</a> <a id="24155" href="1Lab.Univalence.SIP.html#24151" class="Bound">X</a><a id="24156" class="Symbol">)</a>
  <a id="StrTm._s→_"></a><a id="24160" href="1Lab.Univalence.SIP.html#24160" class="InductiveConstructor Operator">_s→_</a>    <a id="24168" class="Symbol">:</a> <a id="24170" class="Symbol">∀</a> <a id="24172" class="Symbol">{</a><a id="24173" href="1Lab.Univalence.SIP.html#24173" class="Bound">ℓ₁</a> <a id="24176" href="1Lab.Univalence.SIP.html#24176" class="Bound">ℓ₂</a><a id="24178" class="Symbol">}</a> <a id="24180" class="Symbol">{</a><a id="24181" href="1Lab.Univalence.SIP.html#24181" class="Bound">S</a><a id="24182" class="Symbol">}</a> <a id="24184" class="Symbol">{</a><a id="24185" href="1Lab.Univalence.SIP.html#24185" class="Bound">T</a><a id="24186" class="Symbol">}</a> <a id="24188" class="Symbol">→</a> <a id="24190" href="1Lab.Univalence.SIP.html#24012" class="Datatype">StrTm</a> <a id="24196" href="1Lab.Univalence.SIP.html#24018" class="Bound">ℓ</a> <a id="24198" href="1Lab.Univalence.SIP.html#24173" class="Bound">ℓ₁</a> <a id="24201" href="1Lab.Univalence.SIP.html#24181" class="Bound">S</a> <a id="24203" class="Symbol">→</a> <a id="24205" href="1Lab.Univalence.SIP.html#24012" class="Datatype">StrTm</a> <a id="24211" href="1Lab.Univalence.SIP.html#24018" class="Bound">ℓ</a> <a id="24213" href="1Lab.Univalence.SIP.html#24176" class="Bound">ℓ₂</a> <a id="24216" href="1Lab.Univalence.SIP.html#24185" class="Bound">T</a> <a id="24218" class="Symbol">→</a> <a id="24220" href="1Lab.Univalence.SIP.html#24012" class="Datatype">StrTm</a> <a id="24226" href="1Lab.Univalence.SIP.html#24018" class="Bound">ℓ</a> <a id="24228" class="Symbol">(</a><a id="24229" href="1Lab.Univalence.SIP.html#24173" class="Bound">ℓ₁</a> <a id="24232" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="24234" href="1Lab.Univalence.SIP.html#24176" class="Bound">ℓ₂</a><a id="24236" class="Symbol">)</a> <a id="24238" class="Symbol">(λ</a> <a id="24241" href="1Lab.Univalence.SIP.html#24241" class="Bound">X</a> <a id="24243" class="Symbol">→</a> <a id="24245" href="1Lab.Univalence.SIP.html#24181" class="Bound">S</a> <a id="24247" href="1Lab.Univalence.SIP.html#24241" class="Bound">X</a> <a id="24249" class="Symbol">→</a> <a id="24251" href="1Lab.Univalence.SIP.html#24185" class="Bound">T</a> <a id="24253" href="1Lab.Univalence.SIP.html#24241" class="Bound">X</a><a id="24254" class="Symbol">)</a>
  <a id="StrTm._s×_"></a><a id="24258" href="1Lab.Univalence.SIP.html#24258" class="InductiveConstructor Operator">_s×_</a>    <a id="24266" class="Symbol">:</a> <a id="24268" class="Symbol">∀</a> <a id="24270" class="Symbol">{</a><a id="24271" href="1Lab.Univalence.SIP.html#24271" class="Bound">ℓ₁</a> <a id="24274" href="1Lab.Univalence.SIP.html#24274" class="Bound">ℓ₂</a><a id="24276" class="Symbol">}</a> <a id="24278" class="Symbol">{</a><a id="24279" href="1Lab.Univalence.SIP.html#24279" class="Bound">S</a><a id="24280" class="Symbol">}</a> <a id="24282" class="Symbol">{</a><a id="24283" href="1Lab.Univalence.SIP.html#24283" class="Bound">T</a><a id="24284" class="Symbol">}</a> <a id="24286" class="Symbol">→</a> <a id="24288" href="1Lab.Univalence.SIP.html#24012" class="Datatype">StrTm</a> <a id="24294" href="1Lab.Univalence.SIP.html#24018" class="Bound">ℓ</a> <a id="24296" href="1Lab.Univalence.SIP.html#24271" class="Bound">ℓ₁</a> <a id="24299" href="1Lab.Univalence.SIP.html#24279" class="Bound">S</a> <a id="24301" class="Symbol">→</a> <a id="24303" href="1Lab.Univalence.SIP.html#24012" class="Datatype">StrTm</a> <a id="24309" href="1Lab.Univalence.SIP.html#24018" class="Bound">ℓ</a> <a id="24311" href="1Lab.Univalence.SIP.html#24274" class="Bound">ℓ₂</a> <a id="24314" href="1Lab.Univalence.SIP.html#24283" class="Bound">T</a> <a id="24316" class="Symbol">→</a> <a id="24318" href="1Lab.Univalence.SIP.html#24012" class="Datatype">StrTm</a> <a id="24324" href="1Lab.Univalence.SIP.html#24018" class="Bound">ℓ</a> <a id="24326" class="Symbol">(</a><a id="24327" href="1Lab.Univalence.SIP.html#24271" class="Bound">ℓ₁</a> <a id="24330" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="24332" href="1Lab.Univalence.SIP.html#24274" class="Bound">ℓ₂</a><a id="24334" class="Symbol">)</a> <a id="24336" class="Symbol">(λ</a> <a id="24339" href="1Lab.Univalence.SIP.html#24339" class="Bound">X</a> <a id="24341" class="Symbol">→</a> <a id="24343" href="1Lab.Univalence.SIP.html#24279" class="Bound">S</a> <a id="24345" href="1Lab.Univalence.SIP.html#24339" class="Bound">X</a> <a id="24347" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="24349" href="1Lab.Univalence.SIP.html#24283" class="Bound">T</a> <a id="24351" href="1Lab.Univalence.SIP.html#24339" class="Bound">X</a><a id="24352" class="Symbol">)</a>

<a id="24355" class="Keyword">infixr</a> <a id="24362" class="Number">30</a> <a id="24365" href="1Lab.Univalence.SIP.html#24160" class="InductiveConstructor Operator">_s→_</a> <a id="24370" href="1Lab.Univalence.SIP.html#24258" class="InductiveConstructor Operator">_s×_</a>
</pre>
<p>Since each term of the language corresponds to one of the combinators for building univalent structures, a pair of <em>mutually recursive</em> functions lets us derive a <span class="Agda"><a href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a></span> and an <span class="Agda"><a href="1Lab.Univalence.SIP.html#13574" class="Function">action on equivalences</a></span> from a term, at the same time.</p>
<pre class="Agda"><a id="tm→Structure"></a><a id="24657" href="1Lab.Univalence.SIP.html#24657" class="Function">tm→Structure</a> <a id="24670" class="Symbol">:</a> <a id="24672" class="Symbol">(</a><a id="24673" href="1Lab.Univalence.SIP.html#24673" class="Bound">s</a> <a id="24675" class="Symbol">:</a> <a id="24677" href="1Lab.Univalence.SIP.html#24012" class="Datatype">StrTm</a> <a id="24683" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="24685" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a> <a id="24688" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a><a id="24689" class="Symbol">)</a> <a id="24691" class="Symbol">→</a> <a id="24693" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="24703" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a> <a id="24706" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a>
<a id="tm→Action"></a><a id="24708" href="1Lab.Univalence.SIP.html#24708" class="Function">tm→Action</a> <a id="24718" class="Symbol">:</a> <a id="24720" class="Symbol">(</a><a id="24721" href="1Lab.Univalence.SIP.html#24721" class="Bound">s</a> <a id="24723" class="Symbol">:</a> <a id="24725" href="1Lab.Univalence.SIP.html#24012" class="Datatype">StrTm</a> <a id="24731" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="24733" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a> <a id="24736" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a><a id="24737" class="Symbol">)</a> <a id="24739" class="Symbol">→</a> <a id="24741" href="1Lab.Univalence.SIP.html#13574" class="Function">EqvAction</a> <a id="24751" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a>

<a id="24754" href="1Lab.Univalence.SIP.html#24657" class="Function">tm→Structure</a> <a id="24767" class="Symbol">(</a><a id="24768" href="1Lab.Univalence.SIP.html#24072" class="InductiveConstructor">s-const</a> <a id="24776" href="1Lab.Univalence.SIP.html#24776" class="Bound">x</a><a id="24777" class="Symbol">)</a> <a id="24779" class="Symbol">=</a> <a id="24781" href="1Lab.Univalence.SIP.html#6221" class="Function">constantStr</a> <a id="24793" href="1Lab.Univalence.SIP.html#24776" class="Bound">x</a>
<a id="24795" href="1Lab.Univalence.SIP.html#24657" class="Function">tm→Structure</a> <a id="24808" href="1Lab.Univalence.SIP.html#24128" class="InductiveConstructor">s∙</a> <a id="24811" class="Symbol">=</a> <a id="24813" href="1Lab.Univalence.SIP.html#7072" class="Function">pointedStr</a>
<a id="24824" href="1Lab.Univalence.SIP.html#24657" class="Function">tm→Structure</a> <a id="24837" class="Symbol">(</a><a id="24838" href="1Lab.Univalence.SIP.html#24838" class="Bound">s</a> <a id="24840" href="1Lab.Univalence.SIP.html#24160" class="InductiveConstructor Operator">s→</a> <a id="24843" href="1Lab.Univalence.SIP.html#24843" class="Bound">s₁</a><a id="24845" class="Symbol">)</a> <a id="24847" class="Symbol">=</a> <a id="24849" href="1Lab.Univalence.SIP.html#16955" class="Function">functionStr</a> <a id="24861" class="Symbol">(</a><a id="24862" href="1Lab.Univalence.SIP.html#24708" class="Function">tm→Action</a> <a id="24872" href="1Lab.Univalence.SIP.html#24838" class="Bound">s</a><a id="24873" class="Symbol">)</a> <a id="24875" class="Symbol">(</a><a id="24876" href="1Lab.Univalence.SIP.html#24657" class="Function">tm→Structure</a> <a id="24889" href="1Lab.Univalence.SIP.html#24843" class="Bound">s₁</a><a id="24891" class="Symbol">)</a>
<a id="24893" href="1Lab.Univalence.SIP.html#24657" class="Function">tm→Structure</a> <a id="24906" class="Symbol">(</a><a id="24907" href="1Lab.Univalence.SIP.html#24907" class="Bound">s</a> <a id="24909" href="1Lab.Univalence.SIP.html#24258" class="InductiveConstructor Operator">s×</a> <a id="24912" href="1Lab.Univalence.SIP.html#24912" class="Bound">s₁</a><a id="24914" class="Symbol">)</a> <a id="24916" class="Symbol">=</a> <a id="24918" href="1Lab.Univalence.SIP.html#7572" class="Function">productStr</a> <a id="24929" class="Symbol">(</a><a id="24930" href="1Lab.Univalence.SIP.html#24657" class="Function">tm→Structure</a> <a id="24943" href="1Lab.Univalence.SIP.html#24907" class="Bound">s</a><a id="24944" class="Symbol">)</a> <a id="24946" class="Symbol">(</a><a id="24947" href="1Lab.Univalence.SIP.html#24657" class="Function">tm→Structure</a> <a id="24960" href="1Lab.Univalence.SIP.html#24912" class="Bound">s₁</a><a id="24962" class="Symbol">)</a>

<a id="24965" href="1Lab.Univalence.SIP.html#24708" class="Function">tm→Action</a> <a id="24975" class="Symbol">(</a><a id="24976" href="1Lab.Univalence.SIP.html#24072" class="InductiveConstructor">s-const</a> <a id="24984" href="1Lab.Univalence.SIP.html#24984" class="Bound">x₁</a><a id="24986" class="Symbol">)</a> <a id="24988" href="1Lab.Univalence.SIP.html#24988" class="Bound">x</a> <a id="24990" class="Symbol">=</a> <a id="24992" class="Symbol">_</a> <a id="24994" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="24996" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>
<a id="25004" href="1Lab.Univalence.SIP.html#24708" class="Function">tm→Action</a> <a id="25014" href="1Lab.Univalence.SIP.html#24128" class="InductiveConstructor">s∙</a> <a id="25017" href="1Lab.Univalence.SIP.html#25017" class="Bound">x</a> <a id="25019" class="Symbol">=</a> <a id="25021" href="1Lab.Univalence.SIP.html#25017" class="Bound">x</a>
<a id="25023" href="1Lab.Univalence.SIP.html#24708" class="Function">tm→Action</a> <a id="25033" class="Symbol">(</a><a id="25034" href="1Lab.Univalence.SIP.html#25034" class="Bound">s</a> <a id="25036" href="1Lab.Univalence.SIP.html#24160" class="InductiveConstructor Operator">s→</a> <a id="25039" href="1Lab.Univalence.SIP.html#25039" class="Bound">s₁</a><a id="25041" class="Symbol">)</a> <a id="25043" class="Symbol">=</a> <a id="25045" href="1Lab.Univalence.SIP.html#20219" class="Function">functionAction</a> <a id="25060" class="Symbol">(</a><a id="25061" href="1Lab.Univalence.SIP.html#24708" class="Function">tm→Action</a> <a id="25071" href="1Lab.Univalence.SIP.html#25034" class="Bound">s</a><a id="25072" class="Symbol">)</a> <a id="25074" class="Symbol">(</a><a id="25075" href="1Lab.Univalence.SIP.html#24708" class="Function">tm→Action</a> <a id="25085" href="1Lab.Univalence.SIP.html#25039" class="Bound">s₁</a><a id="25087" class="Symbol">)</a>
<a id="25089" href="1Lab.Univalence.SIP.html#24708" class="Function">tm→Action</a> <a id="25099" class="Symbol">(</a><a id="25100" href="1Lab.Univalence.SIP.html#25100" class="Bound">s</a> <a id="25102" href="1Lab.Univalence.SIP.html#24258" class="InductiveConstructor Operator">s×</a> <a id="25105" href="1Lab.Univalence.SIP.html#25105" class="Bound">s₁</a><a id="25107" class="Symbol">)</a> <a id="25109" class="Symbol">=</a> <a id="25111" href="1Lab.Univalence.SIP.html#19819" class="Function">productAction</a> <a id="25125" class="Symbol">(</a><a id="25126" href="1Lab.Univalence.SIP.html#24708" class="Function">tm→Action</a> <a id="25136" href="1Lab.Univalence.SIP.html#25100" class="Bound">s</a><a id="25137" class="Symbol">)</a> <a id="25139" class="Symbol">(</a><a id="25140" href="1Lab.Univalence.SIP.html#24708" class="Function">tm→Action</a> <a id="25150" href="1Lab.Univalence.SIP.html#25105" class="Bound">s₁</a><a id="25152" class="Symbol">)</a>
</pre>
<p>The reason for this mutual recursion is the same reason that transport structures are considered in the first place: <span class="Agda"><a href="1Lab.Univalence.SIP.html#16955" class="Function">functionStr</a></span> gives much better results for the definition of homomorphism than can be gotten directly using <span class="Agda"><a href="1Lab.Univalence.SIP.html#8507" class="Function">Str-functionStr</a></span>. As an example of using the language, and the generated definition of homomorphism, consider pointed ∞-magmas:</p>
<pre class="Agda"><a id="25537" class="Keyword">private</a>
  <a id="Pointed∞Magma"></a><a id="25547" href="1Lab.Univalence.SIP.html#25547" class="Function">Pointed∞Magma</a> <a id="25561" class="Symbol">:</a> <a id="25563" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="25573" href="Agda.Primitive.html#764" class="Primitive">lzero</a> <a id="25579" class="Symbol">_</a>
  <a id="25583" href="1Lab.Univalence.SIP.html#25547" class="Function">Pointed∞Magma</a> <a id="25597" class="Symbol">=</a> <a id="25599" href="1Lab.Univalence.SIP.html#24657" class="Function">tm→Structure</a> <a id="25612" class="Symbol">(</a><a id="25613" href="1Lab.Univalence.SIP.html#24128" class="InductiveConstructor">s∙</a> <a id="25616" href="1Lab.Univalence.SIP.html#24258" class="InductiveConstructor Operator">s×</a> <a id="25619" class="Symbol">(</a><a id="25620" href="1Lab.Univalence.SIP.html#24128" class="InductiveConstructor">s∙</a> <a id="25623" href="1Lab.Univalence.SIP.html#24160" class="InductiveConstructor Operator">s→</a> <a id="25626" class="Symbol">(</a><a id="25627" href="1Lab.Univalence.SIP.html#24128" class="InductiveConstructor">s∙</a> <a id="25630" href="1Lab.Univalence.SIP.html#24160" class="InductiveConstructor Operator">s→</a> <a id="25633" href="1Lab.Univalence.SIP.html#24128" class="InductiveConstructor">s∙</a><a id="25635" class="Symbol">)))</a>

  <a id="25642" href="1Lab.Univalence.SIP.html#25642" class="Function">_</a> <a id="25644" class="Symbol">:</a> <a id="25646" class="Symbol">{</a><a id="25647" href="1Lab.Univalence.SIP.html#25647" class="Bound">A</a> <a id="25649" href="1Lab.Univalence.SIP.html#25649" class="Bound">B</a> <a id="25651" class="Symbol">:</a> <a id="25653" href="1Lab.Univalence.SIP.html#3349" class="Function">TypeWith</a> <a id="25662" href="1Lab.Univalence.SIP.html#25547" class="Function">Pointed∞Magma</a><a id="25675" class="Symbol">}</a> <a id="25677" class="Symbol">{</a><a id="25678" href="1Lab.Univalence.SIP.html#25678" class="Bound">f</a> <a id="25680" class="Symbol">:</a> <a id="25682" href="1Lab.Univalence.SIP.html#25647" class="Bound">A</a> <a id="25684" class="Symbol">.</a><a id="25685" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25689" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="25691" href="1Lab.Univalence.SIP.html#25649" class="Bound">B</a> <a id="25693" class="Symbol">.</a><a id="25694" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="25697" class="Symbol">}</a>
    <a id="25703" class="Symbol">→</a> <a id="25705" href="1Lab.Univalence.SIP.html#25547" class="Function">Pointed∞Magma</a> <a id="25719" class="Symbol">.</a><a id="25720" href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a> <a id="25727" href="1Lab.Univalence.SIP.html#25647" class="Bound">A</a> <a id="25729" href="1Lab.Univalence.SIP.html#25649" class="Bound">B</a> <a id="25731" href="1Lab.Univalence.SIP.html#25678" class="Bound">f</a>
    <a id="25737" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="25739" class="Symbol">(</a> <a id="25741" class="Symbol">(</a><a id="25742" href="1Lab.Univalence.SIP.html#25678" class="Bound">f</a> <a id="25744" class="Symbol">.</a><a id="25745" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25749" class="Symbol">(</a><a id="25750" href="1Lab.Univalence.SIP.html#25647" class="Bound">A</a> <a id="25752" class="Symbol">.</a><a id="25753" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25757" class="Symbol">.</a><a id="25758" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="25761" class="Symbol">)</a> <a id="25763" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="25765" href="1Lab.Univalence.SIP.html#25649" class="Bound">B</a> <a id="25767" class="Symbol">.</a><a id="25768" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25772" class="Symbol">.</a><a id="25773" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="25776" class="Symbol">)</a>
      <a id="25784" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="25786" class="Symbol">((</a><a id="25788" href="1Lab.Univalence.SIP.html#25788" class="Bound">x</a> <a id="25790" href="1Lab.Univalence.SIP.html#25790" class="Bound">y</a> <a id="25792" class="Symbol">:</a> <a id="25794" href="1Lab.Univalence.SIP.html#25647" class="Bound">A</a> <a id="25796" class="Symbol">.</a><a id="25797" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="25800" class="Symbol">)</a> <a id="25802" class="Symbol">→</a> <a id="25804" href="1Lab.Univalence.SIP.html#25678" class="Bound">f</a> <a id="25806" class="Symbol">.</a><a id="25807" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25811" class="Symbol">(</a><a id="25812" href="1Lab.Univalence.SIP.html#25647" class="Bound">A</a> <a id="25814" class="Symbol">.</a><a id="25815" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25819" class="Symbol">.</a><a id="25820" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25824" href="1Lab.Univalence.SIP.html#25788" class="Bound">x</a> <a id="25826" href="1Lab.Univalence.SIP.html#25790" class="Bound">y</a><a id="25827" class="Symbol">)</a>
                        <a id="25853" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="25855" href="1Lab.Univalence.SIP.html#25649" class="Bound">B</a> <a id="25857" class="Symbol">.</a><a id="25858" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25862" class="Symbol">.</a><a id="25863" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25867" class="Symbol">(</a><a id="25868" href="1Lab.Univalence.SIP.html#25678" class="Bound">f</a> <a id="25870" class="Symbol">.</a><a id="25871" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25875" href="1Lab.Univalence.SIP.html#25788" class="Bound">x</a><a id="25876" class="Symbol">)</a> <a id="25878" class="Symbol">(</a><a id="25879" href="1Lab.Univalence.SIP.html#25678" class="Bound">f</a> <a id="25881" class="Symbol">.</a><a id="25882" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25886" href="1Lab.Univalence.SIP.html#25790" class="Bound">y</a><a id="25887" class="Symbol">)))</a>
  <a id="25893" class="Symbol">_</a> <a id="25895" class="Symbol">=</a> <a id="25897" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>A homomorphic equivalence of pointed ∞-magmas is an equivalence of their underlying types that preserves the basepoint and is homomorphic over the operation. The use of <span class="Agda"><a href="1Lab.Univalence.SIP.html#24708" class="Function">tm→Action</a></span> in contravariant positions is responsible for making sure the computed <span class="Agda"><a href="1Lab.Univalence.SIP.html#2905" class="Field">is-hom</a></span> doesn’t have any redundant paths in argument positions.</p>
<p>A mutually <em>inductive</em> argument proves that <span class="Agda"><a href="1Lab.Univalence.SIP.html#24708" class="Function">tm→Action</a></span> produces transport structures, and that <span class="Agda"><a href="1Lab.Univalence.SIP.html#24657" class="Function">tm→Structure</a></span> produces univalent structures. At every case, the proof is by appeal to a lemma that was proved above.</p>
<pre class="Agda"><a id="tm→Structure-univalent"></a><a id="26476" href="1Lab.Univalence.SIP.html#26476" class="Function">tm→Structure-univalent</a> <a id="26499" class="Symbol">:</a> <a id="26501" class="Symbol">(</a><a id="26502" href="1Lab.Univalence.SIP.html#26502" class="Bound">s</a> <a id="26504" class="Symbol">:</a> <a id="26506" href="1Lab.Univalence.SIP.html#24012" class="Datatype">StrTm</a> <a id="26512" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="26514" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a> <a id="26517" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a><a id="26518" class="Symbol">)</a> <a id="26520" class="Symbol">→</a> <a id="26522" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="26534" class="Symbol">(</a><a id="26535" href="1Lab.Univalence.SIP.html#24657" class="Function">tm→Structure</a> <a id="26548" href="1Lab.Univalence.SIP.html#26502" class="Bound">s</a><a id="26549" class="Symbol">)</a>
<a id="tm→Action-isTransp"></a><a id="26551" href="1Lab.Univalence.SIP.html#26551" class="Function">tm→Action-isTransp</a> <a id="26570" class="Symbol">:</a> <a id="26572" class="Symbol">(</a><a id="26573" href="1Lab.Univalence.SIP.html#26573" class="Bound">s</a> <a id="26575" class="Symbol">:</a> <a id="26577" href="1Lab.Univalence.SIP.html#24012" class="Datatype">StrTm</a> <a id="26583" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="26585" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a> <a id="26588" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a><a id="26589" class="Symbol">)</a> <a id="26591" class="Symbol">→</a> <a id="26593" href="1Lab.Univalence.SIP.html#14134" class="Function">isTransportStr</a> <a id="26608" class="Symbol">(</a><a id="26609" href="1Lab.Univalence.SIP.html#24708" class="Function">tm→Action</a> <a id="26619" href="1Lab.Univalence.SIP.html#26573" class="Bound">s</a><a id="26620" class="Symbol">)</a>

<a id="26623" href="1Lab.Univalence.SIP.html#26476" class="Function">tm→Structure-univalent</a> <a id="26646" class="Symbol">(</a><a id="26647" href="1Lab.Univalence.SIP.html#24072" class="InductiveConstructor">s-const</a> <a id="26655" href="1Lab.Univalence.SIP.html#26655" class="Bound">x</a><a id="26656" class="Symbol">)</a> <a id="26658" class="Symbol">=</a> <a id="26660" href="1Lab.Univalence.SIP.html#6326" class="Function">constantStr-univalent</a>
<a id="26682" href="1Lab.Univalence.SIP.html#26476" class="Function">tm→Structure-univalent</a> <a id="26705" href="1Lab.Univalence.SIP.html#24128" class="InductiveConstructor">s∙</a> <a id="26708" class="Symbol">=</a> <a id="26710" href="1Lab.Univalence.SIP.html#7280" class="Function">pointedStr-univalent</a>
<a id="26731" href="1Lab.Univalence.SIP.html#26476" class="Function">tm→Structure-univalent</a> <a id="26754" class="Symbol">(</a><a id="26755" href="1Lab.Univalence.SIP.html#26755" class="Bound">s</a> <a id="26757" href="1Lab.Univalence.SIP.html#24160" class="InductiveConstructor Operator">s→</a> <a id="26760" href="1Lab.Univalence.SIP.html#26760" class="Bound">s₁</a><a id="26762" class="Symbol">)</a> <a id="26764" class="Symbol">=</a>
  <a id="26768" href="1Lab.Univalence.SIP.html#17282" class="Function">functionStr-univalent</a>
    <a id="26794" class="Symbol">(</a><a id="26795" href="1Lab.Univalence.SIP.html#24708" class="Function">tm→Action</a> <a id="26805" href="1Lab.Univalence.SIP.html#26755" class="Bound">s</a><a id="26806" class="Symbol">)</a> <a id="26808" class="Symbol">(</a><a id="26809" href="1Lab.Univalence.SIP.html#26551" class="Function">tm→Action-isTransp</a> <a id="26828" href="1Lab.Univalence.SIP.html#26755" class="Bound">s</a><a id="26829" class="Symbol">)</a>
    <a id="26835" class="Symbol">(</a><a id="26836" href="1Lab.Univalence.SIP.html#24657" class="Function">tm→Structure</a> <a id="26849" href="1Lab.Univalence.SIP.html#26760" class="Bound">s₁</a><a id="26851" class="Symbol">)</a> <a id="26853" class="Symbol">(</a><a id="26854" href="1Lab.Univalence.SIP.html#26476" class="Function">tm→Structure-univalent</a> <a id="26877" href="1Lab.Univalence.SIP.html#26760" class="Bound">s₁</a><a id="26879" class="Symbol">)</a>
<a id="26881" href="1Lab.Univalence.SIP.html#26476" class="Function">tm→Structure-univalent</a> <a id="26904" class="Symbol">(</a><a id="26905" href="1Lab.Univalence.SIP.html#26905" class="Bound">s</a> <a id="26907" href="1Lab.Univalence.SIP.html#24258" class="InductiveConstructor Operator">s×</a> <a id="26910" href="1Lab.Univalence.SIP.html#26910" class="Bound">s₁</a><a id="26912" class="Symbol">)</a> <a id="26914" class="Symbol">=</a>
  <a id="26918" href="1Lab.Univalence.SIP.html#7764" class="Function">productStr-univalent</a> <a id="26939" class="Symbol">{</a><a id="26940" class="Argument">σ</a> <a id="26942" class="Symbol">=</a> <a id="26944" href="1Lab.Univalence.SIP.html#24657" class="Function">tm→Structure</a> <a id="26957" href="1Lab.Univalence.SIP.html#26905" class="Bound">s</a><a id="26958" class="Symbol">}</a> <a id="26960" class="Symbol">{</a><a id="26961" class="Argument">τ</a> <a id="26963" class="Symbol">=</a> <a id="26965" href="1Lab.Univalence.SIP.html#24657" class="Function">tm→Structure</a> <a id="26978" href="1Lab.Univalence.SIP.html#26910" class="Bound">s₁</a><a id="26980" class="Symbol">}</a>
    <a id="26986" class="Symbol">(</a><a id="26987" href="1Lab.Univalence.SIP.html#26476" class="Function">tm→Structure-univalent</a> <a id="27010" href="1Lab.Univalence.SIP.html#26905" class="Bound">s</a><a id="27011" class="Symbol">)</a> <a id="27013" class="Symbol">(</a><a id="27014" href="1Lab.Univalence.SIP.html#26476" class="Function">tm→Structure-univalent</a> <a id="27037" href="1Lab.Univalence.SIP.html#26910" class="Bound">s₁</a><a id="27039" class="Symbol">)</a>

<a id="27042" href="1Lab.Univalence.SIP.html#26551" class="Function">tm→Action-isTransp</a> <a id="27061" class="Symbol">(</a><a id="27062" href="1Lab.Univalence.SIP.html#24072" class="InductiveConstructor">s-const</a> <a id="27070" href="1Lab.Univalence.SIP.html#27070" class="Bound">x</a><a id="27071" class="Symbol">)</a> <a id="27073" class="Symbol">=</a> <a id="27075" href="1Lab.Univalence.SIP.html#19578" class="Function">constantAction-isTransp</a>
<a id="27099" href="1Lab.Univalence.SIP.html#26551" class="Function">tm→Action-isTransp</a> <a id="27118" href="1Lab.Univalence.SIP.html#24128" class="InductiveConstructor">s∙</a> <a id="27121" class="Symbol">=</a> <a id="27123" href="1Lab.Univalence.SIP.html#19716" class="Function">idAction-isTransp</a>
<a id="27141" href="1Lab.Univalence.SIP.html#26551" class="Function">tm→Action-isTransp</a> <a id="27160" class="Symbol">(</a><a id="27161" href="1Lab.Univalence.SIP.html#27161" class="Bound">s</a> <a id="27163" href="1Lab.Univalence.SIP.html#24160" class="InductiveConstructor Operator">s→</a> <a id="27166" href="1Lab.Univalence.SIP.html#27166" class="Bound">s₁</a><a id="27168" class="Symbol">)</a> <a id="27170" class="Symbol">=</a>
  <a id="27174" href="1Lab.Univalence.SIP.html#20356" class="Function">functionAction-isTransp</a> <a id="27198" class="Symbol">{</a><a id="27199" class="Argument">α</a> <a id="27201" class="Symbol">=</a> <a id="27203" href="1Lab.Univalence.SIP.html#24708" class="Function">tm→Action</a> <a id="27213" href="1Lab.Univalence.SIP.html#27161" class="Bound">s</a><a id="27214" class="Symbol">}</a> <a id="27216" class="Symbol">{</a><a id="27217" class="Argument">β</a> <a id="27219" class="Symbol">=</a> <a id="27221" href="1Lab.Univalence.SIP.html#24708" class="Function">tm→Action</a> <a id="27231" href="1Lab.Univalence.SIP.html#27166" class="Bound">s₁</a><a id="27233" class="Symbol">}</a>
    <a id="27239" class="Symbol">(</a><a id="27240" href="1Lab.Univalence.SIP.html#26551" class="Function">tm→Action-isTransp</a> <a id="27259" href="1Lab.Univalence.SIP.html#27161" class="Bound">s</a><a id="27260" class="Symbol">)</a> <a id="27262" class="Symbol">(</a><a id="27263" href="1Lab.Univalence.SIP.html#26551" class="Function">tm→Action-isTransp</a> <a id="27282" href="1Lab.Univalence.SIP.html#27166" class="Bound">s₁</a><a id="27284" class="Symbol">)</a>
<a id="27286" href="1Lab.Univalence.SIP.html#26551" class="Function">tm→Action-isTransp</a> <a id="27305" class="Symbol">(</a><a id="27306" href="1Lab.Univalence.SIP.html#27306" class="Bound">s</a> <a id="27308" href="1Lab.Univalence.SIP.html#24258" class="InductiveConstructor Operator">s×</a> <a id="27311" href="1Lab.Univalence.SIP.html#27311" class="Bound">s₁</a><a id="27313" class="Symbol">)</a> <a id="27315" class="Symbol">=</a>
  <a id="27319" href="1Lab.Univalence.SIP.html#19953" class="Function">productAction-isTransp</a> <a id="27342" class="Symbol">{</a><a id="27343" class="Argument">α</a> <a id="27345" class="Symbol">=</a> <a id="27347" href="1Lab.Univalence.SIP.html#24708" class="Function">tm→Action</a> <a id="27357" href="1Lab.Univalence.SIP.html#27306" class="Bound">s</a><a id="27358" class="Symbol">}</a> <a id="27360" class="Symbol">{</a><a id="27361" class="Argument">β</a> <a id="27363" class="Symbol">=</a> <a id="27365" href="1Lab.Univalence.SIP.html#24708" class="Function">tm→Action</a> <a id="27375" href="1Lab.Univalence.SIP.html#27311" class="Bound">s₁</a><a id="27377" class="Symbol">}</a>
    <a id="27383" class="Symbol">(</a><a id="27384" href="1Lab.Univalence.SIP.html#26551" class="Function">tm→Action-isTransp</a> <a id="27403" href="1Lab.Univalence.SIP.html#27306" class="Bound">s</a><a id="27404" class="Symbol">)</a> <a id="27406" class="Symbol">(</a><a id="27407" href="1Lab.Univalence.SIP.html#26551" class="Function">tm→Action-isTransp</a> <a id="27426" href="1Lab.Univalence.SIP.html#27311" class="Bound">s₁</a><a id="27428" class="Symbol">)</a>
</pre>
<h2 id="descriptions-of-structures">Descriptions of Structures</h2>
<p>To make convenient descriptions of structures-with-axioms, we introduce a record type, <span class="Agda"><a href="1Lab.Univalence.SIP.html#27667" class="Record">StrDesc</a></span>, which packages together the structure term and the properties that are imposed:</p>
<pre class="Agda"><a id="27660" class="Keyword">record</a> <a id="StrDesc"></a><a id="27667" href="1Lab.Univalence.SIP.html#27667" class="Record">StrDesc</a> <a id="27675" href="1Lab.Univalence.SIP.html#27675" class="Bound">ℓ</a> <a id="27677" href="1Lab.Univalence.SIP.html#27677" class="Bound">ℓ₁</a> <a id="27680" href="1Lab.Univalence.SIP.html#27680" class="Bound">S</a> <a id="27682" href="1Lab.Univalence.SIP.html#27682" class="Bound">ax</a> <a id="27685" class="Symbol">:</a> <a id="27687" href="1Lab.Type.html#409" class="Primitive">Typeω</a> <a id="27693" class="Keyword">where</a>
  <a id="27701" class="Keyword">field</a>
    <a id="StrDesc.descriptor"></a><a id="27711" href="1Lab.Univalence.SIP.html#27711" class="Field">descriptor</a> <a id="27722" class="Symbol">:</a> <a id="27724" href="1Lab.Univalence.SIP.html#24012" class="Datatype">StrTm</a> <a id="27730" href="1Lab.Univalence.SIP.html#27675" class="Bound">ℓ</a> <a id="27732" href="1Lab.Univalence.SIP.html#27677" class="Bound">ℓ₁</a> <a id="27735" href="1Lab.Univalence.SIP.html#27680" class="Bound">S</a>

    <a id="StrDesc.axioms"></a><a id="27742" href="1Lab.Univalence.SIP.html#27742" class="Field">axioms</a> <a id="27749" class="Symbol">:</a> <a id="27751" class="Symbol">∀</a> <a id="27753" href="1Lab.Univalence.SIP.html#27753" class="Bound">X</a> <a id="27755" class="Symbol">→</a> <a id="27757" href="1Lab.Univalence.SIP.html#27680" class="Bound">S</a> <a id="27759" href="1Lab.Univalence.SIP.html#27753" class="Bound">X</a> <a id="27761" class="Symbol">→</a> <a id="27763" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="27768" href="1Lab.Univalence.SIP.html#27682" class="Bound">ax</a>
    <a id="StrDesc.axioms-prop"></a><a id="27775" href="1Lab.Univalence.SIP.html#27775" class="Field">axioms-prop</a> <a id="27787" class="Symbol">:</a> <a id="27789" class="Symbol">∀</a> <a id="27791" href="1Lab.Univalence.SIP.html#27791" class="Bound">X</a> <a id="27793" href="1Lab.Univalence.SIP.html#27793" class="Bound">s</a> <a id="27795" class="Symbol">→</a> <a id="27797" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="27804" class="Symbol">(</a><a id="27805" href="1Lab.Univalence.SIP.html#27742" class="Field">axioms</a> <a id="27812" href="1Lab.Univalence.SIP.html#27791" class="Bound">X</a> <a id="27814" href="1Lab.Univalence.SIP.html#27793" class="Bound">s</a><a id="27815" class="Symbol">)</a>

<a id="Desc→Fam"></a><a id="27818" href="1Lab.Univalence.SIP.html#27818" class="Function">Desc→Fam</a> <a id="27827" class="Symbol">:</a> <a id="27829" class="Symbol">∀</a> <a id="27831" class="Symbol">{</a><a id="27832" href="1Lab.Univalence.SIP.html#27832" class="Bound">ax</a><a id="27834" class="Symbol">}</a> <a id="27836" class="Symbol">→</a> <a id="27838" href="1Lab.Univalence.SIP.html#27667" class="Record">StrDesc</a> <a id="27846" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="27848" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a> <a id="27851" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="27853" href="1Lab.Univalence.SIP.html#27832" class="Bound">ax</a> <a id="27856" class="Symbol">→</a> <a id="27858" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="27863" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="27865" class="Symbol">→</a> <a id="27867" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="27872" class="Symbol">(</a><a id="27873" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a> <a id="27876" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="27878" href="1Lab.Univalence.SIP.html#27832" class="Bound">ax</a><a id="27880" class="Symbol">)</a>
<a id="27882" href="1Lab.Univalence.SIP.html#27818" class="Function">Desc→Fam</a> <a id="27891" class="Symbol">{</a><a id="27892" class="Argument">S</a> <a id="27894" class="Symbol">=</a> <a id="27896" href="1Lab.Univalence.SIP.html#27896" class="Bound">S</a><a id="27897" class="Symbol">}</a> <a id="27899" href="1Lab.Univalence.SIP.html#27899" class="Bound">desc</a> <a id="27904" href="1Lab.Univalence.SIP.html#27904" class="Bound">X</a> <a id="27906" class="Symbol">=</a>
  <a id="27910" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="27913" href="1Lab.Univalence.SIP.html#27913" class="Bound">S</a> <a id="27915" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="27917" href="1Lab.Univalence.SIP.html#27896" class="Bound">S</a> <a id="27919" href="1Lab.Univalence.SIP.html#27904" class="Bound">X</a> <a id="27921" href="1Lab.Type.html#1563" class="Function">]</a>
    <a id="27927" class="Symbol">(</a><a id="27928" href="1Lab.Univalence.SIP.html#27899" class="Bound">desc</a> <a id="27933" class="Symbol">.</a><a id="27934" href="1Lab.Univalence.SIP.html#27742" class="Field">StrDesc.axioms</a> <a id="27949" class="Symbol">_</a> <a id="27951" href="1Lab.Univalence.SIP.html#27913" class="Bound">S</a><a id="27952" class="Symbol">)</a>

<a id="Desc→Str"></a><a id="27955" href="1Lab.Univalence.SIP.html#27955" class="Function">Desc→Str</a> <a id="27964" class="Symbol">:</a> <a id="27966" class="Symbol">∀</a> <a id="27968" class="Symbol">{</a><a id="27969" href="1Lab.Univalence.SIP.html#27969" class="Bound">ax</a><a id="27971" class="Symbol">}</a> <a id="27973" class="Symbol">→</a> <a id="27975" class="Symbol">(</a><a id="27976" href="1Lab.Univalence.SIP.html#27976" class="Bound">S</a> <a id="27978" class="Symbol">:</a> <a id="27980" href="1Lab.Univalence.SIP.html#27667" class="Record">StrDesc</a> <a id="27988" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="27990" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a> <a id="27993" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="27995" href="1Lab.Univalence.SIP.html#27969" class="Bound">ax</a><a id="27997" class="Symbol">)</a> <a id="27999" class="Symbol">→</a> <a id="28001" href="1Lab.Univalence.SIP.html#1977" class="Record">Structure</a> <a id="28011" class="Symbol">_</a> <a id="28013" class="Symbol">(</a><a id="28014" href="1Lab.Univalence.SIP.html#27818" class="Function">Desc→Fam</a> <a id="28023" href="1Lab.Univalence.SIP.html#27976" class="Bound">S</a><a id="28024" class="Symbol">)</a>
<a id="28026" href="1Lab.Univalence.SIP.html#27955" class="Function">Desc→Str</a> <a id="28035" href="1Lab.Univalence.SIP.html#28035" class="Bound">desc</a> <a id="28040" class="Symbol">=</a> <a id="28042" href="1Lab.Univalence.SIP.html#21864" class="Function">axiomsStr</a> <a id="28052" class="Symbol">(</a><a id="28053" href="1Lab.Univalence.SIP.html#24657" class="Function">tm→Structure</a> <a id="28066" href="1Lab.Univalence.SIP.html#27711" class="Field">descriptor</a><a id="28076" class="Symbol">)</a> <a id="28078" href="1Lab.Univalence.SIP.html#27742" class="Field">axioms</a>
  <a id="28087" class="Keyword">where</a> <a id="28093" class="Keyword">open</a> <a id="28098" href="1Lab.Univalence.SIP.html#27667" class="Module">StrDesc</a> <a id="28106" href="1Lab.Univalence.SIP.html#28035" class="Bound">desc</a>

<a id="Desc→isUnivalent"></a><a id="28112" href="1Lab.Univalence.SIP.html#28112" class="Function">Desc→isUnivalent</a> <a id="28129" class="Symbol">:</a> <a id="28131" class="Symbol">∀</a> <a id="28133" class="Symbol">{</a><a id="28134" href="1Lab.Univalence.SIP.html#28134" class="Bound">ax</a><a id="28136" class="Symbol">}</a> <a id="28138" class="Symbol">→</a> <a id="28140" class="Symbol">(</a><a id="28141" href="1Lab.Univalence.SIP.html#28141" class="Bound">S</a> <a id="28143" class="Symbol">:</a> <a id="28145" href="1Lab.Univalence.SIP.html#27667" class="Record">StrDesc</a> <a id="28153" href="1Lab.Univalence.SIP.html#3483" class="Generalizable">ℓ</a> <a id="28155" href="1Lab.Univalence.SIP.html#3485" class="Generalizable">ℓ₁</a> <a id="28158" href="1Lab.Univalence.SIP.html#3517" class="Generalizable">S</a> <a id="28160" href="1Lab.Univalence.SIP.html#28134" class="Bound">ax</a><a id="28162" class="Symbol">)</a> <a id="28164" class="Symbol">→</a> <a id="28166" href="1Lab.Univalence.SIP.html#3864" class="Function">isUnivalent</a> <a id="28178" class="Symbol">(</a><a id="28179" href="1Lab.Univalence.SIP.html#27955" class="Function">Desc→Str</a> <a id="28188" href="1Lab.Univalence.SIP.html#28141" class="Bound">S</a><a id="28189" class="Symbol">)</a>
<a id="28191" href="1Lab.Univalence.SIP.html#28112" class="Function">Desc→isUnivalent</a> <a id="28208" href="1Lab.Univalence.SIP.html#28208" class="Bound">desc</a> <a id="28213" class="Symbol">=</a>
  <a id="28217" href="1Lab.Univalence.SIP.html#22253" class="Function">axiomsStr-univalent</a>
    <a id="28241" class="Symbol">(</a><a id="28242" href="1Lab.Univalence.SIP.html#24657" class="Function">tm→Structure</a> <a id="28255" href="1Lab.Univalence.SIP.html#27711" class="Function">descriptor</a><a id="28265" class="Symbol">)</a> <a id="28267" href="1Lab.Univalence.SIP.html#27742" class="Function">axioms</a>
    <a id="28278" class="Symbol">(</a><a id="28279" href="1Lab.Univalence.SIP.html#26476" class="Function">tm→Structure-univalent</a> <a id="28302" href="1Lab.Univalence.SIP.html#27711" class="Function">descriptor</a><a id="28312" class="Symbol">)</a> <a id="28314" class="Symbol">(λ</a> <a id="28317" class="Symbol">{</a><a id="28318" href="1Lab.Univalence.SIP.html#28318" class="Bound">X</a><a id="28319" class="Symbol">}</a> <a id="28321" class="Symbol">{</a><a id="28322" href="1Lab.Univalence.SIP.html#28322" class="Bound">s</a><a id="28323" class="Symbol">}</a> <a id="28325" class="Symbol">→</a> <a id="28327" href="1Lab.Univalence.SIP.html#27775" class="Function">axioms-prop</a> <a id="28339" href="1Lab.Univalence.SIP.html#28318" class="Bound">X</a> <a id="28341" href="1Lab.Univalence.SIP.html#28322" class="Bound">s</a><a id="28342" class="Symbol">)</a>
  <a id="28346" class="Keyword">where</a> <a id="28352" class="Keyword">open</a> <a id="28357" href="1Lab.Univalence.SIP.html#27667" class="Module">StrDesc</a> <a id="28365" href="1Lab.Univalence.SIP.html#28208" class="Bound">desc</a>
</pre>
  </article>
</div>

</main>
</body>
</html>